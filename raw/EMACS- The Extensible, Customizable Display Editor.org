#+TITLE: EMACS: The Extensible, Customizable Display Editor
#+URL: https://www.gnu.org/software/emacs/emacs-paper.html
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2020年 01月 15日 星期三 15:23:34 HKT]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
* EMACS: The Extensible, Customizable Display Editor
:PROPERTIES:
:CUSTOM_ID: emacs-the-extensible-customizable-display-editor
:END:

This paper was written by Richard Stallman in 1981 and delivered in the ACM Conference on Text Processing.
翻译:这篇文章是由理查德·马修·斯托曼（Richard Matthew Stallman）于1981年撰写的，并在ACM文本处理会议上发表。

** Table of Contents
:PROPERTIES:
:CUSTOM_ID: table-of-contents
:END:

EMACS[[#FOOT1][(1)]] is a real-time display editor which can be extended by the user while it is running.
翻译:Emacs 是一个实时显示编辑器，可以在运行时由用户进行扩展。[

Extensibility means that the user can add new editing commands or change old ones to fit his editing needs, while he is editing. EMACS is written in a modular fashion, composed of many separate and independent functions. The user extends EMACS by adding or replacing functions, writing their definitions in the same language that was used to write the original EMACS system. We will explain below why this is the only method of extension which is practical in use: others are theoretically equally good but discourage use, or discourage nontrivial use.
翻译:可扩展性意味着用户可以在编辑过程中添加新的编辑命令或更改旧命令以满足他的编辑需求。EMACS 是以模块化的方式编写的，由许多独立且相互分离的功能组成。用户通过添加或替换函数来扩展 EMACS，用编写原始 EMACS 系统相同的语言定义它们。下面我们将解释为什么这是唯一实用的扩展方法：其他方法在理论上同样优秀，但会抑制使用，或者抑制非 trivial 使用。

Extensibility makes EMACS more flexible than any other editor. Users are not limited by the decisions made by the EMACS implementors. What we decide is not worth while to add, the user can provide for himself. He can just as easily provide his own alternative to a feature if he does not like the way it works in the standard system.
翻译:可扩展性使EMACS比其他任何编辑器都更灵活。用户不会受到EMACS实现者所做的决定的限制。我们认为不值得添加的功能，用户可以自己提供。如果用户不喜欢标准系统中某个功能的运作方式，他同样可以轻松地提供自己的替代方案。

A coherent set of new and redefined functions can be bound into a library so that the user can load them together conveniently. Libraries enable users to publish and share their extensions, which then become effectively part of the basic system. By this route, many people can contribute to the development of the system, for the most part without interfering with each other. This has led the EMACS system to become more powerful than any previous editor.
翻译:一个连贯的新函数和重新定义的函数集可以被绑定到一个库中，这样用户就可以方便地一起加载它们。库使用户能够发布并共享他们的扩展程序，从而使这些扩展程序实际上成为基本系统的一部分。通过这种方式，许多人可以贡献于系统的开发，而大部分情况下不会相互干扰。这使得EMACS系统比任何以前的编辑器都要强大。

User customization helps in another, subtler way, by making the whole user community into a breeding and testing ground for new ideas. Users think of small changes, try them, and give them to other users--if an idea becomes popular, it can be incorporated into the core system. When we poll users on suggested changes, they can respond on the basis of actual experience rather than thought experiments.
翻译:用户自定义以另一种更微妙的方式发挥作用，它使整个用户社区成为新想法的孕育和测试场所。用户会想到一些小的改动，尝试它们，然后将它们提供给其他用户——如果一个主意变得流行起来，它可以被整合到核心系统中。当我们就建议的更改对用户进行调查时，他们可以根据实际经验而不是思想实验来做出回应。

To help the user make effective use of the copious supply of features, EMACS provides powerful and complete interactive self-documentation facilities with which the user can find out what is available.
翻译:为了帮助用户有效地利用丰富的特性，Emacs 提供了强大而完整的交互式自文档功能，使用户可以找到可用信息。

A sign of the success of the EMACS design is that EMACS has been requested by over a hundred sites and imitated at least ten times.
翻译:成功的EMACS设计的标志是，已有100多个站点请求使用EMACS，至少有10个地方对其进行了模仿。

By a display editor we mean an editor in which the text being edited is normally visible on the screen and is updated automatically as the user types his commands. No explicit commands to `print' text are needed.
翻译:我们所说的显示编辑器是一种编辑器，在其中被编辑的文本通常会在屏幕上可见，并且会随着用户的命令自动更新。不需要显式地使用`打印`文本的命令。

As compared with printing terminal editors, display editor users have much less need for paper listings, and can compose code quickly on line without writing it on paper first. Display editors are also easier to learn than printing terminal editors. This is because editing on a printing terminal requires a mental skill like that of blindfold chess; the user must keep a mental image of the text he is editing, which he cannot easily see, and calculate how each of his editing command `moves' changes it. A display editor makes this unnecessary by allowing the user to see the `board'.
翻译:与打印终端编辑器相比，显示编辑器的用户很少需要纸面列表，可以在线上快速编写代码而不必先写在纸上。显示编辑器也比打印终端编辑器更容易学习。这是因为在一个打印终端上进行编辑需要一个类似于盲棋的心理技能；用户必须在大脑中保留他所编辑的文本的形象，而这个形象他不容易看到，并且计算他的每个编辑命令`移动`如何改变它。通过允许用户看到“棋盘”，显示编辑器使得这一切变得不必要的。

Among display editors, a real-time editor is one which updates the display very frequently, usually after each one or two character command the user types. This is a matter of the input command language. Most printing terminal editors read a string of commands and process it all at once; a useful feature on a printing terminal. For example, there is usually an `insert' command which inserts a string of characters. When such editors are adapted to display terminals, they often update the display at the end of a command string; thus, the insertion would be shown all at once when it was over. It is more helpful to display each inserted character in its position in the text as soon as it has been typed.
翻译:在显示编辑器中，实时编辑器是指它非常频繁地更新显示器，通常是在用户输入每个或两个字符命令后。这涉及到输入命令语言的问题。大多数打印终端编辑器读取一串命令并一次性处理；这在打印终端上是一个有用的功能。例如，通常有一个`插入`命令可以插入一串字符。当这样的编辑器适应显示终端时，它们通常在命令字符串结束时更新显示器；因此，插入会在完成后一次显示出来。更有效的方法是，一旦键入就立即在文本中的相应位置显示每个插入的字符。

A real-time display editor has (primarily!) short, simple commands which show their effects in the display as soon as they are typed. In EMACS, text (printing characters and formatting characters) is inserted just by typing it; there is no `insert' command. In other words, each printing character is a command to insert that character. The commands for modifying text are nonprinting characters, or begin with nonprinting characters. Many-character commands echo if typed slowly; if there is a sufficiently long pause, the command so far is echoed, and then the rest of the command is echoed as it is typed. Aside from this, EMACS acknowledges commands by displaying their effects.
翻译:实时显示编辑器（主要是！）具有简短、简单的命令，这些命令在键入后会立即在显示器上显示出其效果。在EMACS中，文本（打印字符和格式化字符）的插入只需通过键入即可；没有“插入”命令。换句话说，每个打印字符都是一个插入该字符的命令。修改文本的命令是非打印字符或以非打印字符开头。许多字符的命令如果慢慢输入会回显；如果在足够长的时间内暂停，则会回显到目前为止的命令，然后其余的命令随着键入而逐个回显。除此之外，EMACS通过显示命令的效果来确认命令。

EMACS is not the first real-time display editor, but it derives much appeal from being one. It is not necessary to know how to program, or how to extend EMACS, to use it successfully.
翻译:Emacs 并不是第一个真正的实时显示编辑器，但它正因为这一点而具有很大的吸引力。使用 Emacs 不需要知道如何编程，或者如何扩展 Emacs。

To illustrate and demonstrate the flexibility which EMACS derives from extensibility, here is a summary of many of the features, available to EMACS users without the need to program, to which extensibility has contributed. Many of them were written by users; some were written by the author, but could just as well have been written by users.
翻译:为了说明和演示EMACS从可扩展性中获得的多功能性，这里总结了无需编程即可提供给EMACS用户的许多功能，这些功能都是可扩展性所贡献的。其中许多是由用户编写的；有些是由作者编写的，但同样也可以由用户编写。

Many minor extensions can be done without any programming. These are called customizations, and are very useful even by themselves. For example, for editing a program in which comments start with `<**' and end with `**>', the user can tell the EMACS comment manipulation commands to recognize and insert those strings. This is done by setting parameters which the comment commands refer to. It is not necessary to redefine the commands themselves. Another sort of customization is rearrangement of the command set. For example, some users prefer the four basic cursor motion commands (up, down, left and right) on keys in a diamond pattern on the keyboard. It is easy to reassign the commands to these positions. It is also possible to rearrange the entire command set according to a different philosophy.
翻译:许多小扩展可以在不进行任何编程的情况下完成。这些被称为自定义设置，即使单独使用也非常有用。例如，对于编辑一个注释以 `<**' 开始并以 `**>` 结束的程序，用户可以告诉EMACS评论操作命令识别并插入这些字符串。这是通过设置参数来完成的，这些参数是评论命令所引用的。没有必要重新定义命令本身。另一种自定义类型是命令集的重排。例如，一些用户更喜欢在键盘上的菱形图案键上放置四个基本的光标移动命令（上、下、左和右）。将这些命令分配到这些位置很容易。根据不同的哲学思想，也可以重新排列整个命令集。

EMACS can be programmed to understand the syntax of the language being edited and provide operations particular to it. Many major modes are defined, one for each language which is understood. Each major mode has the ability to redefine any of the commands, and reset any parameters, so as to customize EMACS for that language. Files can contain special text strings that tell EMACS which major mode to use in editing them. For example, `-*-Lisp-*-' anywhere in the first nonblank line of a file says that the file should be edited in Lisp mode. The string would normally be enclosed in a comment.
翻译:Emacs 可以被编程以理解正在编辑的语言的语法并提供特定于它的操作。已经定义了许多主要模式，每一种对应一种已知的语言。每种主要模式都有能力重新定义任何命令和重置任何参数，以便为那种语言定制 Emacs。文件可以包含特殊文本字符串，告诉 Emacs 在编辑时应使用哪种主要模式。例如，文件第一行非空白处的 `-*-Lisp-*-' 表示该文件应该用 Lisp 模式进行编辑。通常情况下，这个字符串会被注释括起来。

For editing English text, commands have been written to move the cursor by words, sentences and paragraphs, and to delete them; to fill and justify paragraphs; and to move blocks of text to the left or to the right. Other commands convert single words or whole regions to upper or lower case. There are also commands which manipulate the command strings for text justifier programs: some insert or delete underlining commands, and others insert or delete font-change commands.
翻译:对于编辑英文文本，已经编写了通过单词、句子和段落移动光标，以及删除它们的命令；填充和调整段落对齐方式；以及将文本块向左或向右移动的命令。还有将单个单词或整个区域转换为大写或小写的命令。此外，还有一些操纵用于文本对齐程序命令字符串的命令：一些插入或删除下划线命令，而另一些则插入或删除字体更改命令。

Many commands are controlled by parameters which can be used to further adapt them to particular styles of formatting. For example, the word moving and deletion commands have a syntax table that says which characters are parts of words. There are two commands to edit this table, one convenient for programs to use and an interactive one for the user. The paragraph commands can be told which strings, appearing at the beginning of a line, constitute the beginning of a paragraph. Such parameters can be set by the user, or by a specification in the file being edited. But normally they are set automatically by the major mode (that is, by telling EMACS what language the file is written in) and do not require attention from the user.
翻译:许多命令都受参数的控制，可以使用这些参数进一步适应特定的格式风格。例如，“移动”和“删除”命令有一个语法表，说明哪些字符是单词的一部分。有两个命令可以编辑这个表格，一个方便程序使用，另一个为用户提供交互式功能。段落命令可以告诉哪些字符串，出现在一行开头，构成段落的开始。这样的参数可以通过用户设置，或者通过正在编辑的文件中的规范设置。但通常情况下，它们会由主要模式（即告诉EMACS文件是用什么语言编写的）自动设置，不需要用户的关注。

A very powerful extension facility is the ability to redefine the graphic and formatting characters as commands. These characters, which include letters, digits and punctuation, are normally all defined as commands to insert themselves into the text. Useful alternate definitions for these characters usually insert the character as usual, and then do additional processing which is in some way meaningfully associated with the insertion of that character.
翻译:一个强大的扩展功能是能够重新定义图形和格式字符为命令。这些字符包括字母、数字和标点符号，通常都被定义为插入到文本中的命令。对于这些字符的有用替代定义通常是按常规插入字符，然后执行与该字符插入有意义关联的额外处理。

The single most useful command for editing text is the `auto-fill space'. It is a program intended to be used as the definition of the space character. In addition to inserting a space, it breaks the line into two lines if it has become too long. With the space character redefined in this way, the user can type endlessly ignoring the right margin, and the text is divided into lines of a reasonable length. Of course, this feature is not always desirable. It is turned on or off by redefining the space command. If the auto-fill space did not exist, any user could write it and also the command to turn it on and off.
翻译:编辑文本最常用的命令是“自动填充空格”。它是一个旨在作为空格字符定义的程序。除了插入空格外，如果行变得过长，它还会将其拆分为两行。以这种方式重新定义空格字符后，用户可以无限地输入而忽略右边界，文本将被分成合理长度的行。当然，这个功能并不总是受欢迎的。通过重新定义空格命令来打开或关闭此功能。如果不存在自动填充空格，任何用户都可以编写它以及打开和关闭它的命令。

A bolder use of redefinition of self-inserting characters is the abbreviation facility, part of the standard EMACS system but still implemented as an extension maintained by the user who wrote it. The abbreviation facility allows the user to define abbreviations for words, and then type the abbreviations in order to insert the words. For example, if `cd' were defined as an abbreviation for `command', typing `i/o-cd' would insert `i/o-command' into the text. Abbreviation expansion preserves case, so `Cd' would expand into `Command'. Abbreviation works by redefining all punctuation characters (the list of which can be altered by customization) to run a program which looks at the preceding word and, if it is a defined abbreviation, replaces it with its expansion.
翻译:更积极地使用自插入字符的重定义功能是缩写功能，这是标准EMACS系统的一部分，但仍然由编写它的用户实现的扩展。缩写功能允许用户为单词定义缩写，然后输入缩写以插入单词。例如，如果将`cd`定义为`command`的缩写，则输入`i/o-cd`会将`i/o-command`插入到文本中。缩写扩展会保留大小写，所以`Cd`会展开为`Command`。缩写通过重新定义所有标点符号（可以通过定制更改该列表）来实现，它运行一个程序来查看前面的单词，如果它是已定义的缩写，则将其替换为其展开形式。

Yet another application of redefining printing characters is automatic parenthesis-matching. When this feature is in use, every time the user inserts a close-parenthesis, the cursor moves briefly to the matching open-parenthesis, then back again. Automatic matching is especially useful in editing Lisp code, but it is helpful with most other programming languages also. It is implemented by redefining the close-parenthesis character.
翻译:重新定义打印字符的另一个应用是自动括号匹配。当使用此功能时，每次用户插入一个闭合括号，光标会短暂地移动到与之匹配的开括号上，然后再次返回。自动匹配在编辑Lisp代码时特别有用，但对大多数其他编程语言也有帮助。它是通过重新定义闭合括号字符来实现的。

Extensibility is especially useful for editing programs. One might conceivably design in advance all the editing commands needed for editing English text, but each programming language has its own set of useful syntactic operations, which suggest useful editing commands. Because languages differ so much, simple customization is not in general enough to implement familiar operations for a new language. A new extension package is required.
翻译:可扩展性对于编辑程序特别有用。人们可能事先设计出所有用于编辑英文文本的编辑命令，但每种编程语言都有自己的有用语法操作，这会暗示有用的编辑命令。因为语言之间差异很大，所以简单的自定义通常不足以实现新语言的熟悉操作。需要一个全新的扩展包。

EMACS commands have been written, for many languages, to move over or kill balanced expressions, to move to the beginning or end of a function definition, and to insert or align comments. But the most useful editing operation for programs, and the first one to be implemented for any programming language, is automatic indentation.
翻译:emacs命令已经被编写出来，用于许多语言，可以移动或删除平衡表达式，移动到函数定义的开始或结束位置，以及插入或对齐注释。但对于程序来说最有用的编辑操作，并且是任何编程语言首先实现的，是自动缩进。

The structure of a program can be made clear at a glance by adjusting the indentation of each line according to its level of nesting. Most programming communities attempt to indent code properly but do it manually. Automatic indentation is used mostly by Lisp programmers.
翻译:通过根据嵌套级别调整每行代码的缩进，可以一目了然地使程序结构清晰。大多数编程社区都试图正确地对代码进行缩进，但这是手动进行的。自动缩进主要被Lisp程序员使用。

Automatic indentation was traditionally done by a program which would read in an entire source file, rearrange the indentation, and write out a corrected source file. Such a tool has several disadvantages. For one thing, processing the entire file is likely to take a while. For another, the tool insists on imposing its own idea of proper formatting, which the user cannot override. Even after a lot of effort is put into heuristics for good indentation, users are still dissatisfied.
翻译:自动缩进传统上是由一个程序完成的，该程序会读取整个源文件，重新排列缩进，并写出修正后的源文件。这样的工具有几个缺点。首先，处理整个文件可能需要一段时间。其次，工具坚持将自己的正确格式想法强加给用户，用户无法覆盖。即使在很大程度上投入了用于良好缩进的启发式方法，用户仍然不满意。

Automatic indentation in EMACS is done incrementally. The Tab character is redefined, as a command, to update the indentation of the current line only, based on the existing indentation of the preceding lines. The Tab command is used on lines whose nesting has changed. With it, the user can indent code properly as it is first typed in. If he does not agree with the Tab command's choice of indentation, he can override it.
翻译:自动缩进在EMACS中是增量进行的。制表符（Tab）字符被重新定义为一条命令，仅根据前一行现有的缩进来更新当前行的缩进。当行嵌套发生变化时使用Tab命令。有了它，用户可以在键入代码时就正确地进行缩进。如果用户不同意Tab命令选择的缩进方式，可以覆盖它。

Because the indentation function must understand the syntax of the programming language being edited, each language requires a separate indentation function. It is the job of the major mode for each programming language to redefine the Tab character to run an appropriate indenter. Users can always use the same command to indent, no matter what sort of program they are editing. In addition, another editing command can do indentation by calling the current definition of Tab as a subroutine. (One such function is the one which indents several consecutive lines.)
翻译:因为缩进功能必须理解正在编辑的编程语言的语法，每种语言都需要一个单独的缩进函数。每个编程语言的默认模式负责重新定义Tab字符以运行合适的缩进程序。无论用户编辑的是哪种类型的程序，他们都可以始终使用相同的命令进行缩进。此外，另一个编辑命令可以通过调用当前Tab的定义作为子例程来进行缩进。（其中一个功能是同时对连续几行进行缩进。）

Conventions such as this are vital, in an extensible system, for enabling unrelated extensions to avoid interacting wrong; one user can write an indentation function for a new language, while another user writes new language-independent operations for requesting indentation, and the two automatically work properly together.
翻译:这样的约定在可扩展系统中至关重要，它使得无关的扩展能够避免相互干扰；一个用户可以为新的语言编写缩进函数，而另一个用户可以为请求缩进编写不依赖于特定语言的操作，两者可以自动正确地协同工作。

Languages which have support for indentation include Lisp, Pascal, PL/I, Bliss, BCPL, Muddle and TECO.
翻译:支持缩进的编程语言包括Lisp、Pascal、PL/I、Bliss、BCPL、Muddle和TECO。

Comprehension of the user's program reaches its greatest heights for Lisp programs, because the simplicity of Lisp syntax makes intelligent editing operations easier to implement, while the complexity of other languages discourages their users from implementing similar operations for them. In fact, EMACS offers most of the same facilities as editors such as the Interlisp editor which operate on list structure, but combined with display editing. The simple syntax of Lisp, together with the powerful editing features made possible by that simple syntax, add up to a more convenient programming system than is practical with other languages. Lisp and extensible editors are made for each other, in this way. We will see below that this is not the only way.
翻译:理解用户的程序达到顶峰的是Lisp程序，因为Lisp语法的简单性使得智能编辑操作更容易实现，而其他语言的复杂性则阻碍了它们的用户为他们实现类似的操作。事实上，EMACS提供了与Interlisp编辑器等基于列表结构的编辑器相同的大多数功能，但结合了显示编辑。Lisp的简单语法，加上由这种简单语法所支持的强大编辑功能，构成了比其他语言更方便的程序设计系统。Lisp和可扩展编辑器是相互匹配的，我们将看到这并非唯一的方式。

Large programs are composed of many functions divided among many files. It is often hard to remember which file a given function is in. An EMACS extension called the TAGS package knows how to keep track of this.
翻译:大程序由许多函数组成，这些函数分布在许多文件中。通常很难记住某个给定的函数在哪个文件中。一个称为TAGS的EMACS扩展知道如何跟踪这一点。

The TAGS package makes use of a file called a tag table, which records each function in the program, stating what file it is defined in and at what position in the file. The tag table is made by running a special program named TAGS, which is not part of EMACS. Once the tag table is loaded into EMACS, the command Meta--Period[[#FOOT2][(2)]] finds the definition of any function, using the information in the tag table to select the proper file and find the function in it.
翻译:TAGS包使用一个称为标签表的文件，它记录程序中的每个函数，说明它是定义在哪个文件中以及在该文件的什么位置。标签表是通过运行一个名为TAGS的特殊程序来生成的，这个程序不是EMACS的一部分。一旦将标签表加载到EMACS中，命令Meta--Period[[#FOOT2][(2)]]就会找到任何函数的定义，利用标签表中的信息选择正确的文件并在其中查找该函数。

The positions within the source file, remembered in the tag table, are used to find the function in the file instantly. Changing the file makes the remembered positions inaccurate. If this has happened, Meta--Period searches in both directions away from the remembered position until it finds the definition. So small inaccuracies cause only slight delays.
翻译:在源文件中，通过标签表记住的位置用于立即找到文件中的函数。更改文件会使记住的位置不准确。如果发生了这种情况，Meta--Period将从记住的位置向两边搜索，直到找到定义为止。因此，小的准确性误差只会造成轻微的延迟。

When many new functions have been added, or moved from one file to another, the TAGS program can reprocess the tag table into an updated one. To make this more automatic, the tag table also remembers which language each source file is written in. This information is needed for recognizing the function definitions in the file.
翻译:当添加了许多新功能，或者将某些功能从其中一个文件移动到另一个文件中时，TAGS程序可以重新处理标签表以生成一个更新后的版本。为了使这个过程更加自动化，标签表还记录了每个源文件使用的语言类型。这些信息对于在文件中识别函数定义是必需的。

Interactiveness is useful in many activities aside from editing text. For example, reading and replying to mail from other users ought to be interactive. Many of these activities occasionally involve text editing: for example, editing the text of a reply. If a special editor is implemented for the purpose, it can easily be much more work to write than all the rest of the system. It is easier to write the other interactive system within the framework of an extensible editor.
翻译:除了编辑文本之外，互动性在许多活动中都是有用的。例如，阅读和回复其他用户的邮件应该是互动的。这些活动偶尔会涉及到文本编辑：例如，编辑回复的文本。如果为这个目的实现了一个专门的编辑器，编写它可能比系统中所有的其他部分都要多得多工作。在一个可扩展的编辑器框架内编写其他的交互式系统要容易一些。

EMACS has two extensions, RMAIL and BABYL, for reading mail. Commands in RMAIL and BABYL are not like EMACS commands; typical commands include `D' for `delete this message', and `R' for `reply to this message'. Editing the text of the reply is done with ordinary EMACS commands.
翻译:Emacs 有两个邮件阅读扩展程序：RMAIL 和 BABYL。RMAIL 和 BABYL 中的命令与 Emacs 命令不同；典型的命令包括 `D' 用于“删除此消息”，以及 `R' 用于“回复此消息”。编辑回复的内容使用普通的 Emacs 命令。

DIRED is used for editing a file directory. The normal editing commands, as extended, can be used to move the cursor through the directory listing. Other special commands defined only in DIRED delete, move, compare or examine the file whose name is under the cursor.
翻译:Dired 用于编辑文件目录。通常的编辑命令（经扩展后）可以用来在目录列表中移动光标。仅在 Dired 中定义的其他特殊命令用于删除、移动、比较或检查光标下文件的名称。

The INFO extension is designed for reading tree-structured documentation files. These files are divided textually into nodes, which contain text representing pointers to other nodes. INFO displays one node at a time, and INFO commands move from one node to another by following the pointers.
翻译:INFO扩展程序旨在阅读树状结构的文档文件。这些文件在文本上分为节点，其中包含指向其他节点的指针表示的文字。INFO每次显示一个节点，并且通过跟随指针，INFO命令从一节点移动到另一节点。

The primary components of the EMACS system are the text manipulation and I/O primitives, the interpreter, the command dispatcher, the library system, and the display processor.
翻译:EMACS 系统的主要组件是文本操作和输入/输出原语、解释器、命令分发器、库系统和显示处理器。

The text and I/O primitives are used to operate on the text under the command of the program. The interpreter executes programs, using the primitives when called for. The command dispatcher remembers which program corresponds to each possible input character; it reads a character from the terminal and calls the associated function. The library system associates functions with their names and documentation, and allows groups of related functions to be loaded quickly together. The display processor updates the screen to match the text as changed by the text primitives; it is run whenever there is nothing else to do.
翻译:文本和输入/输出原语用于在程序的指挥下操作文本。解释器执行程序，当被调用时使用这些原语。命令分发器记住每个可能的输入字符对应哪个程序；它从终端读取一个字符并调用相关的函数。库系统将函数与它们的名称和文档关联起来，并允许快速一起加载相关的一组函数。显示处理器根据文本原语更改的文本更新屏幕以匹配；每当没有其他事情要做时就会运行。

An EMACS system actually implements two different languages, the editing language and the programming language. The editing language contains the commands users use for changing text. These commands are implemented by programs written in the programming language. When we speak of the interpreter, we mean the one which implements the programming language. The editing language is implemented by the command dispatcher.
翻译:一个实际的EMACS系统实现了两种不同的语言：编辑语言和编程语言。编辑语言包含了用户用于更改文本的命令。这些命令通过用编程语言编写的程序来实现。当我们提到解释器时，我们指的是实现编程语言的那个。编辑语言是通过命令分发器实现的。

Previous attempts at programmable editors have usually attempted to mix programming constructs and editing in one language. TECO is the primary example of this sort of design. It has the advantage that once the user knows how to edit with the system, he need only learn the programming constructs to begin programming as well.
翻译:之前的可编程编辑器通常试图在一个语言中混合编程结构和编辑功能。TECO是这个类型设计的首要例子。它具有这样的优势：一旦用户学会了如何使用系统进行编辑，他就只需学习编程结构就可以开始编程了。

However, there are considerable disadvantages, because what is good in an editor command language is ugly, hard to read, and grossly inefficient as a programming language. A good interactive editing language is composed primarily of single character commands, with a few commands that introduce longer names for less frequently used operations. As a programming language, it is unreadable if the editor is to be customizable, the user must be able to redefine each character. This in a programming language would be intolerable!
翻译:然而，这存在相当大的缺点，因为编辑器命令语言中好的东西在编程语言中显得丑陋、难以阅读且效率极低。一个好的交互式编辑语言主要由单字符命令组成，其中少数命令引入了较长名称以供较少使用的操作。如果编辑器要可定制，那么作为一种编程语言，它将是不可读的，用户必须能够重新定义每个字符。这在一种编程语言中是无法容忍的！

When the programming language is the editing language, the built-in editing commands and the primitive operations they use have to be written in another language. Then the user cannot change part of the standard system slightly by making a small change to its definition; it has to be reimplemented from scratch as a macro. Since the primitives available are only the commands he uses for editing, this will often be impossible because the necessary primitives will be internal routines that the user cannot call. The primitives that an extension would like to use are not always the same as the editing operations the user wants.
翻译:当编程语言是编辑语言时，内置的编辑命令以及它们使用的原始操作必须用另一种语言编写。那么，用户就不能通过对其定义稍作修改来稍微改变标准系统的一部分；它需要从头开始重新实现为一个宏。由于可用的基本操作仅限于他用于编辑的命令，这通常是不可能的，因为必要的原始操作将是用户无法调用的内部例程。扩展程序希望使用的基本操作并不总是与用户想要的编辑操作相同。

The implementor of a macro processor is encouraged to ignore such deficiencies because he himself does not use the language in implementing the rest of the system. Since it is traditional, in designing a macro language, to ignore the standards of readability, power and robustness typically applied to the design of programming languages, these deficiencies are usually considerable. The original TECO is a good example of this sort of problem.
翻译:宏处理器的设计者被鼓励忽略这些缺陷，因为他在实现系统的其余部分时不使用这种语言。由于在设计宏语言时，传统上会忽略通常应用于编程语言设计中的可读性、功能和健壮性标准，因此这些缺陷通常是相当大的。原始的TECO就是这类问题的良好示例。

In EMACS, each language is designed for its purpose. The editing language has single-character redefinable commands. The programming language is TECO, modified and extended to be more suitable for writing well-structured and robust programs, and to provide the primitives needed by editing programs as opposed to editor users. It remains hard to read, so the descendents of EMACS generally use Lisp instead. TECO was used only for reasons of historical convenience.
翻译:在EMACS中，每种语言都是为其目的而设计的。编辑语言具有单字符可重定义命令。编程语言是TECO，经过修改和扩展以更适合编写结构良好且健壮的程序，并为编辑程序而不是编辑器用户提供所需的原始代码。它仍然难以阅读，因此EMACS的后代通常使用Lisp。TECO仅因历史便利而被使用。

More information on the requirements extensibility imposes on the system's programming language is in the next chapter.
翻译:下一章中将介绍需求扩展对系统编程语言的详细要求。

An important part of any practical extensible system is the ability to use more than one extension at one time, and begin using an additional extension at any time. Extensions should be able to override or replace parts of the standard system, or previous extensions. In EMACS the library system is responsible for accomplishing this.
翻译:任何实用可扩展系统的关键部分之一是能够同时使用多个扩展，并且随时开始使用额外的扩展。扩展应该能够覆盖或替换标准系统的一部分，或者先前的扩展。在EMACS中，库系统负责实现这一点。

An EMACS library is a collection of function names, definitions and documentation that can be loaded into an EMACS in mid-session. Libraries are read-only and position-independent, so that they can be loaded just by incorporating them into the virtual memory of the EMACS. This allows all EMACSs using a library to share the physical memory. Each library contains its own symbol table which connects function names with definitions, and also with their documentation strings. Libraries are generated from source files in which each function definition is accompanied by its documentation; this encourages all functions to be documented.
翻译:一个EMACS库是一组函数名、定义和文档的集合，可以在会话中进行加载到EMACS中。库是只读和无位置的，因此只需通过将其纳入EMACS的虚拟内存即可加载它们。这使得使用同一库的所有EMACS都可以共享物理内存。每个库都包含自己的符号表，它将函数名与定义以及它们的文档字符串相连接。库是从源文件生成的，其中每个函数定义都伴随着其文档；这鼓励了所有函数都被文档化。

When a function name is looked up, all the loaded libraries are searched, most recently loaded first. For the sake of uniformity, the standard EMACS functions also reside in a library, which is always the first one loaded. Therefore, any library can override or replace the definition of a standard EMACS function with a new definition, which will be used everywhere in place of the old. This, together with the fact that EMACS is constructed with explicit function calls to named subroutines at many points, makes it easy for the user to change parts of the system in a modular fashion without replacing it all.
翻译:当一个函数名被查找时，会搜索所有已加载的库，最近加载的优先。为了统一性，标准的EMACS函数也位于一个库中，这个库总是最先被加载的。因此，任何库都可以用一个新的定义覆盖或替换标准EMACS函数的定义，这将取代旧定义在系统的各个地方使用。这与EMACS在许多点通过显式函数调用命名子例程构建的事实相结合，使得用户可以以模块化的方式更改系统的一部分，而无需全部替换它。

Subroutines are normally called by their full names. The user can also call any command by name, and many commands are primarily intended to be used in that way. However, the most common editing operations need to be more easily accessible. This is the purpose of the command dispatcher, which reads one character and looks it up in the dispatch table, a vector of definitions to find the function to be called (the definition-object, not the name).
翻译:子程序通常通过其全名来调用。用户还可以按名称调用任何命令，并且许多命令主要是为了以这种方式使用。然而，最常见的编辑操作需要更容易访问。这就是命令分发器的目的，它读取一个字符并在分发表中查找，分发表是一个定义向量，用于找到要调用的函数（不是名称，而是定义对象）。

Functions residing in the dispatch table can be invoked either by the character command or by name. A function which does not appear in the dispatch table can be called only by name. The user calls functions by name by means of a single-character command (Meta--X) whose definition is to read the name of a function and call that function.
翻译:驻留在转发表中的函数可以通过字符命令或名称来调用。如果一个函数不在转发表中，那么只能通过名称来调用它。用户通过一个单字符命令（Meta--X）来按名称调用函数，该命令的定义是读取一个函数名并调用那个函数。

Each user has his own patterns of use. Many functions in EMACS are accessible only by name because we expect most users to use them infrequently. If a particular user uses one such command often, he can place the definition in the dispatch table using the function Set Key. The function calling conventions are designed so that almost any function definition will behave reasonably if called by the command dispatcher. If a function tries to read a string argument from its caller, then when called by the command dispatcher it will automatically prompt and read the argument from the terminal instead.[[#FOOT3][(3)]]
翻译:每个用户都有自己的使用习惯。由于我们预计大多数用户不会频繁地使用它们，因此EMACS中的许多功能只能通过名称访问。如果某个特定用户经常使用这样的一个命令，他可以使用Set Key函数将其定义放入分发表中。函数调用约定被设计得几乎任何函数定义如果在命令分派程序中被调用都会表现得合理。如果一个函数试图从其调用者读取字符串参数，那么当它由命令分派程序调用时，它会自动提示并从终端读取该参数。[[#FOOT3][(3)]]

Some libraries contain functions that are intended to be called with single character commands. The library can arrange to place those functions' definitions in the dispatch table by defining a function called Setup. This will be called automatically when the library is loaded, and it can redefine character commands as needed. However, because EMACS is intended to be customized, no library can reasonably make the assumption that a function belongs on a particular character without allowing the user who loads the library to override that assumption. For example, a library might wish to redefine Control--S on the assumption that it invokes the search function, but a user might prefer to keep his search on Control--T instead, and he might prefer that same library to alter the definition of Control--T when loaded by him. The author of the library cannot anticipate the details of such idiosyncrasies, but he can provide for them all by following a convention: in the Setup function of the library (TAGS, say), he checks for a variable called =TAGS Setup Hook=, and if it exists, its value is called as a function instead of the usual setting up.
翻译:某些库包含了一些旨在通过单个字符命令调用的函数。库可以通过定义一个称为Setup的函数来安排将这些函数的定义放入分发表。当库被加载时，这将自动调用Setup函数，并且可以根据需要重新定义字符命令。然而，因为EMACS是为了定制而设计的，没有任何库可以合理地假设一个函数应该属于特定的字符，而不允许加载库的用户覆盖这个假设。例如，一个库可能希望根据它调用搜索功能的假设来重定义Control--S，但用户可能更喜欢保留他的搜索在Control--T上，他可能更喜欢当他加载该库时，该库改变Control--T的定义。库的作者无法预测这些癖好的细节，但他可以通过遵循一个约定来为它们全部提供支持：在库的Setup函数（例如TAGS）中，检查是否存在一个变量叫做=TAGS Setup Hook=，如果存在，则将其值作为函数调用，而不是使用通常的设置。

The display processor is the part of EMACS which maintains on the display screen an up-to-date image of the text inside the editor. Since the size of the screen is limited, only a portion or `window' can be shown. The display processor prefers to continue to start its display at the same point in the file, so as to minimize the amount of changes necessary to the screen. However, the text where the editor's own cursor is located must appear on the screen so that the terminal's cursor can show where it is. This sometimes forces a new window position to be computed. The user can also command changes in the window position, moving the text up or down on the screen.
翻译:显示处理器是EMACS中维护编辑器内文本文档在显示器屏幕上最新图像的部分。由于屏幕尺寸有限，只能显示一部分或“窗口”。显示处理器倾向于继续从文件中的同一位置开始其显示，以便使屏幕更改所需的最小化。然而，编辑器的光标所在位置的文本必须出现在屏幕上，这样终端的光标才能显示它的位置。这有时迫使重新计算新的窗口位置。用户还可以命令更改窗口位置，将文本在屏幕上上下移动。

The EMACS display processor embodies an unusual principle which makes for much faster responses to the user: display updating has lower priority than cogitation.
翻译:EMACS显示处理器采用了一种不同寻常的原则，使得对用户的响应速度更快：显示更新优先级低于思考。

Most display editors change the display after each user command. This is the simplest strategy to implement, since each command knows precisely how it has changed the text. But it is very inefficient, not just of the computer's time, but of the user's time, because it makes the user wait for the completion of display updates that have already been made obsolete by further commands waiting to be executed.
翻译:大多数显示编辑器在每次用户命令后更改显示。这是实现起来最简单的策略，因为每个命令都能精确地知道它如何改变了文本。但这种做法非常低效，不仅浪费了计算机的时间，也浪费了用户的时间，因为它让用户等待已经过时的显示更新完成，而这些更新很快就会被待执行的后续命令所取代。

Here is an example of the problem. If the user types Carriage Return to create a new line, all the lines below that point need to be redisplayed in their new positions.
翻译:这是一个问题的示例。如果用户按下回车键来创建一个新行，那么下面所有点的行都需要重新显示在它们的新位置上。

While this is still going on, if he types an additional Carriage Return to create another new line, the rest of the display update is obsolete; there is no use displaying the rest of the lines in their second positions, only to display them again in their third positions.[[#FOOT4][(4)]]
翻译:当这个过程中还在继续的时候，如果他再按一次回车键来创建另一个新行，那么其余的显示更新就变得过时了；没有必要在第二位置上显示剩余的行，只是为了再次在第三位置上显示它们。[[#FOOT4][(4)]]

The EMACS display processor is best understood as being a separate, lower priority process that runs in parallel with the editing process. The editing process reads keyboard input and makes changes in the text. The display process is always trying to change the screen to match the text; it keeps a record of what is on the screen, and in each cycle of operation finds one discrepancy between the editing buffer and the screen record and corrects it. After each cycle, the display process can be pre-empted by the editing process, which has higher priority. The display process can be thought of as chasing an arbitrarily moving target, the edited text, with a speed limited by the terminal baud rate.
翻译:EMACS显示处理器最好被视为一个独立且优先级较低的过程，它与编辑过程并行运行。编辑过程读取键盘输入并在文本中进行更改。显示过程始终试图使屏幕与文本相匹配；它记录屏幕上的内容，并在每次操作周期中找到编辑缓冲区和屏幕记录之间的一个差异并进行纠正。在每个周期之后，具有更高优先级的编辑过程可以抢占显示过程的控制权。可以将显示过程视为用一个受终端波特率限制的速度追逐任意移动的目标——已编辑的文本。

Multiple processes are not actually used in the implementation. Instead, after each line of display output, the display processor updates its data base and polls for input.
翻译:实际上并没有使用多进程进行实现。相反，在每次显示输出的每行之后，显示器处理器更新其数据库并轮询输入。

An additional benefit of this input-before-output philosophy is that it uses less computer resources when the system is heavily loaded. When not enough computer power is available, EMACS gets behind in processing the user's input. When the first command is completed, more input is available, so no effort is put into display updating yet. By saving computer time this way, EMACS eventually catches up with the user and does its display updating all at once.
翻译:这种输入在前、输出在后的哲学思想还有另外一个好处，就是在系统负载较重时，它使用的计算机资源更少。当计算机功率不足时，EMACS 在处理用户的输入时会落后。当第一个命令完成后，又有更多的输入可用，所以此时并不需要投入精力进行显示更新。通过这种方式节省了计算机时间，最终 EMACS 会赶上用户并一次性完成其显示更新。

Since display updating is not necessarily done at the same time as the editing operation which necessitates it, display updating cannot be the responsibility of the editing command itself. Instead, the display update must be done by somehow comparing the new text with the previous displayed text, or information about it. In EMACS, each editing command returns information on the range of text it has changed, but aside from that the display processor operates independently. This is good for extensibility as well: it is easier to write or change an editing command if it does not have to contain algorithms for updating the screen.
翻译:由于显示更新不一定与需要它的编辑操作同时进行，因此显示更新不能由本身执行编辑命令负责。相反，显示更新必须通过某种方式比较新文本与之前显示的文本或有关信息来完成。在EMACS中，每个编辑命令都会返回它所更改的文本范围的详细信息，除此之外，显示处理器独立运行。这对于扩展性来说也很好：如果一个编辑命令不需要包含更新屏幕的算法，那么编写或修改这个编辑命令就会更容易。

Because the TECO language is not very efficient, the display processor had to be written in assembler language to get adequate performance. This is unfortunate because extensions to the display processor could be very valuable. In later implementations of EMACS, the display processor is written in Lisp along with the editing commands, and can be extended.
翻译:由于TECO语言的效率不高，显示处理器不得不使用汇编语言编写以获得足够的性能。这很不幸，因为扩展显示处理器可能会非常有价值。在后来的EMACS实现中，显示处理器与编辑命令一起用Lisp编写，并且可以进行扩展。

Despite its syntactic obscurity, TECO is actually one of the best languages to use for implementing an extensible editor. This is because most traditional programming languages simply cannot do the job! Implementing an extensible system of any sort requires features that they intrinsically lack. Specifically, it requires a language with an interpreter and the ability for programs to access the interpreter's data structures (such as function definitions).
翻译:尽管TECO的语法有些晦涩难懂，但它实际上是最适合用于实现可扩展编辑器的编程语言之一。这是因为大多数传统编程语言根本无法胜任这项工作！实现任何类型的可扩展系统都需要它们本质上缺乏的功能。具体来说，它需要一个具有解释器和程序能够访问解释器数据结构（如函数定义）能力的语言。

请注意，这段话是英文原文的直接翻译，没有进行任何额外的修改或润色。

Adherents of non-Lisp programming languages often conceive of implementing an EMACS for their own computer system using PASCAL, PL/I, C, etc. In fact, it is simply impossible to implement an extensible system in such languages. This is because their designs and implementations are batch-oriented; a program must be compiled and then linked before it can be run. An on-line extensible system must be able to accept and then execute new code while it is running. This eliminates most popular programming languages except Lisp, APL and Snobol. At the same time, Lisp's interpreter and its ability to treat functions as data are exactly what we need.[[#FOOT5][(5)]]
翻译:非Lisp编程语言的信徒们常常设想使用PASCAL、PL/I、C等语言为自己所使用的计算机系统实现一个EMACS。实际上，用这些语言来实现一个可扩展的系统是完全不可能的。这是因为它们的设计和实施都是面向批处理的；一个程序必须被编译并链接之后才能运行。一个在线可扩展的系统必须在运行过程中能够接受并执行新的代码。这就排除了除Lisp、APL和Snobol之外的大多数流行编程语言。同时，Lisp的解释器和它把函数当作数据来处理的能力正是我们所需要的。[[#FOOT5][(5)]]

A system written in PL/I or PASCAL can be modified and recompiled, but such an extension becomes a separate version of the entire program. The user must choose, before invoking the program, which version he wants. Combining two independent extensions requires comparing and merging the source files. These obstacles usually suffice to discourage all extension.
翻译:用PL/I或PASCAL编写的系统可以修改并重新编译，但这种扩展变成了整个程序的独立版本。在调用程序之前，用户必须选择他想要的版本。结合两个独立的扩展需要比较和合并源文件。这些障碍通常足以阻止所有的扩展。

The only way to implement an extensible system using an unsuitable language, is to write an interpreter for a suitable language and then use that one. Prime is now implementing an EMACS using a simple Lisp written in PL/I. This technique works because an editor does not require a very efficient interpreter; even the most straightforward Lisp interpreter is more efficient than the TECO interpreter which is empirically observed to be good enough. I would not regard this as implementation `in' the original language, however.
翻译:要使用一种不合适的语言实现一个可扩展的系统，唯一的办法就是编写一个适合语言的解释器的编译器，然后使用那个解释器。Prime现在正在用一个用PL/I编写的简单Lisp来实现一个EMACS编辑器。这种技术之所以可行，是因为编辑器并不需要一个非常高效的解释器；甚至是最直接的Lisp解释器也比经验上被认为足够好的TECO解释器更有效率。然而，我不会认为这是在原始语言中实现的。

A PASCAL or PL/I implementation which uses an interpreter, and allows the user program to access the interpreter data structures sufficiently, could be used just as a Lisp implementation would be used. However, such implementations are very rare, because these languages are not designed for them. If the implementor appreciates the importance of the interpreter, and of treating functions as data, he will usually choose to implement Lisp.
翻译:一个使用解释器、并且允许用户程序足够访问解释器数据结构的PASCAL或PL/I实现，可以像使用Lisp实现一样使用。然而，这样的实现非常罕见，因为这些语言并不是为此设计的。如果实施者欣赏解释器的重要性，以及将函数视为数据的重要性，他通常会选择实现Lisp。

It is also possible to use dynamic linking--the ability to load additional modules of compiled code during execution, and refer to subroutines therein by name--in place of an interpreter. However, dynamic linking operating systems are rarer than good Lisps, harder to implement, and not as convenient for the job. One of the few such operating systems, Multics, has an EMACS written in Lisp. SINE, the EMACS implementation on Interdata computers, uses dynamic linking to load files compiled from a language which resembles Lisp.
翻译:也可以使用动态链接——在执行过程中加载编译后的代码模块并在其中按名称引用子程序的能力，代替解释器。然而，动态链接操作系统比优秀的Lisp更少见，实现起来也更困难，对于这项工作来说也不够方便。为数不多的此类操作系统之一是Multics，它有一个用Lisp编写的EMACS。SINE是在Interdata计算机上实现的EMACS，它使用动态链接来加载从类似于Lisp的语言编译而成的文件。

When a language is used for implementing extensible systems, certain control structure and data structure features become vital.
翻译:当一个语言用于实现可扩展系统时，某些控制结构和数据结构特性变得至关重要。

One difference between Lisp (and TECO) and most other programming languages, which is very important in writing extensible systems, is that variable names are retained at run time; they are not lost in compilation.
翻译:与Lisp（以及TECO）和大多数其他编程语言相比，一个非常重要的区别在于变量名在运行时被保留；它们不会在编译过程中丢失。

In typical compiled languages, variable names are meaningful only at compile time. In the compiled code, uses of one variable name become references to one location in memory, but the name itself has been discarded.
翻译:在典型的编译型语言中，变量名只在编译时具有意义。在编译后的代码中，对一个变量名的使用变成了对内存中一个位置的引用，但这个名称本身已经被丢弃了。

By contrast, Lisp remembers the connection between variable names and their values, so that new programs can be defined.
翻译:相比之下，Lisp 会记住变量名和其值之间的关系，这样就可以定义新的程序。

Global variables are essential for parameters used for customization. EMACS has a variable named =Comment Start= which controls the string recognized as starting a comment in the text being edited. Its value is supposed to be that string. This variable is used by the comment indenting command to recognize an existing comment. The fact that the variable name is known at run time enables the user to
翻译:全局变量对于自定义使用的参数至关重要。Emacs有一个名为=Comment Start=的变量，它控制着被识别为编辑文本中注释开始的字符串。其值应该是那个字符串。这个变量由注释缩进命令用来识别已存在的注释。由于在运行时已知变量名，因此使用户能够

- ask to see the value of the string.
翻译:请求查看字符串的值。
- change the string.
翻译:您的好用的人工智能助手，请将我的非中文文字翻译成中文！注意翻译时要保留原文的格式，只需输出翻译的内容即可
- define or redefine major modes, for various programming languages which change the string.
翻译:定义或重新定义各种编程语言的重大模式，以更改字符串。
- define or redefine comment-manipulation commands, which refer to the variable so that they will work on text in various languages.
翻译:定义或重新定义注释操作命令，该变量引用使得它们可以处理各种语言的文本。

Most batch languages use a lexical scope rule for variable names. Each variable can be referred to legally only within the syntactic construct which defines the variable.
翻译:大多数批处理语言使用词法作用域规则来命名变量。每个变量只能在定义它的语法结构内部合法引用。

Lisp and TECO use a dynamic scope rule, which means that each binding of a variable is visible in all subroutine calls to all levels, unless other bindings override. For example, after
翻译:Lisp和TECO使用动态作用域规则，这意味着每个变量的绑定在所有对各级子程序的调用中都是可见的，除非其他绑定进行了覆盖。例如，在执行以下代码后：

```lisp
(defun foo ()
  (setq x 10)
  (defun bar ()
    (setq x 20))
  (bar))

(foo)
```

变量`x`的值将是30，因为`foo`函数中的绑定被传递到了`bar`函数中，并且没有被`bar`函数内部的绑定所覆盖。

请注意，这种作用域规则可能会导致一些难以调试的错误，因此在实际编程中应谨慎使用。

#+BEGIN_EXAMPLE
(defun foo1 (x) (foo2))
(defun foo2 () (+ x 5))
#+END_EXAMPLE

then =(foo1 2)= returns 7, because =foo2= when called within =foo1= uses =foo1='s value of =x=. If =foo2= is called directly, however, it refers to the caller's value of =x=, or the global value. We say that =foo1= binds the variable =x=. All subroutines called by =foo1= see the binding made by =foo1=, instead of the global binding, which we say is shadowed temporarily until =foo1= returns.
翻译:然后表达式`(foo1 2)`返回7，因为当`foo2`在`foo1`内部被调用时，它使用的是`foo1`中`x`的值。然而，如果直接调用`foo2`，它会引用调用者的`x`值的全局绑定，或者全局值。我们说`foo1`绑定了变量`x`。所有由`foo1`调用的子程序都会看到`foo1`所做的绑定，而不是全局绑定，后者在我们所说的临时被`foo1`返回所遮蔽。

In PASCAL the analogous; program would be erroneous, because =foo2= has no lexically visible definition of =x=.
翻译:在PASCAL中，类似的程序将是错误的，因为`foo2`没有词法可见的定义为`x`。

Dynamic scope is useful. Consider the function =Edit Picture=, which is used to change certain editing commands slightly, temporarily, so that they are more convenient for editing text which is arranged into two-dimensional pictures. For example, printing characters are changed to replace existing text instead of shoving it over to the right. =Edit Picture= works by binding the values of parameter variables dynamically, and then calling the editor as a subroutine. The editor `exit' command causes a return to the =Edit Picture= subroutine, which returns immediately to the outer invocation of the editor. In the process, the dynamic variable bindings are unmade.
翻译:动态作用域很有用。考虑一下 =编辑图片= 这个函数，它用于稍微改变某些编辑命令，以便在将文本排列成二维图片时更方便地进行编辑。例如，打印字符被替换为替换现有文本，而不是将其推到右边。=编辑图片= 通过动态绑定参数变量的值来工作，然后调用编辑器作为子程序。编辑器的 `退出` 命令导致返回到 =编辑图片= 子程序，该子程序立即返回到外部对编辑器的调用中。在此过程中，动态变量绑定会被解除。

Dynamic binding is especially useful for elements of the command dispatch table. For example, the RMAIL command for composing a reply to a message temporarily defines the character Control--Meta--Y to insert the text of the original message into the reply. The function which implements this command is always defined, but Control--Meta--Y does not call that function except while a reply is being edited. The reply command does this by dynamically binding the dispatch table entry for Control--Meta--Y and then calling the editor as a subroutine. When the recursive invocation of the editor returns, the text as edited by the user is sent as a reply.
翻译:动态绑定对于命令分发表中的元素特别有用。例如，RMAIL命令用于编写回复消息临时定义了字符Control--Meta--Y来将原始消息的文本插入到回复中。实现这个命令的功能始终被定义，但在编辑回复的过程中Control--Meta--Y不会调用那个函数。回复命令通过动态绑定Control--Meta--Y的分发表项然后作为子程序调用编辑器来完成这项工作。当递归调用的编辑器返回时，用户编辑后的文本将被发送作为回复。

It is not necessary for dynamic scope to be the only scope rule provided, just useful for it to be available.
翻译:动态作用域不必是唯一的作用域规则，但使其可用是有益的。

Some language designers believe that dynamic binding should be avoided, and explicit argument passing should be used instead. Imagine that function A binds the variable =FOO=, and calls the function B, which calls the function C, and C uses the value of =FOO=. Supposedly A should pass the value as an argument to B, which should pass it as an argument to C.
翻译:一些语言设计者认为应该避免动态绑定，而应使用显式参数传递。想象一下函数A绑定变量“=FOO=”，然后调用函数B，函数B又调用函数C，而C使用“=FOO=”的值。据说A应该将值作为参数传递给B，B再将它作为参数传递给C。

This cannot be done in an extensible system, however, because the author of the system cannot know what all the parameters will be. Imagine that the functions A and C are part of a user extension, while B is part of the standard system. The variable =FOO= does not exist in the standard system; it is part of the extension. To use explicit argument passing would require adding a new argument to B, which means rewriting B and everything that calls B. In the most common case, B is the editor command dispatcher loop, which is called from an awful number of places.
翻译:在可扩展系统中，这是无法实现的，因为系统的作者不可能知道所有的参数是什么。想象一下，函数A和C是用户扩展的一部分，而B是标准系统的一部分。"="FOO="这个变量不存在于标准系统中；它是扩展的一部分。要使用显式参数传递，就需要给B添加一个新参数，这意味着需要重写B以及调用B的所有东西。在最常见的情况下，B是编辑器命令分发循环，它被从许多地方调用。

What's worse, C must also be passed an additional argument. B doesn't refer to C by name (C did not exist when B was written). It probably finds a pointer to C in the command dispatch table. This means that the same call which sometimes calls C might equally well call any editor command definition. So all the editing commands must be rewritten to accept and ignore the additional argument. By now, none of the original system is left!
翻译:更糟糕的是，C 必须传递一个额外的参数。B 并没有通过名称引用 C（当 B 编写时 C 还不存在）。它可能在命令调度表中找到一个指向 C 的指针。这意味着相同的调用有时会调用 C，同样可能会调用任何编辑器命令定义。因此，所有编辑命令都必须重写以接受并忽略这个额外参数。现在，原始系统中没有任何东西了！

Suppose one file is formatted with comments starting at column 50. Editing this file is easier if the variable =Comment Column=, which is used (by convention) to decide where to align comments, is always set to 50 whenever this file is being editing. EMACS provides a way to request this; but since it also provides the feature of visiting several files at once, it must take special care to keep each file's variables straight. Suppose one file wants =Comment Column= to be 50 while another is formatted with 40?
翻译:假设一个文件以第50列开始注释。如果总是将变量=注释列=设置为50，那么编辑这个文件就会更容易，因为这个变量（按照惯例）用于决定注释的对齐方式。EMACS提供了一个请求这种设置的方法；但是由于它还提供了同时访问多个文件的功能，因此必须特别注意保持每个文件的变量正确无误。如果一个文件希望=注释列=为50，而另一个文件则以40进行格式化怎么办？

This is solved by allowing each file to have its own local values for any set of variables. Specially formatted text at the end of the file specifies them:
翻译:通过允许每个文件为其任意一组变量设置自己的本地值来解决。文件末尾特别格式的文本来指定它们：

#+BEGIN_EXAMPLE
Local Modes:
Comment Column:50
End:
#+END_EXAMPLE

When a file is brought into EMACS, this local modes list is parsed and the variables and values remembered in a local symbol table. While the file is not selected, its local symbol table contains the local values of the variables. While a file is selected, its local symbol table contains the global values, and the real symbol table contains the file's local values instead.
翻译:当一个文件被带入EMACS时，这个局部模式列表会被解析，变量及其值会被记住在一个局部符号表中。当文件没有被选中时，它的局部符号表包含了变量的局部值。当一个文件被选中时，它的局部符号表包含全局值，而真正的符号表则包含文件的局部值。

When an extensible system allows the user to provide a function to be called on certain well-defined occasions, we call it a hook. For example, we have already mentioned the hook which is executed whenever a certain library is loaded; for the TAGS library, the hook is named =TAGS Setup Hook=.
翻译:当一个可扩展的系统允许用户为某些明确定义的场合提供一个要调用的函数时，我们称它为一个钩子。例如，我们已经提到了每当加载某个库时就会执行的钩子；对于TAGS库，这个钩子的名字是=TAGS设置钩子=。

Another important class of hooks is executed when a major mode is entered. Each major mode has its own hook. For example, Text mode's hook is named =Text Mode Hook=. This hook can be used to request arbitrary actions in advance for each time text mode is entered. Many users always define this hook to turn on Auto Fill mode, so that Auto Fill mode is always on when Text mode is.
翻译:一类重要的钩子是在进入主模式时执行的。每个主模式都有自己的钩子。例如，文本模式的钩子被称为="文本模式钩子"=。这个钩子可以用在每次进入文本模式之前请求任意操作。许多用户总是定义这个钩子来打开自动填充模式，这样每当进入文本模式时自动填充模式就会一直开启。

Hooks can be associated with variables as well. Then, each time the value of the variable changes, its hook is run. Usually these hooks are used to change other data structures so that they always correspond to the value of the variable. This is often more efficient and more modular than checking the variable itself whenever its value is relevant. For example, changing the value of =Auto Fill Mode= to turn auto-filling on or off calls a function which automatically redefines the Space character's command definition.
翻译:钩子也可以与变量关联。然后，每当变量的值发生变化时，就会运行其钩子。通常这些钩子用于更改其他数据结构，以便它们始终与变量的值相对应。这通常比在变量的值相关时每次都检查变量本身更有效、更模块化。例如，将“自动填充模式”的值更改为开启或关闭自动填充功能会调用一个函数，该函数会自动重新定义空格字符的命令定义。

Some hooks are attached to specific points within the interpreter or display processor. For example, there is a hook which is called whenever it is time to read a character of input from the terminal. The hook program can supply the character itself. These hooks can be thought of as compensating for the fact that some parts of the system are written in assembler language and cannot simply be redefined by the user.
翻译:一些钩子被附加到解释器或显示处理器内的特定点上。例如，每当需要从终端读取一个输入字符时，就会调用一个钩子。钩子程序可以提供该字符本身。这些钩子可以被视为补偿系统的一些部分是用汇编语言编写的，不能简单地通过用户重新定义。

A system for programming editor commands needs more sophisticated facilities for handling errors and other exceptional conditions than most programming systems provide. Let us consider what an error is, and what ought to happen when there is an error.
翻译:一个用于编程编辑器命令的系统需要比大多数编程系统提供的更高级的错误处理和其他异常条件处理功能。让我们考虑一下什么是错误，以及在发生错误时应该发生什么。

First of all, what exactly is an error? Sometimes the user asks to do something that cannot be done (a user error). Sometimes a program asks to do something which cannot be done (a program error). Program errors often accompany user errors, but either one can happen without the other.
翻译:首先，什么是错误？有时用户请求做一些无法完成的事情（用户错误）。有时程序请求做一些无法完成的事情（程序错误）。程序错误通常伴随用户错误发生，但两种错误可以单独出现，而不相互伴随。

Program errors can be defined objectively: any event which executes a certain part of the interpreter is a program error. User errors cannot be defined objectively in this way because they are a matter of attitude toward events rather than events themselves. If a command has done nothing, we can regard this either as the response to an error or as normal functioning. And this choice of attitude has no necessary connection with whether the command definition required special code to make it do nothing in the circumstances in question.
翻译:程序错误可以客观地定义：任何执行解释器某个部分的动作都是程序错误。用户错误不能以这种方式客观定义，因为它们是关于对事件的态度而不是事件本身。如果一个命令什么都没做，我们可以将其视为对错误的响应或正常运作。而这种态度的选择与命令定义是否需要特殊代码使其在所述情况下什么都不做之间没有必然联系。

When a program error happens, EMACS prints the error message and then gives the user the chance to invoke the error handler to debug it. If he does not do this, control returns to the innermost error return point. Programs can create error return points with a special construct. (We use a Lisp-style syntax in these examples for clarity).
翻译:当一个程序发生错误时，EMACS会打印出错误信息，然后给用户提供机会调用错误处理器来调试它。如果他不去这样做，控制就会返回到最内层的错误返回点。程序可以使用一个特殊的构造来创建错误返回点。(在这些例子中，我们使用Lisp风格的语法以提高清晰度)。

#+BEGIN_EXAMPLE
(error-return
(arbitrary-code-here))
#+END_EXAMPLE

The end of the error-return construct becomes an error return point which is in effect while the code inside the construct is being executed. Error returns are usually used by loops which read and execute commands of some sort, including the built-in one which reads and displays editing commands.
翻译:错误返回结构的结束成为了一个实际执行结构内部代码时的错误返回点。通常情况下，错误返回是由读取并执行某种命令的循环所使用的，包括内置的读取并显示编辑命令的循环。

#+BEGIN_EXAMPLE
(do-forever
(error-return
(read-and-execute-one-command)))
#+END_EXAMPLE

Sometimes interpreted functions are called asynchronously or unpredictably. An example is the one which optionally saves the text every so often to reduce the amount lost if the system crashes. If this function gets a program error, it should notify the user, but should not interfere in any way with the user's explicit commands. This requires a construct known in Lisp as errset, which prevents all normal processing of errors that occur within it. An error occurring within an errset does nothing but return control immediately to the end of the errset.
翻译:有时解释型函数会被异步地或不可预测地调用。例如，一个可选功能每隔一段时间保存一次文本，以减少系统崩溃时丢失的数据量。如果这个函数出现程序错误，它应该通知用户，但不应该在任何方面干扰用户的显式命令。这需要一个在Lisp中称为errset的构造，它可以防止对在其内部发生的所有正常错误的处理。在errset内部发生的一个错误不会做任何事情，只是立即将控制返回到errset的末尾。

The programming system does not provide any such uniform handling for user errors because the concept of a user error is not defined at that level. Instead, the designer of each editing command must decide what conditions ought to be considered errors, and what to do in each case. Sometimes the command simply does nothing. Sometimes it rings the terminal's bell and perhaps throws away type ahead. This can be best if we expect that, once the user is told that there is something wrong, it will be obvious what it is. When the cause of the error is less obvious, causing a program error deliberately with a specially chosen error message is a good way of informing him. A special primitive is used to cause a program error with an arbitrary specified error message so that the error-return processing can be invoked.
翻译:编程系统不提供对用户错误的统一处理方式，因为在该级别上没有定义“用户错误”的概念。相反，每个编辑命令的设计者必须决定哪些条件应该被视为错误，以及每种情况下应采取的措施。有时该命令什么也不做。有时它会响铃，并且可能会丢弃输入的内容。如果我们预期一旦告诉用户出了问题，就会很明显是什么问题，那么这样做是最好的。当错误的原因不太明显时，故意引起程序错误并使用特别选择的错误消息是一种很好的方法来通知他。使用一个特殊的原语来引发带有任意指定错误消息的程序错误，以便调用错误返回处理。

Sometimes the user error leads naturally to an error in the program, which may be all the handling it needs. This can be so if the program error's error message is an adequate explanation for the user, or if the situation is not deemed likely enough to deserve the effort required to make anything else happen.
翻译:有时用户的错误自然会引发程序中的错误，这可能就是程序所需要的全部处理。如果程序的错误信息对用户来说是一个充分的解释，或者这种情况被认为不太可能值得付出让其他事情发生的努力，那么情况就可能如此。

The error handler for debugging program errors is an interpreted program itself. This is possible because primitives are provided for examining the function call stack and all other data structures which the programmer would want to examine while debugging. Users have actually written extensions and complete replacements for the standard error handler program.
翻译:调试程序错误的错误处理程序本身就是一个解释型程序。这是因为提供了检查函数调用栈和程序员在调试过程中想要检查的所有其他数据结构的原语。实际上，用户已经编写了扩展程序和标准错误处理程序的完整替换程序。

Returning to the example of the user-written command loop, there has to be a command to exit the loop. How can it be done?
翻译:回到用户编写的命令循环示例中，必须有退出循环的命令。该如何实现呢？

#+BEGIN_EXAMPLE
(do-forever
(error-return
(read-and-execute-one-command)))
#+END_EXAMPLE

We do it by means of a non-local control transfer. We create the transfer point by means of a catch construct around the loop. The catch creates a named transfer point at the end of the loop, which is accessible only within the loop.
翻译:我们通过非局部控制转移来实现这一点。我们使用一个循环周围的catch构造来创建传输点。catch在循环末尾创建了一个命名的传输点，该传输点仅在循环内部可访问。

#+BEGIN_EXAMPLE
(catch
(do-forever
(error-return
(read-and-execute-one-command)))
exit-my-loop)
#+END_EXAMPLE

At any time during the loop, execution of =(throw exit-my-loop)= transfers control immediately to the end of the catch, thus exiling the loop. The catch and throw constructs were copied from Maclisp.
翻译:在任何循环过程中，执行 =(throw exit-my-loop)= 将立即将控制转移到捕获块的末尾，从而将循环放逐。catch 和 throw 构造是从 Maclisp 复制的。

Like variable names, catch names have dynamic scope: the program can throw to a catch from any of the subroutines called while inside the catch. This is important because ease of extension dictates that each command which the command-reading loop understands be implemented by a separate function, so that the user can redefine one command without replacing the framework of the loop.[[#FOOT6][(6)]]
翻译:像变量名一样，捕获名称具有动态作用域：程序可以从调用 catch 时的任何子例程中抛出异常到 catch 中。这是因为易于扩展规定，命令读取循环理解的每个命令都应由一个单独的函数实现，这样用户就可以重新定义一个命令而无需替换循环框架。[[#FOOT6][(6)]]

A complex program is much easier to learn if it can answer questions about how to use it. When the program is customizable, it is important for the answers to reflect any customization that has been done. The easiest way to do this is for questions to be answered based on the same tables and data structures that control the functioning of the system. In EMACS, these include the command dispatch table and the loaded libraries.
翻译:如果一个程序能够回答关于如何使用它的疑问，那么学习这个复杂程序将会容易得多。当程序可以定制时，答案应反映已经进行的任何定制是非常重要的。要做到这一点最简单的方法就是根据控制系统运行的相同表格和数据结构来回答问题。在EMACS中，这些包括命令分发表和已加载的库。

The most basic kind of question that a user might want to ask is, "What does this command do?" He can inquire about either a function name or a command character. A library contains a documentation string for each function in it, and this is used to answer the question. When the question is about a command character, the dispatch table is used to find the function object which is currently the definition of that character. Then the library system is used to find the name of the function, and then, from that, the documentation string.
翻译:用户可能会问的最基本的问题是：“这个命令的作用是什么？”他可以询问函数名或命令字符。库为其中的每个函数包含一个文档字符串，用于回答问题。当问题是关于命令字符时，使用分发表来找到当前定义该字符的函数对象。然后，库系统用来查找函数名称，然后根据这个名字获取文档字符串。

The ability to ask what a certain command does only helps users who know what commands to ask about. Other users need to ask, "What commands might help me now?" EMACS attempts to answer this by listing all the functions whose names contain a given substring. Since the function names tend to summarize what the functions do (such as `Forward Word' or `Indent for Comment') and follow systematic conventions, this is usually enough. The list also contains the first line of each function's own documentation, and how to invoke the function with one or two characters, if that is possible.
翻译:仅能询问某个命令的作用只能帮助知道要问哪些命令的用户。其他用户需要问：“现在有哪些命令可能对我有帮助？”EMACS试图通过列出所有包含给定子字符串的功能名称来回答这个问题。由于功能名称通常总结功能的作用（例如“向前单词”或“为注释缩进”），并且遵循系统约定，这通常就足够了。列表还包含了每个函数自身文档的第一行以及如何用一个或两个字符调用该函数的方法，如果可能的话。

The documentation for a function is usually just a string of text, but it can also contain programs to be executed to print the documentation, interspersed with text to be printed literally. This comes in handy when the description of one function refers to another function which is usually accessed as a one or two character command. It is better to tell the user the short command, which he would actually use, than the name of the function which defines it. But exactly which command--if any--runs the function in question depends on the user's customization. What we do is to use a program, in the middle of the documentation string, which searches the dispatch table and prints the command which would invoke the desired function. Another application of this facility is for functions which simply load a library and call a function in it. The documentation string for such functions is a program to load the library and print the documentation of the function which would be called.
翻译:函数文档通常只是一串文本，但它也可以包含要执行的程序以打印文档，其中穿插着要字面打印的文本。当对一个函数的描述引用了通常作为一或两个字符命令访问的另一个函数时，这很有用。告诉用户他会实际使用的简短命令，而不是定义它的函数名称，要好得多。但是，确切哪个命令（如果有）会运行所讨论的函数取决于用户的定制。我们做的就是在文档字符串中间使用一个程序，搜索分发表并打印出调用所需函数的命令。这个功能的另一个应用是对于仅仅加载库并调用其中的函数的函数。此类函数的文档字符串是一个加载库并打印将被调用的函数文档的程序。

To help users remember how to ask these questions, we make it simple and standard. A special character, called the Help character, is used. This character is only used for asking for help, and is always available. Help is normally followed by another character which specifies the type of inquiry. If the user does not remember these characters, he can type Help again to see a list of them. To close the remaining loophole of confusion, EMACS prints a message about the Help character each time it starts up.
翻译:为了帮助用户记住如何提出这些问题，我们使其简单且标准化。使用一个特殊字符，称为“帮助”字符来实现这一目的。"帮助"字符仅用于请求帮助，并且始终可用。通常情况下，“帮助”后面会跟随另一个字符来指定查询的类型。如果用户忘记了这些字符，他可以再次输入“帮助”以查看它们的列表。为了解决剩余的混淆漏洞，每次启动时，EMACS都会打印有关“帮助”字符的消息。

Help is also available in the middle of typing a command. For example, if you start to type the Replace String command and forget what arguments are required, type Help. The documentation of the Replace String function will be printed to tell you what to do next. Because questions are answered based on the data structures as they are at the moment, many changes in EMACS require no extra effort to update the documentation. It is only necessary to update the documentation of each function whose definition is changed. The format for EMACS library source files encourages this by requiring a documentation string for every function, between the function name and its definition.
翻译:在输入命令的过程中也可以获得帮助。例如，如果您开始输入替换字符串（Replace String）命令并忘记需要哪些参数，您可以输入“帮助”（Help）。替换字符串函数的文档将被打印出来，告诉您下一步该做什么。因为问题的答案是基于当前的数据结构生成的，所以许多EMACS的变化都不需要额外的努力来更新文档。只需更新每个被修改了定义的函数的文档即可。EMACS库源文件的格式鼓励这样做，它要求为每一个函数提供一个文档字符串，位于函数名和其定义之间。

I began the development of EMACS in 1974 with an improvement to TECO: the implementation of the display processor and a command dispatcher with a small fixed set of commands. These were inspired by the editor E of the Stanford Artificial Intelligence Lab. They were not considered a new editor, but rather one new feature in TECO to join many existing features. The user would give the TECO command Control-R to enter display editing mode, whose commands were suitable only for making local changes to the file. He would exit display editing mode to do anything else.
翻译:我在1974年开始开发EMACS，这是对TECO的一个改进：实现了显示处理器和一个带有少量固定命令的命令分发器。这些灵感来自于斯坦福人工智能实验室的编辑E。它们并没有被认为是一个新的编辑器，而只是TECO中众多现有功能中的一个新特性。用户会给出TECO命令Control-R进入显示编辑模式，该模式的命令只适合于对文件进行局部更改。他会退出显示编辑模式去做其他任何事情。

But once display editing was implemented, it was fairly easy to allow commands to be redefined to call functions written in TECO. TECO already contained considerable facilities for text manipulation, I/O, and programming, so almost immediately many users began to implement large collections of editing commands, powerful enough to do every part of editing. One of the most popular of these systems was TECMAC. Others included MACROS, RMODE, TMACS, Russ-mode and DOC. The need to exit from display editing mode to use TECO directly became less and less frequent until new users no longer learned how.
翻译:但是一旦实现了显示编辑功能，就很容易允许命令重新定义以调用用TECO编写的函数。TECO本身已经包含了大量的文本处理、输入/输出和编程设施，所以几乎立即就有许多用户开始实现大量编辑命令集合，强大到足以完成所有编辑工作。这些系统中最受欢迎的是TECMAC。其他的包括MACROS、RMODE、TMACS、Russ-mode和DOC。直接退出显示编辑模式使用TECO的需求变得越来越少，直到新用户甚至不再学习如何这样做。

But TECO was still missing many at the important control and programming constructs which allow programs to be readable and maintainable (for example, named functions and variables!). So the early TECO-based display editors were very hard to maintain. In 1976 the TMACS system experimented with adding named functions and variables, with good results limited by the inefficiency of implementing them with TECO programs. This inspired me to implement EMACS itself.
翻译:但是TECO仍然缺少许多重要的控制和编程结构，这些结构允许程序可读且易于维护（例如，命名函数和变量！）。因此，早期的基于TECO的显示编辑器非常难以维护。在1976年，TMACS系统尝试添加命名函数和变量，取得了良好的效果，但由于使用TECO程序实现它们的效率低下而受到限制。这激发了我自己实现EMACS的动机。

Writing EMACS involved simultaneously adding to TECO the features which make up the library system and self-documentation, which permitted a new readable programming style, and writing a new set of display editing commands using this style. The design for the commands themselves was based on examining the command sets of the many TECO-based editors for inspiration, and choosing commands so that the most common operations would take few keystrokes. The first operational EMACS system existed in late 1976.
翻译:编写EMACS涉及同时向TECO添加构成库系统的特性和自文档化功能，这允许了一种新的可读编程风格，并使用这种风格编写了一套新的显示编辑命令。这些命令本身的设计是基于检查许多基于TECO的编辑器的命令集以获得灵感，并选择命令以便最常用的操作只需少量按键。第一个可运行的EMACS系统在1976年底存在。

Since then, development has proceeded steadily, most new code being written in TECO. New features are added to TECO itself only to speed up loops such as table searching and s-expression parsing, or to make possible new kinds of I/O or interface operations.
翻译:自那时以来，发展一直稳步进行，大多数新代码都是用TECO编写的。只有在加快循环，如表搜索和s表达式解析，或者使可能的新的I / O或接口操作的情况下，才会向TECO本身添加新功能。

EMACS was developed on the Digital Equipment Corporation PDP--10 computer using MIT's own Incompatible Timesharing System. By 1977, outside interest in EMACS was sufficient to motivate Mike McMahon of SRI International to adapt it to Digital's Twenex (`Tops--20') operating system. EMACS is now in use at about a hundred sites.
翻译:emacs是在Digital Equipment Corporation的PDP-10计算机上使用麻省理工学院自己的不相容分时系统开发的。到1977年，外界对emacs的兴趣已经足够大，以至于激励了SRI国际的Mike McMahon将它适应于Digital的Twenex（`Tops--20'）操作系统。现在，emacs大约在一百个站点上使用。

Several post-EMACS editor implementations have copied from EMACS both the specific command set and user interlace and the fundamental principle of being based on a programmable interpreter. The motivation for these projects was to transfer the ideas of EMACS to other computer systems. Two of them, now in use, are Multics EMACS, a Honeywell product, and ZWEI, the editor for the MIT Artificial Intelligence Lab Lisp machine.
翻译:几个后EMACS编辑器的实现都从EMACS复制了特定的命令集和用户界面，以及基于可编程解释器的根本原则。这些项目的动机是将EMACS的思想转移到其他计算机系统上。其中两个现在仍在使用中，一个是Honeywell公司的Multics EMACS，另一个是麻省理工学院人工智能实验室Lisp机器上的ZWEI编辑器。

Because EMACS supplied the implementors with a clear idea of what was to be implemented, their focus was on making the foundations clean. The essential improvement was the substitution of an excellent programming language, Lisp, for the makeshift extended TECO used in EMACS. Lisp provides the necessary language features in a framework much cleaner than TECO. Also, it is more efficient. A Lisp interpreter is intrinsically more efficient than a string-scanning interpreter such as TECO's, and Lisp compilers are also available. This efficiency is important not just for saving a few microseconds, but because it reduces the amount of the system which must be written in assembler language in order to obtain reasonable performance. This opens more of the system to user extensions. Another improvement has been in the data structure used to represent the editing buffer: Multics EMACS developed the technique of using a doubly-linked list of lines, each being a string. This technique is used in ZWEI as well.
翻译:因为EMACS为实施者提供了一个清晰的实施目标，他们的重点在于使基础更加干净。本质上的改进是用一种优秀的编程语言Lisp替换了在EMACS中使用的临时扩展TECO。Lisp在一个比TECO更干净的框架内提供了必要的语言特性。此外，它也更有效率。一个Lisp解释器本质上比像TECO那样的字符串扫描解释器更有效率，并且也有Lisp编译器可用。这种效率不仅对于节省几微秒很重要，还因为它减少了为了获得合理性能而必须用汇编语言编写的系统部分的数量。这使更多的系统对用户的扩展开放。另一个改进是在表示编辑缓冲区的数据结构方面：Multics EMACS开发了使用双链表行的技术，每行都是一个字符串。这项技术在ZWEI中也得到了应用。

Many other editors imitate the EMACS command set and display updating philosophy without providing extensibility. Despite that deficiency, and despite the greatly reduced set of features that results from it, these can be useful editors, though not as useful as an extensible one. For a computer with a small address space or lacking virtual memory, this is probably the best that can be done.[[#FOOT7][(7)]]
翻译:许多其他编辑器模仿了EMACS命令集和显示更新哲学，但没有提供可扩展性。尽管存在这种缺陷，并且由于它而大大减少了功能集，但这些仍然可以是有用的编辑器，尽管不如可扩展的那么有用。对于地址空间较小或缺乏虚拟内存的计算机来说，这可能就是最好的办法。[[#FOOT7][(7)]]

The proliferation of such superficial facsimiles of EMACS has an unfortunate confusing effect: their users, knowing that they are using an imitation of EMACS, and never having seen EMACS itself, are led to believe that they are enjoying all the advantages of EMACS. Since any real-time display editor is a tremendous improvement over what they probably had before, they believe this readily. To prevent such confusion, we urge everyone to refer to a nonextensible imitation of EMACS as an `Ersatz EMACS'.
翻译:这类肤浅的EMACS仿制品的大量出现产生了不幸的混淆效果：他们的用户知道他们使用的是一个模仿EMACS的程序，却从未真正见过真正的EMACS，因此会误以为自己正在享受所有EMACS的优势。由于任何实时显示编辑器都比他们之前可能使用的要好得多，所以他们很容易相信这一点。为了防止这种混淆，我们敦促每个人都将一个不可扩展的EMACS仿制品称为“替代EMACS”。

The conventional wisdom has it that when a program intended for multiple users is to be written, specifications should be designed in advance. It this is not done, the result will be inferior. The place to try anything new is in a research project which users will not see.
翻译:传统观念认为，当编写一个面向多个用户的程序时，应该提前设计规格说明。如果不这样做，结果将会很差。尝试新事物的地点是在一个用户不会看到的研究项目中。

Some people know better than this, but they have been silenced.
翻译:有些人比这知道得更好，但他们被沉默了。

The development of EMACS followed a path that most authorities would say is a direct route to disaster. It was the continuous deformation of TECO into something which is totally unlike TECO, from the typical user's point of view. And during the whole process, TECO and programs containing TECO were the only text editors we had on ITS.[[#FOOT8][(8)]] Indeed, there are ways in which EMACS shows the results of not having been completely thought out in advance: such as, in being based on TECO rather than Lisp. But it is still reliable enough to be widely used and imitated. The disaster which would have been forecast has not occurred. Instead, a new and powerful way of constructing editors has been explored and shown to be good.
翻译:EMACS的开发遵循了大多数权威人士认为是一条直接通往灾难的道路。它是对TECO的不断变形，从典型用户的视角来看，已经完全不同于TECO。在整个过程中，TECO以及包含TECO的程序是我们ITS上唯一的文本编辑器。[[#FOOT8][(8)]]确实，在某种程度上，EMACS显示出在没有事先彻底考虑的情况下所得到的结果：例如，它是基于TECO而不是Lisp。但仍然足够可靠，被广泛使用和模仿。曾经预测的灾难并没有发生。相反，探索并证明了这是一种构建新式强大编辑器的新方法。

I believe that this is no accident. EMACS could not have been reached by a process of careful design, because such processes arrive only at goals which are visible at the outset, and whose desirability is established on the bottom line at the outset. Neither I nor anyone else visualized an extensible editor until I had made one, nor appreciated its value until he had experienced it. EMACS exists because I felt free to make individually useful small improvements on a path whose end was not in sight.
翻译:我相信这不是偶然的。EMACS不可能通过一个精心设计的过程达到，因为这样的过程只能达到一开始就可见的目标，其可取性也是从一开始就在底线确立的。在我制作出一个可扩展编辑器之前，我以及任何其他人都没有预见到它，直到他亲身体验过之后才欣赏到它的价值。EMACS之所以存在，是因为我觉得自己可以自由地在看不到尽头的道路上对个别有用的微小改进进行尝试。

While there was no overall goal, each small change had a specific purpose in terms of improving the text editor in general use, and each step had to be individually well designed and reliable. This helped to keep things on the right track. Research projects with no users tend to improve the state of the art of writing research projects, rather than the state of the art of writing usable system tools.
翻译:虽然没有总体目标，但每个小的更改在提高通用文本编辑器方面都有其特定的目的，而且每一步都必须单独设计良好且可靠。这有助于保持事情朝着正确的方向发展。没有用户的科研项目往往会提升编写科研项目的技术水平，而不是提升编写可用系统工具的水平。

The individual commands of EMACS benefited from a stage of unregulated experimentation also. When the display processor and the capability for extension were created, many users began to write extensions, which developed into the complete editing environments of which EMACS is the most recent. Each command in EMACS benefits from the experimentation by many different users customizing their editors in different ways since that time. This experimentation was possible only because a programmable display editor existed.
翻译:EMACS 的各个命令也受益于一段不受管制的实验阶段。当显示处理器和扩展功能被创建出来后，许多用户开始编写扩展程序，这些扩展最终发展成了完整的编辑环境，其中 EMACS 是最新的一个。自从那时起，由于存在可编程显示编辑器，许多不同用户以不同的方式自定义他们的编辑器，使得每个 EMACS 命令都能从中受益。这种实验之所以成为可能，只因为有一个可编程显示编辑器存在。

New implementations of EMACS can now be carefully designed, because they have the advantage of hindsight based on the original EMACS. However, the implementor must carefully restrict his careful design to the parts of the editor that are already well understood. To go beyond the original EMACS, he must experiment. But why isn't such a program of exploration doomed to be sidetracked by a blind alley, which will be unrecognized until too late? It is the extensibility, and a flexibility of mind, which solves this problem: many alleys will be tried at once, and blind alleys can be backed out of with minimal real loss.
翻译:新的EMACS实现现在可以精心设计，因为它们具有基于原始EMACS的优势。然而，实施者必须小心翼翼地将他的谨慎设计限制在已经了解良好的编辑器部分。为了超越原始的EMACS，他必须进行实验。但是，为什么这样一个探索程序不会注定被死胡同误导，直到太迟才被发现呢？正是可扩展性和灵活的思维解决了这个问题：同时尝试许多小巷，并且可以用最小的实际损失退出死胡同。

The traditional attitude towards Lisp holds that it is useful only for esoteric amusements and Artificial Intelligence. The appearance of Multics EMACS as a Honeywell product is the death knell of this view. Now, a mainframe manufacturer is offering a system utility program written in Lisp; a program intended for heavy use by the general user community. The special properties of Lisp, which make extensibility possible, are a key feature, even though many of the users will not be programmers. Lisp has escaped from the ivory tower forever, and is a force to be reckoned with as a system programming language.
翻译:传统的看法认为Lisp只适用于神秘娱乐和人工智能领域。Honeywell公司推出的Multics EMACS系统作为一个产品出现，标志着这种观点的终结。现在，一家大型计算机制造商提供了一个用Lisp编写的系统实用程序；一个旨在被普通用户群体广泛使用的程序。正是Lisp的特殊性质，使得扩展成为可能，这成为了关键特性，尽管许多用户并不是程序员。Lisp已经永远走出了象牙塔，作为一种系统编程语言，它已经成为不容忽视的力量。

The programmable editor is an outstanding opportunity to learn to program! A beginner can see the effect of his simple program on the text he is editing; this feedback is fast and in an easily understood form. Educators have found display programming to be very suited for children experimenting with programming, for just this reason (see LOGO).
翻译:可编程编辑器是学习编程的一个绝佳机会！初学者可以看到他编写的简单程序对正在编辑的文本产生的影响；这种反馈快速且易于理解。教育工作者发现显示编程非常适合儿童进行编程实验，正是因为这个原因（参见LOGO）。

Programming editor commands has the additional advantage that a program need not be very large to be tangibly useful in editing. A first project can be very simple. One can thus slide very smoothly from using the editor to edit into learning to program with it.
翻译:编程编辑器命令的另一个优点是，一个程序不需要非常大就可以在编辑中明显有用。第一个项目可以非常简单。因此，人们可以从使用编辑器进行编辑平滑过渡到用它来学习编程。

When large numbers of nontechnical workers are using a programmable editor, they will he tempted constantly to begin programming in the course of their day-to-day lives. This should contribute greatly to computer literacy, especially because many of the people thus exposed will be secretaries taught by society that they are incapable of doing mathematics, and unable to imagine for a moment that they can learn to program. But that won't stop them from learning it if they don't know that it is programming that they are learning! According to Bernard Greenberg, this is already happening with Multics EMACS.
翻译:当大量非技术工人使用可编程编辑器时，他们会在日常生活中不断地被诱惑开始编程。这将极大地促进计算机素养的提高，特别是因为这些因此受到影响的许多人将是社会认为他们无法进行数学运算、甚至一刻也无法想象自己能够学会编程的秘书们。但如果他们不知道自己在学习的是编程，那么这并不会阻止他们去学！据Bernard Greenberg介绍，这种情况已经在Multics EMACS中发生了。

The way EMACS records what remains on the screen, and compares it with what is now in the text being edited, is determined by the representation used for that text. The post-EMACS editors use better text representations that make for easier display updating algorithms.
翻译:emacs记录屏幕上剩余内容并与现在被编辑的文本进行比较的方式是由该文本使用的表示法决定的。后emacs编辑器使用更好的文本表示法，这使得显示更新算法更加简单。

The representation used in EMACS is a straightforward linear string of characters. A movable gap which can grow and shrink makes it unnecessary for insertion and deletion within a small region of the file to move half of the file up and down. The gap was essential in making it practical to insert characters one at a time, instead of en masse in an `insert' command, but aside from that it is made invisible at all but the lowest levels of software, so essentially the representation is just a linear string. It is the task of the display processor's auxiliary data to make sense out of the amorphous mass of text.
翻译:在EMACS中使用的表示法是一种简单的线性字符字符串。一个可以增长和缩小的可移动间隙使得在小范围内插入或删除文件中的内容无需将一半的文件上下移动变得没有必要。这个间隙对于使逐个插入字符而不是通过`插入`命令批量插入变得实用至关重要，但除此之外，它除了在最底层的软件级别外都被设置为不可见，因此本质上表示法只是一个线性字符串。显示处理器的辅助数据任务是从无形的文本大屠杀中做出有意义的内容。

The lowest level of avoiding wasteful output is a checksum of the characters displayed on each line of the screen. It a screen line is about to be rewritten, the new and old checksums are compared. If they match, the rewriting is skipped. Once in every 2^36 times this will leave old incorrect text on the screen.
翻译:最低级别的避免浪费输出的方法是校验屏幕上每行显示字符的校验和。如果一个屏幕行即将被重写，那么新旧校验和将被进行比较。如果它们匹配，则跳过重写。大约每2^36次中，这将会留下旧的错误文本在屏幕上。

Higher levels of display optimization work by preserving information which is a byproduct of writing the display--namely, where in the text string the beginning of each screen line comes--and combining it with information which localizes the regions of the text string in which alteration has taken place. This allows it to restrict display update processing to a horizontal band of screen which contains all the necessary changes (often just one line). While processing the other lines on the screen would do no actual output, because of the checksums, even the time to compute the checksums is noticeable to the user as a delay. The same information can be used to decide when some lines on the screen should be moved up or down. When lines are inserted in the middle of the screen, it is much better to scroll the following lines downward (if the terminal can do this) than to rewrite them all in their new positions.
翻译:更高的显示优化级别通过保留编写显示过程中产生的信息来实现，即每个屏幕行的开头在文本字符串中的位置，并将其与定位文本字符串中发生更改区域的信

The record of where in the text string changes have taken place is maintained by requiring every command to return values saying what part of the string it has changed. It can identify a subinterval of the string which contains all the changes made, it can say that no change was made (though the cursor may have been moved), or it can say nothing, which requires the display processor to make no assumptions.
翻译:记录字符串中更改发生位置的日志是通过要求每个命令返回值来说明它改变了字符串的哪些部分来实现的。它可以识别包含所有更改的字符串子区间，可以说没有进行任何更改（尽管光标可能已经移动），或者什么也不说，这需要显示处理器不做出任何假设。

A better way, developed by Bernard Greenberg in Multics EMACS and used in ZWEI, is to represent the buffer as a doubly-linked list containing pointers to strings, one for each line. Newline characters are not actually present, but implicitly appear after each line except the last. This requires the lowest level insert, delete and search subroutines to be more complicated (for example, inserting a string cannot treat Newline characters like other characters), but this is just a finite amount of complexity; and it greatly simplifies efficient display computations. The state of the screen can be remembered in an array of pointers to the string that was displayed on each screen line. When the display is updated, one can compare the strings in the buffer with the strings in the display, both to see whether they are the same objects (the pointers are equal; EQ, in Lisp), and to see whether their contents are the same.
翻译:更好的方法是，由Bernard Greenberg在Multics EMACS中使用并在ZWEI中使用的双链表表示缓冲区，其中包含指向字符串的指针，每个字符串对应一行。实际上并不存在换行符，但在每行的末尾隐含地出现。这需要最低级别的插入、删除和搜索子程序更复杂（例如，插入字符串不能将换行符视为其他字符），但这只是有限量的复杂性；而且它极大地简化了有效的显示计算。屏幕的状态可以保存在一个数组中，该数组指向每个屏幕行上显示的字符串。当更新显示时，可以将缓冲区中的字符串与显示中的字符串进行比较，既要看它们是否是相同的对象（指针相等；EQ，在Lisp中），也要看它们的內容是否相同。

Multics EMACS never changes the contents of a string in the buffer. It creates new strings to replace the old ones when the text changes. Thus, the string pointers in the screen state continue to record the screen as it was.
翻译:多ICS Emacs从不改变缓冲区中的字符串内容。当文本更改时，它会创建新字符串来替换旧字符串。因此，屏幕状态中的字符串指针继续记录屏幕的原貌。

ZWEI does change the contents of existing strings. To make sure that it does not fail to notice that the text no longer matches the screen, ZWEI maintains a `clock' which increments each time a change is made in the text. Each line records the clock tick of the last modification. Each screen line records the clock tick as of the time it was displayed. If the line in the text matches the line in the screen record, but the tick counts do not match, then the contents of the line have been changed.
翻译:ZWEI确实会更改现有字符串的内容。为了确保它不会因为没有注意到文本不再与屏幕匹配而失败，ZWEI维护了一个`时钟`，每次对文本进行更改时都会增加一次。每条记录都保存了最后修改的时间戳。每个屏幕行记录的是显示时的时钟时间戳。如果文本中的行与屏幕记录中的行相匹配，但时间戳计数不匹配，那么该行的内容已被更改。

Line list representations also eliminate the requirements on commands to say what they have changed. Reducing the need for the programmer to worry about how display will be done is very desirable. Another advantage is that it becomes feasible to have pointers to characters in the text which relocate when insertions or deletions are done, so that they continue to point to the same place in the text.
翻译:行列表表示法还消除了命令需要说明它们更改了什么的必要性。减少程序员对显示方式如何实现的担忧是非常理想的。另一个优点是，当进行插入或删除操作时，可以实现在文本中指向字符的指针重新定位，以便它们继续指向文本中的同一位置，变得可行起来。

An EMACS sharable library contains, first of all, a symbol table which can be binary searched for the name of an object to find the object named. The symbol table points at both the names and the definitions using offsets from the beginning of the file, so that the file can be valid at any location in memory. The names and definitions are all examples of the TECO string data type, in the internal TECO format, so that the library does not need to be translated or parsed in any way when it is loaded.
翻译:一个可共享的EMACS库首先包含一个符号表，该表可以通过二分查找来找到命名对象的名称以获取对象。符号表指向名称和定义，使用从文件开头偏移的字节来定位，这样文件可以在内存中的任何位置都是有效的。名称和定义都是TECO字符串数据类型的实例，采用内部的TECO格式，因此当加载库时不需要对其进行任何形式的转换或解析。

The symbol table points to the documentation of functions in the library as well as their definitions. The documentation for the function =Visit File= is an object entered in the symbol table with the name =~Doc~ Visit File=. There is also a string named =~Directory~= whose definition contains a list of the names of all the objects in the file which the library wishes to advertise. This is used for documentation purposes, not for looking up names, and it does not contain names of auxiliary objects such as =~Doc~ V1sit File= or =~D1rectory~=.
翻译:符号表指向库中函数及其定义的文档。对于函数“=Visit File=”的文档是作为对象记入符号表的，其名称为“~=Doc~ Visit File=”。还有一个字符串名为“~=Directory~=”，其定义包含了一个列表，列出了库希望宣传的所有文件对象的名称。这用于文档目的，而不是查找名称，它不包含辅助对象如“~=Doc~ V1sit File=”或“~=D1rectory~=”之类的名称。

It is possible to search the symbol table in reverse, to take a definition and find its name. Since one can tell which library an object is in by comparing its address with the range of memory occupied by the library, this makes it possible to find the name of any object which has one. The ability to do this is important, because when the user asks what the character Control-K does, it is desirable to be able to tell him that it runs the function =Kill Line=. The names themselves are not kept in the dispatch table because looking up a name in the loaded libraries is slow. For other implementations, that is a reasonable strategy.
翻译:可以反向搜索符号表，通过一个定义找到它的名字。由于可以通过比较对象的地址与库占用的内存范围来确定对象所在的库，这使得能够找到任何具有名称的对象的名字。这种能力很重要，因为当用户询问控制字符Control-K的功能是什么时，最好能告诉他它运行的是=Kill Line=函数。然而，这些名称本身并不保存在派发表中，因为在一个已加载的库中查找名称的速度很慢。对于其他实现来说，这是一个合理的策略。

EMACS is available for distribution to sites running the Digital Equipment Corporation Twenex (`Tops-20') operating system. It is distributed on a basis of communal sharing, which means that all improvements must be given back to me to be incorporated and distributed. Those who are interested should contact me. Further information about how EMACS works is available in the same way.
翻译:emacs适用于运行Digital Equipment Corporation Twenex（`Tops-20'）操作系统的站点分发。它基于共同分享的原则进行分发，这意味着所有改进都必须反馈给我以供整合和分发。有兴趣的人应该联系我。有关emacs如何工作的更多信息也可以同样方式获得。

A complete manual for use (but not extension) of EMACS is
翻译:《EMACS使用手册（仅限基本功能，不含扩展）》

- Richard M. Stallman, EMACS Manual for ITS Users, Artificial Intelligence Lab memo 554, 1980.
翻译:理查德·马修·斯托曼，《Emacs手册：ITS用户指南》，人工智能实验室备忘录554号，1980年。
- Richard M. Stallman, EMACS Manual for TWENEX Users, Artificial Intelligence Lab memo 555, 1980.
翻译:理查德·马修·斯塔尔曼，《EMACS手册：TWENEX用户指南》，人工智能实验室备忘录555号，1980年。

Various lower level implementation strategies for parts of an EMACS-like editor are treated in
翻译:各种用于类似EMACS编辑器的部分之低级实现策略被处理了。

- Craig A. Finseth, Theory and Practice of Text Editors, or, A Cookbook for an Emacs, L.C.S. Technical Memo TM--165, B.S. Thesis, May 1980.
翻译:克雷格·A·芬塞斯，《文本编辑器的理论与实践》，或《Emacs烹饪书》，LCS技术备忘录TM--165，学士学位论文，1980年5月。

These include the true extensible descendents of EMACS, and the editors which preceded EMACS and supplied some of the ideas for it. The many ersatz EMACS editors are not included.
翻译:这包括真正的可扩展后裔EMACS，以及先于EMACS并为其提供一些想法的编辑器。众多的冒牌EMACS编辑器不包括在内。

- Multics EMACS :: Multics EMACS was written in MacLisp by Bernard S. Greenberg of Honeywell's Cambridge Information Systems Lab, starting in 1978. When first implemented, it could be used only by its author, because he alone had the necessary privileges to patch the Multics operating system so that a program could read one character from the keyboard instead of waiting for a complete line. After seeing the new editor in operation, the other Honeywell people were convinced to make the feature generally available. Because it is written in Lisp, Multics EMACS is even more extensible than the original EMACS, and as a result it has accumulated even more powerful features.
翻译:多ICS Emacs:: 多ICS Emacs是由Honeywell剑桥信息系统实验室的Bernard S. Greenberg于1978年开始用MacLisp编写的。最初实现时，只能由其作者使用，因为他一个人拥有必要的权限来修补Multics操作系统，以便程序可以从键盘读取一个字符而不是等待完整的行。在看到新编辑器运行后，其他Honeywell人都被说服使该功能普遍可用。由于它是用Lisp编写的，所以多ICS Emacs比原始Emacs更具可扩展性，因此积累了更多强大的功能。

- Bernard S. Greenberg, Multics Emacs: an Experiment in Computer Interaction, in proceedings, Fourth Honeywell International Software Conference, Bloomington, Minn., April, 1979
翻译:伯纳德·S·格林伯格，《Multics Emacs：计算机交互实验》，第四届霍尼韦尔国际软件会议论文集，明尼苏达州布卢明顿，1979年4月。
- Bernard S. Greenberg, Prose and CONS (Multics Emacs: a commercial text processing system in Lisp), in proceedings, 1980 Lisp Conference, Stanford University, Stanford, California, August 1980.
翻译:伯纳德·S·格林伯格，《散文与CONS》(多ICS emacs：一种商业文本处理系统在Lisp中)，1980年Lisp会议论文集，斯坦福大学，加利福尼亚州斯坦福，1980年8月。
- Bernard S. Greenberg, and Katie Kissel, Multics Emacs Text Editor User's Guide, Publication #CH27, Honeywell Information Systems, Waltham, Mass., 1979.
翻译:伯纳德·S·格林伯格和凯蒂·基塞尔，《Multics Emacs 文本编辑器用户指南》，出版物编号 CH27，霍尼韦尔信息系统，马萨诸塞州沃尔瑟姆，1979年。
- Bernard S. Greenberg, Multics Emacs Extension Writers' Guide, Publication #CJ52, Honeywell Information Systems, Waltham, Mass., 1980
翻译:伯纳德·S·格林伯格，《Multics Emacs扩展编写指南》，出版物编号CJ52，霍尼韦尔信息系统，马萨诸塞州沃尔瑟姆，1980年
- SINE :: SINE (`SINE Is Not EMACS') is based on compiling Lisp code to run in a non-Lisp editor environment, in which, unfortunately, no interpreter is present. However, the user can load his own compiled files into a running editor. This design was chosen because of the small address space of the machine, an Interdata at the MIT Architecture Machine Group. See
翻译:SINE（SINE不是EMACS）是基于编译Lisp代码以在非Lisp编辑器环境中运行的程序，遗憾的是，在这种环境下没有解释器存在。然而，用户可以将自己的编译文件加载到正在运行的编辑器中。这种设计是因为机器的地址空间很小，是在麻省理工学院建筑机组的一台Interdata上选择的。参见

- Owen T.Anderson, The Design and Implementation of a Display-Oriented Editor Writing System, Undergraduate Thesis, MIT Physics Department, January 1979.
翻译:欧文·T·安德森，《面向显示器的编辑系统设计与实现》，麻省理工学院物理系本科论文，1979年1月。
- TECMAC :: TECMAC was the first editor implemented in TECO to work with the display processor. It developed many of the ideas used in the EMACS user interface. It was retired because, written when TECO was less suited to system programming, it was unable to attain either readability or efficiency. TECMAC was maintained from 1974 to 1976 by John L. Kulp and Richard L. Bryan.
翻译:TECMAC::TECMAC是第一个在TECO中实现的与显示处理器协同工作的编辑器。它发展了许多后来用在EMACS用户界面中的思想。由于当时TECO不太适合系统编程，所以它既不能达到可读性也不能达到效率，因此被淘汰了。从1974年到1976年，由John L. Kulp和Richard L. Bryan维护。
- TECO :: PDP--10 TECO was originally written by Richard Greenblatt, Stew Nelson and Jack Holloway at the MIT Artificial Intelligence Lab, based on PDP--1 TECO which was written by Murphy in 1962. The TECO in which EMACS is implemented is its direct descendant. The PDP--10 TECO from Digital, a typical example of TECO, is also a descendant of an early version from MIT. It is documented in
翻译:TECO :: PDP--10 TECO最初由Richard Greenblatt、Stew Nelson和Jack Holloway在麻省理工学院人工智能实验室编写，基于1962年由Murphy编写的PDP--1 TECO。EMACS实现的TECO是其直接后裔。Digital公司的PDP--10 TECO是典型的TECO示例，也是MIT早期版本的一个后裔。它在文档中有说明。



- Digital Equipment Corporation, DECsystem-10 TECO Programmer's Reference Manual, DEC--10--ETEE--D (revised from time to time).
翻译:数字设备公司，DECsystem-10 TECO程序员参考手册，DEC--10--ETEE--D（不时修订）。

Ordinary TECO lacks many important programming constructs. In MIT TECO, the constructs may be syntactically ugly, but they exist. So programs can be well organized, and clean except in the lowest level of detail.
翻译:普通TECO缺少许多重要的编程结构。在MIT TECO中，这些结构虽然在语法上可能不太美观，但确实是存在的。因此，程序可以很好地组织，除了在最底层的细节之外，都是整洁的。
- TMACS :: TMACS was an editor implemented in TECO which began to develop the idea of the sharable library with commands that could be assigned to keys by the user. TMACS was the project of Dave Moon, Charles Frankston, Earl A. Killian, and Eugene C. Ciccarelli. Interestingly, it had no standard command set. The implementors were unable to agree on one, which is what motivated them to work on making customization easier.
翻译:TMACS 是用TECO编写的编辑器，它开始发展可共享库的概念，其中命令可以由用户分配给键。TMACS是Dave Moon、Charles Frankston、Earl A. Killian和Eugene C. Ciccarelli的项目。有趣的是，它没有一个标准的命令集。实施者无法达成一致，这促使他们致力于使定制变得更加容易。
- ZWEI :: ZWEI (`ZWEI Was EINE Initially') is the editor for the Lisp machine. EINE (`EINE Is Not EMACS'), the former editor for the Lisp machine, was also based on EMACS; it was operational for late 1977 and 1978, and was redone to make it cleaner. Both EINE and ZWEI are primarily the work of Daniel Weinreb and Mike McMahon; see
翻译:ZWEI 是Lisp机器的编辑器。"ZWEI"（意为“ZWEI曾是EINE”）是基于EMACS的前任Lisp机器编辑器；它在1977年底和1978年期间投入使用，并被重新设计以使其更简洁。EINE 和 ZWEI 主要是由Daniel Weinreb和Mike McMahon开发的；详情请见

- Daniel L. Weinreb, A Real-Time Display-oriented Editor for the LISP Machine, Undergraduate Thesis, MIT EECS Department, January 1979.
翻译:丹尼尔·L·温雷布，《面向显示器的实时编辑器》，麻省理工学院电子工程与计算机科学系本科论文，1979年1月。

- Augment :: Augment (formerly known as NLS) is a display editor whose interesting feature is its ability to structure files into trees. Making the tree structure useful required the concept of the viewspec, which specifies that only certain levels in the tree structure will be visible. This is the sort of feature which cannot be added by a user to EMACS, because it involves modification of the display processor; but it could be added by a user to Multics EMACS or ZWEI. Augment popularized the graphical input device known as the `mouse', which is a small box with wheels or balls on the bottom and buttons on the top, which the user moves on the table with his hand. This device has been copied widely because of its simplicity and low cost. Augment was designed at SRI International but is now supplied by Tymshare. See
翻译:Augment（前称NLS）是一款显示编辑器，其有趣的功能是将文件结构化为树形。使树状结构有用需要引入视图规范的概念，该概念指定只有树状结构中的某些级别才会可见。这类功能无法通过用户添加到EMACS中，因为它涉及到修改显示处理器；但用户可以将其添加到Multics EMACS或ZWEI中。Augment普及了被称为`鼠标`的图形输入设备，这是一种底部有轮子或球体、顶部有按钮的小盒子，用户可以通过手在桌子上移动它。由于其简单性和低成本，这种设备已被广泛复制。Augment最初由SRI国际设计，但现在由Tymshare供应。参见

- Douglas C. Engelbart and William K. English, A Research Center for Augmenting Human Intellect, AFIPS Conference Proceedings, Vol. 33, Fall Joint Computer Conference, San Francisco, December 1968, pp. 395--410.
翻译:道格拉斯·C·恩格尔巴特和威廉·K·英格利希，《增强人类智能的研究中心》，AFIPS会议论文集，第33卷，秋季联合计算机会议，旧金山，1968年12月，第395至410页。
- Patricia B. Seybold, TYMSHARE'S AUGMENT--Heralding a New Era, The Seybold Report on Word Processing, Vol. 1, No. 9, October 1978, 16 pp. (ISSN: 0160--9572), Seybold Publications, Inc., Box 644, Media, Pa 19063.
翻译:帕特丽夏·B·塞博尔德，《TYMSHARE的增强——宣告新时代的到来》，《赛博尔德报告：文字处理》，第1卷，第9期，1978年10月，16页（国际标准刊号：0160--9572），赛博尔德出版公司，宾夕法尼亚州媒体市邮政信箱644号。
- Bravo :: Bravo comes from the Xerox Palo Alto Research Center. Its orientation is toward text formatting, and it can display multiple fonts, underlining, etc. It makes heavy use of a graphical pointing device, the `mouse' (see Augment). It is not programmable and offers no special help for editing programs as opposed to text. For more information, see your local industrial espionage agent.
翻译:祝贺::Bravo 来自施乐帕罗奥图研究中心。它的定位是面向文本格式化，可以显示多种字体、下划线等。它大量使用图形指点设备，即“鼠标”（参见Augment）。它是不可编程的，也没有为编辑程序而不是文本提供特殊帮助。有关更多信息，请参阅您当地的工业间谍代理人。
- E :: The editor used at the Stanford Artificial Intelligence Lab, E interfaces with a `line editor' (used to edit within a line, on a display terminal) which can also be employed to edit the input to any other program. The line editor does not allow commands to be redefined; since it is part of the timesharing system, that is not trivial (though possible in principle). E allows macros to be written using the same language used for editing. These are as powerful as a Turing machine, and as easy to program with. See the on-line documentation file =`E.ALS[UP,DOC]'= of the Stanford Artificial Intelligence Laboratory.
翻译:- E：斯坦福人工智能实验室使用的编辑器E与一个“行编辑器”（用于在显示终端上对一行进行编辑）接口，也可以用来编辑任何程序的输入。行编辑器不允许重新定义命令；由于它是时分系统的一部分，这并不简单（尽管从原则上讲是可能的）。E允许使用相同的语言编写宏。这些宏具有图灵机的功能，并且易于编程。参见斯坦福人工智能实验室在线文档文件=E.ALS[UP,DOC]=。

请注意，我已将图片中的英文文本翻译为中文，并保持了原文的格式。如果需要进一步的帮助或修改，请告诉我！
- TRIX :: TRIX is a language similar to TRAC designed at Lawrence Livermore Lab specifically for writing editors. It has been used to write commands that are specific to particular languages, and to write text formatters. Its fatal flaw is that it was designed for printing terminals. See
翻译:TRIX :: TRIX 是一种类似于 TRAC 的语言，专门在劳伦斯·利弗莫尔国家实验室设计用于编写编辑器。它被用来编写特定于某种语言的命令以及文本文档格式化程序。然而，它的一个致命缺陷是它最初是为打印终端设计的。参见

- Cecil, Moll and Rinde, TRIX AC: A Set of General Purpose Text Editing Commands, Lawrence Livermore Lab UCID 30040, March 1977.
翻译:塞西尔、莫尔和林德，特里克斯AC：一套通用的文本编辑命令，劳伦斯·利弗莫尔实验室UCID 30040，1977年3月。
- TVEDIT :: TVEDIT is a distant relative of E (above) which is used at Stanford on the Twenex and Tenex operating systems. These systems do not provide a line editor, so TVEDIT has its own facilities for changes within lines. TVEDIT is a good example of a generally reasonable but nonprogrammable display editor. See
翻译:电视编辑器:: 电视编辑器是E（上述）的一个远亲，在斯坦福大学的Twenex和Tenex操作系统上使用。这些系统不提供一个行编辑器，因此TVEDIT具有自己用于行内更改的功能。TVEDIT是一个一般合理但不可编程显示编辑器的良好示例。参见

- Pentti Kanerva, TVGUID: A User's Guide to TEC/DATAMEDIA TV-Edit, Stanford University, Institute for Mathematical Studies in the Social Sciences, 1973. (Online document)
翻译:Pentti Kanerva，《电视指南：TEC/DATAMEDIA电视编辑的用户手册》，斯坦福大学社会科学数学研究学院，1973年。(在线文档)。

- The Lisp Machine :: The MIT Artificial Intelligence Laboratory has built a machine specifically for the purpose of running large Lisp programs more cheaply than ever before. One of its goals is to make the entire software system interactively extensible by writing it in Lisp and allowing the user to redefine the functions composing the innards of the system. Part of the system is an EMACS-like editor (ZWEI; see above) written entirely in Lisp, which shares in this extensibility. See
翻译:《Lisp机器》::麻省理工学院人工智能实验室建造了一台专门用于以比以往任何时候都更低的成本运行大型Lisp程序的目的。它的一个目标是使整个软件系统可以通过用Lisp编写并允许用户重新定义组成系统内部的函数来实现交互式扩展。系统的部分内容是一个类似于EMACS的编辑器（ZWEI；参见上文），它完全是用Lisp编写的，并且共享这种可扩展性。参阅

- Daniel Weinreb and Dave Moon, The Lisp Machine Manual, MIT Artificial Intelligence Laboratory.
翻译:丹尼尔·温雷布和戴夫·穆恩，《Lisp机器手册》，麻省理工学院人工智能实验室。
- LOGO :: LOGO is a language used for teaching children how to think clearly. Unlike conventional computer-aided instruction, which automates a method of teaching which offers little to motivate the student, LOGO invites students to write programs to produce interesting pictures and learn while doing something fun.
翻译:LOGO是一种用于教孩子如何清晰思考的语言。与传统的计算机辅助教学不同，后者自动化了一种教学方法，这种方法对学生来说缺乏激励，而LOGO则邀请学生编写程序以生成有趣的图片，在做一些有趣的事情的同时学习。

- Seymour Papert, Teaching Children to be Mathematicians vs. Teaching About Mathematics,
翻译:西摩·帕普特，《教学儿童数学》与《教授数学知识》
`[[ftp://publications.ai.mit.edu/ai-publications/0-499/AIM-249.ps,MIT%0AArtificial%20Intelligence%20Laboratory%20Memo%20249][=ftp://publications.ai.mit.edu/ai-publications/0-499/AIM-249.ps,MIT Artificial Intelligence Laboratory Memo 249=]]', 1971.
翻译:[ [ ftp://publications.ai.mit.edu/ai-publications/0-499/AIM-249.ps , MIT人工智能实验室备忘录249 ] ] ，1971年。
- MacLisp :: The MacLisp language is very suitable for writing extensible interactive programs, and has been used for the implementation of Multics EMACS. See
翻译:MacLisp :: MacLisp 语言非常适合编写可扩展的交互式程序，并且已被用于实现Multics EMACS。参见

- Dave Moon, MacLisp Reference Manual, MIT Laboratory for Computer Science, 1974.
翻译:戴夫·穆恩，《MacLisp参考手册》，麻省理工学院计算机科学实验室，1974年。
- Smalltalk :: The Smalltalk language and system is oriented toward writing extensible programs.
翻译:小谈:: 小谈语言和系统面向编写可扩展程序。

- Dan H.H. Ingalls, The Smalltalk--76 Programming System Design and Implementation, in proceedings, Fifth Annual ACM Symposium on Principles of Programming Languages.
翻译:丹·H·H·英格尔斯，《Smalltalk--76编程系统设计与实现》，第五届ACM程序设计原理年度研讨会论文集。

** Footnotes
:PROPERTIES:
:CUSTOM_ID: footnotes
:END:

*** (1)
:PROPERTIES:
:CUSTOM_ID: FOOT1
:END:

EMACS stood for Editing Macros, before we realized that EMACS is composed of functions written in a programming language rather than macros in the editor TECO.
翻译:EMACS 最初代表 Editing Macros（编辑宏），在我们意识到 EMACS 实际上是由用编程语言编写的函数组成的，而并非编辑器 TECO 的宏之前。

*** (2)
:PROPERTIES:
:CUSTOM_ID: FOOT2
:END:

Meta is the name of a shift key on the ideal EMACS terminal. On terminals which do not have this key, the ASCII character Escape is used as a prefix instead.
翻译:元是理想EMACS终端上的换档键名称。在缺少此键的终端上，使用ASCII字符Esc作为前缀。

*** (3)
:PROPERTIES:
:CUSTOM_ID: FOOT3
:END:

The process of reading the argument from the terminal is implemented by a function which the user can replace.
翻译:从终端读取参数的过程是通过一个用户可以替换的功能实现的。

*** (4)
:PROPERTIES:
:CUSTOM_ID: FOOT4
:END:

This particular sequence of events poses no problem on terminals which can move text up and down on the screen. But the same problem can still result from other events.
翻译:这个事件序列在可以上下滚动屏幕文本的终端上没有问题。但是，其他事件仍然可能导致同样的问题。

*** (5)
:PROPERTIES:
:CUSTOM_ID: FOOT5
:END:

It is o.k. to use a Lisp compiler, if there is one. What counts is not using the interpreter all the time, but having it available all the time.
翻译:如果有的话，使用Lisp编译器是可以的。关键不在于是否总是使用解释器，而在于它始终可用。

*** (6)
:PROPERTIES:
:CUSTOM_ID: FOOT6
:END:

Normally the command reading loop uses the name of the command to compute the name of the function to call. For example, if RMAIL reads the letter N as a command, it calls the function =# RMAIL N=. This way the user can easily define new commands.
翻译:通常情况下，命令读取循环使用命令的名称来计算要调用的函数名称。例如，如果RMAIL读取字母N作为命令，它调用函数=# RMAIL N=。这样，用户可以轻松地定义新命令。

*** (7)
:PROPERTIES:
:CUSTOM_ID: FOOT7
:END:

The standard EMACS system is bigger than the entire 64k-byte address space of the PDP--11, despite constant strenuous efforts to reduce its size. And TECO is equally large. The post-EMACS editors are even larger.
翻译:标准的emacs系统比PDP--11整个64k字节的地址空间还要大，尽管不断地努力减小它的尺寸。而TECO也同样庞大。后来的emacs编辑器甚至更大。

*** (8)
:PROPERTIES:
:CUSTOM_ID: FOOT8
:END:

The Incompatible Timesharing System.
翻译:不相容的分时系统

This document was generated on 11 Febuary 1998 using the [[https://www.nongnu.org/texi2html/][texi2html]] translator, version 1.51a (originally located at http://wwwcn.cern.ch/dci/texi2html/).
翻译:本文件于1998年2月11日生成，使用的是[[https://www.nongnu.org/texi2html/][texi2html]]翻译器，版本为1.51a（最初位于http://wwwcn.cern.ch/dci/texi2html/）。

Copyright © 1981 Richard Stallman Verbatim copying and distribution of this entire article are permitted worldwide, without royalty, in any medium, provided this notice is preserved.
翻译:版权所有© 1981年理查德·马修斯全文复制和分发本文在全球范围内均被许可，无需支付版税，在任何介质上均可进行，前提是保留此通知。
