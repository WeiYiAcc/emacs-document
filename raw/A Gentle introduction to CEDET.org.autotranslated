#+TITLE: A Gentle introduction to CEDET
#+URL: http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2020年 01月 15日 星期三 14:29:17 HKT]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
This article doesn't pretend to be detailed description on how to setup Emacs to be
翻译:这篇文章并不假装是对如何设置Emacs以使其成为
complete development environment. I just tried to provide a small description on "How to
翻译:完整的开发环境。我只是试图对“如何”
setup [[http://cedet.sf.net][CEDET]] to work with C, C++ & Java", although most of this description will be also
翻译:安装[[http://cedet.sf.net][CEDET]]以与C、C++和Java一起工作"，尽管本描述的大多数内容也将适用于
applicable for other languages, supported by CEDET.
翻译:适用于其他语言的编辑器，支持CEDET。

** <<sec1>> What is CEDET?
:PROPERTIES:
:CUSTOM_ID: what-is-cedet
:END:

The CEDET package is a collection of libraries, that implement different commands, but all
翻译:CEDET软件包是一组库，实现了不同的命令，但都
of them have common goal --- provide functionality for work with source code written in
翻译:它们都有一个共同的目标---为使用源代码编写的工作提供功能。
different programming languages (please, take into account that not all of these packages
翻译:不同的编程语言（请注意，并非所有这些包
are included into CEDET bundled with GNU Emacs):
翻译:（包括与GNU Emacs捆绑的分发版CEDET中）：

- Semantic is a base for construction of syntactic analyzers for different programming
翻译:语义是构建不同编程语言的句法分析器的基础。
languages. It provides common representation of information extracted from code. Using
翻译:代码信息提取的通用表示。使用
this information, CEDET & other packages, such as [[http://jdee.sourceforge.net/][JDEE]] and [[http://ecb.sf.net][ECB]], can implement
翻译:这些信息、CEDET以及其他包，如[[http://jdee.sourceforge.net/][JDEE]]和[[http://ecb.sf.net][ECB]]，可以实现
functionality, required for modern development environment --- name completion, code
翻译:功能，适用于现代开发环境---名称完成，代码
navigation, etc.;
翻译:导航等;
- SemanticDB is included into Semantic, and implements different storage modules, that
翻译:语义数据库已集成到语义中，并实现了不同的存储模块，这
store information, needed for names completion, source code navigation, etc. Syntactic
翻译:存储信息，用于名称完成、源代码导航等。语法
information may be saved between Emacs sessions, so this reduces need for re-parsing of
翻译:信息可能会在Emacs会话之间保存，因此这减少了重新解析的需要。
source code that wasn't modified since last parse;
翻译:自上次解析以来未修改的源代码；
- Senator implements navigation in source code using information extracted by Semantic;
翻译:参议员在源代码中使用语义提取的信息实现了导航功能。
- Srecode is a package for source code generation using syntactic information (including
翻译:Srecode 是一个使用语法信息（包括）生成源代码的包
information, extracted by Semantic);
翻译:信息（由语义提取）。
- EDE implements a set of extensions to work with projects --- user can control list of
翻译:EDE 实现了一套扩展来处理项目 --- 用户可以控制列表中的
the targets to build, build the project, etc. Besides this, using the notion of the
翻译:构建目标、构建项目等。除此之外，使用这个概念
project, you can have more precise control over Semantic's operations --- name
翻译:项目，您可以更精确地控制语义的操作---名称
completions, navigation, etc.;
翻译:完成、导航等；
- Speedbar is used to display information about current buffer using different sources of
翻译:速栏用于显示有关当前缓冲区使用不同信息源的详细信息。
information --- Semantic, some specialized information providers (for texinfo & HTML,
翻译:语义、一些专门的信息提供商（用于texinfo和HTML，
for example).
翻译:例如）。
- Eieio is a library, that implements CLOS-like (Common Lisp Object System)
翻译:Eieio 是一个库，它实现了类似 Common Lisp Object System 的 CLOS 风格。
infrastructure for Emacs Lisp;
翻译:Emacs Lisp的基础设施；
- Cogre is a library for generation of UML-like diagrams in Emacs buffer, with basic
翻译:Cogre 是一个在Emacs缓冲区生成类似UML图图的库，具有基本的
integration with Semantic.
翻译:与语义集成。

** <<sec2>> CEDET's versions
:PROPERTIES:
:CUSTOM_ID: cedets-versions
:END:

We need to understand that there are several versions of CEDET, that differ from each
翻译:我们需要理解CEDET有几个版本，它们彼此之间存在差异
other by installation & customization methods:
翻译:通过安装和自定义方法：

- standalone versions of CEDET up to version 1.1 (including) --- these versions are
翻译:独立版本的CEDET直到1.1版（包括）--- 这些版本是
available for [[https://sourceforge.net/projects/cedet/files/][downloading from project's site]]. This version uses "old" layout for
翻译:可以从[[https://sourceforge.net/projects/cedet/files/][项目网站上下载]]。这个版本使用的是“旧”布局。
source code & activation method that isn't compatible with version included into GNU
翻译:源代码与激活方法不兼容GNU内含版本
Emacs. In this version, files with source code often had "long names", like
翻译:Emacs。在这个版本中，源代码文件常常有“长名字”，比如
=semanticdb.el=, or =semantic-gcc.el=, and this made them incompatible with some of
翻译:您提到的这些名称似乎与特定的编程环境或工具相关联，但它们在提供的上下文中没有明确的定义。"semanticdb.el" 可能是指一个 Emacs Lisp 包，用于语义数据库支持；而 "semantic-gcc.el" 则可能是一个为 GCC 编译器提供语义信息的 Emacs 插件。

由于缺乏具体的使用场景和上下文信息，很难确定这些术语的确切含义以及为什么它们会使某些东西变得不兼容。如果您能提供更多的背景信息或者详细描述问题出现的环境和情况，我或许能够给出更准确的解释和建议。
operating systems supported by GNU Emacs;
翻译:GNU Emacs支持的操作系统；
- standalone CEDET versions after 1.1 release --- they use "new" directory layout and the
翻译:独立于CEDET版本1.1之后的版本---它们使用“新”目录布局和
same activation method as in GNU Emacs, but these versions usually have more
翻译:与GNU Emacs中使用的相同激活方法，但这些版本通常具有更多功能
functionality & include some additional packages, like Senator. In this version,
翻译:功能与包含一些额外的包，如Senator。在这个版本中，
layout of source code was changed to match GNU Emacs, so some files was renamed: for
翻译:源代码的布局已改为匹配GNU Emacs，因此一些文件已被重命名：对于
example, =semanticdb.el= was renamed to =semantic/db.el=, and =semantic-gcc.el= became
翻译:例如，`semanticdb.el` 被重命名为 `semantic/db.el`，而 `semantic-gcc.el` 变成了
=semantic/bovine/gcc.el=, etc.
翻译:您上传的图片包含一些英文和数字，看起来像是一些编程代码或者命令行参数。这些内容是：

- semantic/bovine/gcc.el
- etc.

如果您需要对这些内容进行翻译或有任何相关问题，请告诉我。
- version that is bundled with GNU Emacs (starting with GNU Emacs 23.2) --- some packages
翻译:与GNU Emacs捆绑的分发版本（从GNU Emacs 23.2开始）---某些包
aren't included into this version, and code could be "outdated", comparing with current
翻译:不包括在这个版本中，代码可能与当前的相比已经“过时”。
standalone versions of CEDET.
翻译:CEDET 的独立版本。

This article describes new version of CEDET, including version bundled with GNU Emacs. If
翻译:这篇文章描述了CEDET的新版本，包括与GNU Emacs捆绑的分发版本。如果
you want to use standalone release 1.1, or earlier, then you need to read
翻译:如果您想使用独立发行版1.1或更早版本，那么您需要阅读
[[file:EmacsCedetOld.html][previous version of this article]].
翻译:[[文件：EmacsCedet旧版.html][这篇文章的早期版本]]。

** <<sec3>> Installation of standalone CEDET's version
:PROPERTIES:
:CUSTOM_ID: installation-of-standalone-cedets-version
:END:

Right now (October, 2012) there is no released version of CEDET with "new" activation
翻译:目前（2012年10月），还没有发布带有“新”激活功能的CEDET版本。
method, so you need to take [[http://www.randomsample.de/cedet-snapshots/][current snapshot]], or get [[http://cedet.sourceforge.net/bzr-repo.shtml][version from repository]]. Unpack
翻译:方法如下，你需要获取当前的[[http://www.randomsample.de/cedet-snapshots/][快照]]，或者从[[http://cedet.sourceforge.net/bzr-repo.shtml][代码库版本]]中获取。解压
source code, if this is necessary, change to directory & perform following command that
翻译:如果需要的话，更改目录并执行以下命令：
will compile everything:
翻译:将编译所有内容：

#+BEGIN_EXAMPLE
make clean-all && make
#+END_EXAMPLE

** <<sec4>> Customization
:PROPERTIES:
:CUSTOM_ID: customization
:END:

If you're using standalone CEDET's version, then you need to load it with following command:
翻译:如果您使用的是独立的CEDET版本，则需要使用以下命令进行加载：

#+BEGIN_EXAMPLE
(load-file "~/emacs/cedet-bzr/cedet-devel-load.el")
#+END_EXAMPLE

But if you're using CEDET bundled with GNU Emacs, then everything will be already loaded
翻译:如果您使用的是与GNU Emacs捆绑的分发版的CEDET，那么所有必要的组件将会已经加载好了。
on start.
翻译:开始。

*** <<sec5>> Semantic's customization
:PROPERTIES:
:CUSTOM_ID: semantics-customization
:END:

All standalone versions until release 1.1 (including) had activation method that was
翻译:直到1.1版本（包括）的所有独立版本都采用了激活方法
different from method for CEDET bundled into GNU Emacs. In new versions activation of
翻译:与GNU Emacs捆绑的CEDET方法不同。在新版本中，激活
package is performed by adding of symbols for selected sub-modes into special list, and
翻译:包是通过将选定的子模式的符号添加到特殊列表中完成的。
then activating =semantic-mode=. While in the "old" versions, functionality was activated
翻译:然后激活=语义模式=。而在“旧”版本中，功能是通过以下方式激活的：
by calling one of the functions, each of them activated some specific set of features. So
翻译:通过调用其中的一个函数，每个函数都激活了一些特定的特征集。因此
in the "new" version, it's enough to do following:
翻译:在“新”版本中，只需执行以下操作：

#+BEGIN_EXAMPLE
(semantic-mode 1)
#+END_EXAMPLE

And set of enabled features will depend on what will be put into list
翻译:已启用功能集将取决于放入列表中的内容。
=semantic-default-submodes=, that can contain following symbols (it's better to populate
翻译:您的好用的人工智能助手，请将我提供的非中文文本翻译成中文。在翻译过程中，请注意保留原文的格式，并且只需输出翻译结果，不需要进行其他操作！
this list before enabling =semantic-mode=):
翻译:在启用“语义模式”之前，请先检查此列表）：

- *=global-semanticdb-minor-mode=* :: enables global support for Semanticdb;
翻译:"*=全局语义数据库次要模式=* 启用了对语义数据库的全局支持。"
- *=global-semantic-mru-bookmark-mode=* :: enables automatic bookmarking of tags that you
翻译:"*=全局语义最近使用书签模式=* 启用自动标记标签的功能，当你"
edited, so you can return to them later with the =semantic-mrub-switch-tags= command;
翻译:您可以使用“=semantic-mrub-switch-tags=”命令稍后返回它们；
- *=global-cedet-m3-minor-mode=* :: activates CEDET's context menu that is bound to right mouse
翻译:- *=global-cedet-m3-minor-mode=* 激活与右键鼠标绑定CEDET上下文菜单
button;
翻译:按钮
- *=global-semantic-highlight-func-mode=* :: activates highlighting of first line for current
翻译:- 激活当前行第一行的全局语义高亮显示功能模式 *
tag (function, class, etc.);
翻译:标签（功能、类等）。
- *=global-semantic-stickyfunc-mode=* :: activates mode when name of current tag will be shown
翻译:- *=全局语义粘性函数模式=*：激活当当前标签名称将显示的模式
in top line of buffer;
翻译:在缓冲区顶部行；
- *=global-semantic-decoration-mode=* :: activates use of separate styles for tags decoration
翻译:全局语义装饰模式激活：为标签使用单独的样式进行装饰
(depending on tag's class). These styles are defined in the =semantic-decoration-styles=
翻译:这些样式取决于标签的类。这些样式在=语义装饰样式=中定义。
list;
翻译:列表
- *=global-semantic-idle-local-symbol-highlight-mode=* :: activates highlighting of local names
翻译:全局语义闲置本地符号高亮模式::激活局部名称的高亮显示
that are the same as name of tag under cursor;
翻译:与光标下标签相同的名称
- *=global-semantic-idle-scheduler-mode=* :: activates automatic parsing of source code in the
翻译:- *=全局语义空闲调度模式=* :: 激活自动解析源代码的功能。
idle time;
翻译:空闲时间
- *=global-semantic-idle-completions-mode=* :: activates displaying of possible name
翻译:“*全局语义空闲完成模式*：激活显示可能的名称。”
completions in the idle time. Requires that =global-semantic-idle-scheduler-mode= was
翻译:在空闲时间完成。要求启用 =global-semantic-idle-scheduler-mode=。
enabled;
翻译:启用
- *=global-semantic-idle-summary-mode=* :: activates displaying of information about current
翻译:- *=全局语义空闲摘要模式=* :: 启用显示有关当前
tag in the idle time. Requires that =global-semantic-idle-scheduler-mode= was enabled.
翻译:在空闲时间中添加标签。需要启用`global-semantic-idle-scheduler-mode`。

```lisp
(tag in the idle time. Requires that =global-semantic-idle-scheduler-mode= was enabled.)
```

翻译为：

```lisp
在空闲时间中添加标签。需要启用全局语义空闲调度模式。
```

Following sub-modes are usually useful when you develop and/or debug CEDET:
翻译:以下子模式在开发和/或调试CEDET时通常很有用：

- *=global-semantic-show-unmatched-syntax-mode=* :: shows which elements weren't processed by
翻译:- 显示未处理元素
current parser's rules;
翻译:当前的解析器规则；
- *=global-semantic-show-parser-state-mode=* :: shows current parser state in the modeline;
翻译:显示当前解析器状态在模型行中；
- *=global-semantic-highlight-edits-mode=* :: shows changes in the text that weren't processed
翻译:全局语义高亮编辑模式：显示未处理文本中的更改
by incremental parser yet.
翻译:目前还没有通过增量解析器进行翻译。

This approach allows to make Semantic's customization more flexible, as user can switch on
翻译:这种方法使得语义的自定义更加灵活，因为用户可以开启
only necessary features. You can also use functions with the same names to enable/disable
翻译:只保留必要功能。您还可以使用具有相同名称的功能来启用/禁用
corresponding sub-modes for current Emacs session. And you can also enable/disable these
翻译:对应于当前Emacs会话的子模式。您还可以启用/禁用这些
modes on the per-buffer basis (usually this is done from hook): names of corresponding
翻译:在缓冲区基础上设置模式（通常通过钩子完成）：相应名称
variables you can find in description of =global-semantic-*= functions.
翻译:您可以在*global-semantic-*函数的描述中找到这些变量。

To enable more advanced functionality for name completion, etc., you can load the
翻译:为了启用更高级的功能，例如名称完成等，您可以加载
=semantic/ia= with following command:
翻译:您可以使用以下命令来获取语义信息：

#+BEGIN_EXAMPLE
(require 'semantic/ia)
#+END_EXAMPLE

After loading of this package, you'll get access to commands, described below.
翻译:在加载此包之后，您将获得以下命令的访问权限。

*** <<sec6>> System header files
:PROPERTIES:
:CUSTOM_ID: system-header-files
:END:

To normal work with system-wide libraries, Semantic should has access to system include
翻译:为了正常使用系统范围的库，Semantic 应该有访问系统包含目录的权限。
files, that contain information about functions & data types, implemented by these
翻译:文件包含有关由这些函数和数据类型实现的信息
libraries.
翻译:库。

If you're using GCC for programming in C & C++, then Semantic can automatically find
翻译:如果您使用GCC进行C和C++编程，那么Semantic可以自动找到
directory, where system include files are stored. Just load =semantic/bovine/gcc= package
翻译:目录，其中存储系统包含文件的位置。只需加载= semantic/bovine/gcc=包
with following command:
翻译:使用以下命令：

#+BEGIN_EXAMPLE
(require 'semantic/bovine/gcc)
#+END_EXAMPLE

You can also explicitly specify additional directories for searching of include files (and
翻译:您也可以明确指定用于搜索头文件（和）的附加目录。
these directories also could be different for specific modes). To add some directory to
翻译:这些目录也可能因特定模式而异)。要向其中添加一些目录（
list of system include paths, you can use the =semantic-add-system-include= command --- it
翻译:系统包含路径列表，您可以使用 ``=semantic-add-system-include=`` 命令来添加。
accepts two parameters: string with path to include files, and symbol, representing name
翻译:接受两个参数：包含文件的路径字符串和表示名称的符号
of major mode, for which this path will be used. For example, to add Boost header files
翻译:您可以使用此路径添加Boost头文件。例如：
for C++ mode, you need to add following code:
翻译:对于C++模式，您需要添加以下代码：

#+BEGIN_EXAMPLE
(semantic-add-system-include "~/exp/include/boost_1_37" 'c++-mode)
#+END_EXAMPLE

Although I want to say, that customization for Boost support is more complex, and requires
翻译:尽管我想说，为Boost支持进行自定义更为复杂，并且需要
to specify where Semantic can find files with constant's definitions, etc.
翻译:指定语义可以找到包含常量定义等文件的路径。

*** <<sec7>> Semantic's work optimization
:PROPERTIES:
:CUSTOM_ID: semantics-work-optimization
:END:

To optimize work with tags, you can use several techniques:
翻译:为了优化标签的使用，你可以使用以下几种技巧：

- limit search by using an EDE project, as described below;
翻译:使用以下描述的方法通过EDE项目限制搜索；
- explicitly specify a list of root directories for your projects, so Semantic will use
翻译:明确指定您项目的根目录列表，这样Semantic就会使用
limited number of databases with syntactic information;
翻译:有限的数据库包含语法信息；
- explicitly generate tags databases for often used directories (=/usr/include=,
翻译:明确为常用目录生成标签数据库（例如：/usr/include/）。
=/usr/local/include=, etc.). You can use commands =semanticdb-create-ebrowse-database= or
翻译:"/usr/local/include="，等等)。您可以使用命令"semanticdb-create-ebrowse-database="或
=semanticdb-create-cscope-database=;
翻译:创建语义数据库cscope数据库
- limit search by customization of the =semanticdb-find-default-throttle= variable for
翻译:限制搜索可以通过自定义 = semanticdb-find-default-throttle 变量来实现。
concrete modes --- for example, don't use information from system include files, by
翻译:具体的模式示例，例如，不要使用系统包含文件中的信息
removing =system= symbol from list of objects to search for =c-mode=:
翻译:移除列表中要搜索的对象的=system=符号=c-mode=:

#+BEGIN_EXAMPLE
(setq-mode-local c-mode semanticdb-find-default-throttle
'(project unloaded system recursive))
#+END_EXAMPLE

Semantic extracts syntactic information when Emacs is idle. You can customize the
翻译:语义提取器在Emacs空闲时提取语法信息。您可以自定义此功能的行为。
=semantic-idle-scheduler-idle-time= variable to specify idle time (in seconds), if you don't
翻译:“=语义空闲调度程序空闲时间=”变量用于指定空闲时间（以秒为单位），如果您不
want to use default value (1 second).
翻译:想要使用默认值（1秒）。

*** <<sec8>> Integration with imenu
:PROPERTIES:
:CUSTOM_ID: integration-with-imenu
:END:

The Semantic package can be integrated with the imenu package. This lead to creation of a
翻译:语义包可以与imenu包集成。这导致了创建了一个
menu with a list of functions, variables, and other tags. To enable this feature you need
翻译:菜单中列出了函数、变量和其他标签的列表。要启用此功能，您需要
to add following code into your initialization file:
翻译:将以下代码添加到您的初始化文件中：

#+BEGIN_EXAMPLE
(defun my-semantic-hook ()
(imenu-add-to-menubar "TAGS"))
(add-hook 'semantic-init-hooks 'my-semantic-hook)
#+END_EXAMPLE

*** <<sec9>> Customization of Semanticdb
:PROPERTIES:
:CUSTOM_ID: customization-of-semanticdb
:END:

To enable Semanticdb you need to add the =global-semanticdb-minor-mode= symbol into the
翻译:要启用Semanticdb，您需要在其中添加=global-semanticdb-minor-mode=符号：
=semantic-default-submodes= list. And you can specify some customization variables to
翻译:您的好用的人工智能助手，请将我提供的非中文文本翻译成中文。注意在翻译时保留原文的格式，并且只需输出翻译后的内容，不需要进行其他操作！
control behaviour of Semanticdb --- for example, where to save data, etc. These variables
翻译:控制语义数据库的行为---例如，数据保存的位置等。这些变量
could be set via =semanticdb= customization group.
翻译:可以通过 =语义数据库= 自定义组设置。

Semanticdb can also use databases generated by external utilities: =gtags= (from
翻译:语义数据库还可以使用外部工具生成的数据库：=gtags=（来自
[[http://www.gnu.org/software/global/][GNU Global]]), [[http://ctags.sourceforge.net/][exubertant ctags]], =ebrowse= & =cscope=. To activate this functionality you can
翻译:GNU 全球（[[http://www.gnu.org/software/global/][GNU Global]]），卓越的 ctags（[[http://ctags.sourceforge.net/][exubertant ctags]]），以及 ebrowse 与 cscope。要激活这些功能，你可以
use following code (please, note that these commands may fail if you have no utilities
翻译:使用以下代码（请注意，如果您的计算机上没有相应的工具，这些命令可能会失败）。
installed, or have an incorrect versions of them --- that's why they a wrapped into =when=):
翻译:安装了不正确的版本或者根本没有安装这些库——这就是为什么我们需要将它们包装进“when”语句中：

#+BEGIN_EXAMPLE
;; if you want to enable support for gnu global
(when (cedet-gnu-global-version-check t)
(semanticdb-enable-gnu-global-databases 'c-mode)
(semanticdb-enable-gnu-global-databases 'c++-mode))

;; enable ctags for some languages:
;; Unix Shell, Perl, Pascal, Tcl, Fortran, Asm
(when (cedet-ectag-version-check t)
(semantic-load-enable-primary-exuberent-ctags-support))
#+END_EXAMPLE

*** <<sec10>> EDE's customization
:PROPERTIES:
:CUSTOM_ID: edes-customization
:END:

If you plan to use projects, then you need to enable corresponding mode, implemented by
翻译:如果您打算使用项目，那么您需要启用相应的模式，该模式由实现。
the EDE package:
翻译:EDE软件包：

#+BEGIN_EXAMPLE
(global-ede-mode t)
#+END_EXAMPLE

There are several types of projects supported by EDE, and I want to describe here only
翻译:EDE支持多种项目类型，这里我只描述其中几种。
some of them.
翻译:他们中的某些人。

**** Using EDE for C & C++ projects
:PROPERTIES:
:CUSTOM_ID: using-ede-for-c-c-projects
:END:

For correct work of Semantic with С & C++ code it's recommended to use the EDE package (it
翻译:为了正确使用语义与C和C++代码，建议使用EDE包（它
allows to work with projects, etc.). For these languages, EDE package defines special
翻译:允许处理项目等）。对于这些语言，EDE包定义了特殊的
project type: =ede-cpp-root-project=, that provides additional information to Semantic, and
翻译:项目类型：=ede-cpp-root-project=，为语义提供了附加信息
this information will be used to analyze source code of your project.
翻译:此信息将被用来分析您项目的源代码。

To define a project, you need to add following code:
翻译:要定义一个项目，您需要添加以下代码：

#+BEGIN_EXAMPLE
(ede-cpp-root-project "Test"
:name "Test Project"
:file "~/work/project/CMakeLists.txt"
:include-path '("/"
"/Common"
"/Interfaces"
"/Libs"
)
:system-include-path '("~/exp/include")
:spp-table '(("isUnix" . "")
("BOOST_TEST_DYN_LINK" . "")))
#+END_EXAMPLE

For the =:file= parameter you can use any file at root directory of your project. This file
翻译:对于“=:file=”参数，您可以使用项目根目录下的任何文件。此文件
isn't parsed --- it's used only as an anchor to search all other files in project.
翻译:不被解析——它仅用作锚点来搜索项目中所有其他文件。

To search include files, Semantic uses directories from two lists, that could be specified
翻译:要搜索包含文件，语义使用两个列表中的目录，这些目录可以指定。
for project. The =:system-include-path= parameter is used to specify list of full paths
翻译:用于项目。`:system-include-path=` 参数用来指定包含路径列表
where lookup for "system" include files will be performed. Another parameter ---
翻译:在查找“系统”包含文件的地方将会执行。另一个参数---
=:include-path= specifies the list of directories, that will be used to search of "local"
翻译:":include-path=" 指定了用于搜索“本地”文件的目录列表。
include files (if names are starting with =/=, this means, that path is specified relative
翻译:包含文件（如果名称以 !=== 开头，这意味着指定了相对路径）。
to project's root directory). Instead of specifying paths as lists, you can also provide
翻译:将项目根目录)。与其指定为列表形式的路径，您还可以提供建议
function, that will perform search of include files in your project. You can read about
翻译:函数，用于在您的项目中搜索包含文件。您可以在
it in the EDE manual.
翻译:在EDE手册中有说明。

Another parameter, that could be specified in project's declaration is a list of
翻译:另一个可以在项目声明中指定的参数是一个参数列表
definitions, that will be used during code preprocessing. The =:spp-table= parameter allows
翻译:定义，将在代码预处理过程中使用。"=:spp-table="参数允许
to specify list of pairs, consisting from symbol's name & value, defined for given symbol.
翻译:指定给定符号的名称与值列表，该列表由符号的定义组成。
In our example above, we defined two symbols ---
翻译:在我们的上述例子中，我们定义了两个符号---
=isUnix= and =BOOST_TEST_DYN_LINK=, that will
翻译:“isUnix”和“BOOST_TEST_DYN_LINK”，这将
be passed to preprocessor, and this will allow to perform proper parsing of the code.
翻译:传递给预处理程序，这将允许正确解析代码。

User, if required, can redefine some variables for files inside project. This could be
翻译:用户如果需要，可以为项目中的文件重新定义一些变量。这可能包括
done by specifying the =:local-variables= parameter with value that is a list of pairs in
翻译:通过指定`:local-variables`参数为列表对值来实现。

```lisp
(done-by-specifying-the-local-variables-parameter-with-value-that-is-a-list-of-pairs-in)
```

在Lisp编程中，`:local-variables`参数通常用于宏定义中，它允许你在宏展开过程中使用局部变量。这些局部变量的值可以通过一个列表对来指定，其中每个对包含变量的名称和对应的初始值或表达式。例如：

```lisp
(defmacro my-macro ((var1 val1) (var2 val2)) ...)
```

在这个例子中，`var1`和`var2`是局部变量，它们的值由提供的列表对`(val1)`和`(val2)`确定。这样可以在宏展开时动态地设置这些变量的值。
form symbol name/value, and these values will be set for files in project.
翻译:表单符号名称/值，这些值将为项目中的文件设置。

***** Preprocessing of source code
:PROPERTIES:
:CUSTOM_ID: preprocessing-of-source-code
:END:

More information about definitions for C/C++ preprocessor you can find in documentation
翻译:有关C/C++预处理器定义的更多信息，您可以在文档中找到。
for the =semantic-lex-c-preprocessor-symbol-map= variable. You can obtain list of
翻译:对于 semantic-lex-c-preprocessor-symbol-map 变量，您可以获得列表如下：
preprocessor symbols, defined for file with source code, by using the
翻译:预处理符号，用于具有源代码的文件，通过使用
=semantic-lex-spp-describe= command. And then use these results to set =:spp-table= parameter
翻译:您给出的指令是语义词汇表描述命令。然后使用这些结果来设置=:spp-table=参数
or =semantic-lex-c-preprocessor-symbol-map= variable.
翻译:您上传的内容似乎包含了一些特殊字符或标记，这些在常规翻译中可能不会被识别。如果您能提供更多的上下文或者说明这些符号的具体含义，我会更好地帮助您进行翻译。"

Many libraries store all macro definitions in one or more include files, so you can use
翻译:许多库将所有宏定义存储在一个或多个包含文件中，因此你可以使用
these definitions as-is. To do this you need to specify these files in the
翻译:将这些定义照原样使用。要实现这一点，您需要在文件中指定这些文件。
=semantic-lex-c-preprocessor-symbol-file= variable, and when CEDET will perform analysis,
翻译:`.语义-词汇-C预处理器符号文件`变量，以及当CEDET执行分析时，
then values from these files will be used. By default, this variable has only one value
翻译:然后这些文件中的值将被使用。默认情况下，这个变量只有一个值。
--- file with definitions for C++ standard library, but you can add more data there. As
翻译:定义C++标准库的文件，但您可以在那里添加更多数据。
example, I want to show CEDET's configuration for work with Qt4:
翻译:例如，我想展示CEDET与Qt4协同工作的配置：

#+BEGIN_EXAMPLE
(setq qt4-base-dir "/usr/include/qt4")
(semantic-add-system-include qt4-base-dir 'c++-mode)
(add-to-list 'auto-mode-alist (cons qt4-base-dir 'c++-mode))
(add-to-list 'semantic-lex-c-preprocessor-symbol-file (concat qt4-base-dir "/Qt/qconfig.h"))
(add-to-list 'semantic-lex-c-preprocessor-symbol-file (concat qt4-base-dir "/Qt/qconfig-dist.h"))
(add-to-list 'semantic-lex-c-preprocessor-symbol-file (concat qt4-base-dir "/Qt/qglobal.h"))
#+END_EXAMPLE

After you'll add these lines to initialization file, you should be able to use names
翻译:在你将这些行添加到初始化文件后，你应该能够使用名称
completion for classes, defined in Qt4 library. Example you can see on the picture below:
翻译:类定义，在Qt4库中。下面的图片示例您可以看到：

[[../../../common/writings/emacs-devenv/cedet-qt-name-completion.png]]
翻译:您提供的图片似乎无法显示或未包含有效的视觉信息以供我分析。如果您有具体的内容或者问题需要讨论，请提供文本描述，我会尽力帮助您。

**** Using EDE for Java projects
:PROPERTIES:
:CUSTOM_ID: using-ede-for-java-projects
:END:

Semantic includes a parser for source code written in Java, so name completion for source
翻译:语义包括对用Java编写的源代码的解析器，因此可以完成名称。
code always worked, and the main problem was to get name completions for classes from JDK,
翻译:代码总是能正常工作，主要问题是从JDK中获取类的名称完成。
or other libraries that are used in project. For compiled code, Semanticdb can get
翻译:对于项目中使用到的其他库，Semanticdb 可以获取编译后的代码信息。
information about name by using =javap= on the list libraries in the =CLASSPATH=. To make it
翻译:关于在CLASSPATH列表库中使用javap列出名称的信息。要使其
working, you need to load the =semantic/db-javap= package:
翻译:正在工作，您需要加载= semantic/db-javap=包：

#+BEGIN_EXAMPLE
(require 'semantic/db-javap)
#+END_EXAMPLE

The path to the JDK's main library (=rt.jar= on Linux & Windows, and =classes.jar= on Mac OS
翻译:JDK的主库路径（在Linux和Windows上是rt.jar，而在Mac OS上是classes.jar）。
X) is usually detected automatically by the =cedet-java-find-jdk-core-jar= function,
翻译:"X 通常会自动被 =cedet-java-find-jdk-core-jar= 函数检测到。"
although you can change its behaviour by setting =JAVA_HOME= environment variables, or some
翻译:尽管您可以通过设置 =JAVA_HOME= 环境变量来更改其行为，或者某些
other parameters.
翻译:其他参数

If you're using Maven to build your projects, then =CLASSPATH= will be calculating
翻译:如果您使用Maven构建项目，则CLASSPATH将被计算为：
automatically by running Maven in the root of your project (also for multi-module
翻译:自动在项目根目录下运行Maven（也适用于多模块项目）。
projects). And it isn't necessary to specify project's root manually --- EDE will find it
翻译:项目和子项目). 并且没有必要手动指定项目的根目录---EDE 会自动找到它
automatically by searching for the =pom.xml= file. I need to mention that first call to
翻译:自动通过搜索=pom.xml=文件来执行。我需要指出的是，第一次调用
name completion functions could be relatively slow --- EDE should run Maven and collect
翻译:名称完成函数可能相对较慢 —— EDE 应该运行 Maven 并收集
information about libraries that are used in the project. But after first run, this
翻译:关于项目中使用的库的信息。但在第一次运行后，这个
information is cached, and next completions will be performed faster.
翻译:信息已缓存，下次完成速度会更快。

If you aren't using Maven, then you can either specify all used libraries in the
翻译:如果您不使用Maven，那么您可以在项目中指定所有使用的库，方法是将它们列在项目的`pom.xml`文件中或者直接下载到本地并引用它们的路径。
=semanticdb-javap-classpath= variable, or use the =ede-java-root-project= class, that is
翻译:`.语义db - javap类路径`变量，或者使用`= ede-java-root-project=`类。
similar to =ede-cpp-root-project= that was described above. To use this type of project,
翻译:类似于上述描述的ede-cpp-root-project类型的项目。要使用此类项目，
you need to add something like to you initialization file:
翻译:您需要在初始化文件中添加类似以下内容：

#+BEGIN_EXAMPLE
(ede-java-root-project "TestProject"
:file "~/work/TestProject/build.xml"
:srcroot '("src" "test")
:localclasspath '("/relative/path.jar")
:classpath '("/absolute/path.jar"))
#+END_EXAMPLE

As for C/C++, you need to specify name of the project, point to existing file at the
翻译:至于C/C++，您需要指定项目名称，并指向现有的文件。
project's root directory, and some additional options:
翻译:项目的根目录以及一些额外的选项：

- *=:srcroot=* :: list of directories with source code. Directory names are specified
翻译:源代码目录列表。目录名称是指定的。
relatively of project's root (in this example this is =src= & =test=);
翻译:相对于项目的根目录（在这个例子中这是 src 和 test）；
- *=:classpath=* :: list of absolute file names for used libraries;
翻译:类路径上使用的库的绝对文件名列表
- *=:localclasspath=* :: list of file names for used libraries, relative to project's root.
翻译:*=:本地类路径=* 使用的库文件名列表，相对于项目的根目录。

When Semantic finds such project, it can use provided information for name completion.
翻译:当语义找到这样的项目时，它可以利用提供的信息来完成名称填写。

** <<sec11>> Work with Semantic
:PROPERTIES:
:CUSTOM_ID: work-with-semantic
:END:

From user's point of view, Semantic provides several major features --- names completions,
翻译:从用户的角度来看，语义提供了几个主要功能——名称补全、
retrieving information about tags (variables, functions, etc.), and navigation in source
翻译:检索有关标记（变量、函数等）的信息以及源代码导航
code. Some of these features are implemented by =semantic/ia= package, while other are
翻译:代码。其中一些功能是通过 =语义/IA= 包实现的，而其他功能则
implemented by Senator, and Semantic's kernel.
翻译:由参议员实施，语义内核。

Some of commands have no standard key bindings, so it's better to select key bindings,
翻译:一些命令没有标准的热键绑定，因此最好选择关键绑定。
that are comfortable to you, and bind commands to them, like this (only for standalone
翻译:您可以选择舒适的操作方式，并为它们分配命令，如下所示（仅适用于独立使用）。
CEDET):
翻译:您似乎忘记上传需要翻译的非中文文本文件。请上传文件后，我将为您提供相应的中文翻译。谢谢！

#+BEGIN_EXAMPLE
(defun my-cedet-hook ()
(local-set-key [(control return)] 'semantic-ia-complete-symbol)
(local-set-key "C-c?" 'semantic-ia-complete-symbol-menu)
(local-set-key "C-c>" 'semantic-complete-analyze-inline)
(local-set-key "C-cp" 'semantic-analyze-proto-impl-toggle))
(add-hook 'c-mode-common-hook 'my-cedet-hook)
#+END_EXAMPLE

I want to mention, that Semantic's development is pretty active, and if something doesn't
翻译:我想提一下，语义的发展相当活跃，如果有什么不满足您的地方
work, or works wrong, then please, send examples of code to the [[https://lists.sourceforge.net/lists/listinfo/cedet-devel][cedet-devel mailing list]]
翻译:如果工作或出错，请将代码示例发送到[[https://lists.sourceforge.net/lists/listinfo/cedet-devel][cedet-devel邮件列表]]。
--- the CEDET's authors usually answers pretty fast.
翻译:CEDET 的作者通常回复得很快。

*** <<sec12>> Names completion
:PROPERTIES:
:CUSTOM_ID: names-completion
:END:

Text completion for names of functions, variables & classes is pretty often used feature
翻译:函数、变量和类名称的文字补全是一个非常常用的功能。
when you work with source code. There are two packages inside Semantic that implement
翻译:当你处理源代码时，Semantic中有两个包实现了
this functionality ---
翻译:这个功能是
=semantic/ia= and Senator (it doesn't included into GNU Emacs). You
翻译:您提到的“semantic/ia”和“Senator”似乎是指某种软件或编程环境中的特定组件或功能。"Semantic"通常与语义分析相关，而"IA"可能是某个项目、库或者功能的缩写。"Senator"，如果指的是GNU Emacs中的一个功能或插件，那么它可能是一个用于增强Emacs编辑器功能的包或模块。

然而，由于这些术语在提供的上下文中没有进一步的描述，我无法给出更具体的翻译或解释。如果您能提供更多的背景信息或详细说明，我会更好地帮助您理解这些词汇的含义。
need to take into account, that in the new versions it's recommended to use Semantic only
翻译:需要考虑的是，在新版本中建议仅使用语义。
as source of information, and perform names completion using other packages, such as
翻译:作为信息来源，并使用其他包来完成命名完成，例如
=auto-complete=. You see example below.
翻译:您看到一个例子下面。

Commands, implemented by =semantic/ia= use the =semantic-analyze-possible-completions=
翻译:命令，由 =语义/ia= 实现，使用 =语义分析可能完成项=
function to create a list of all possible names completion, and this function takes into
翻译:创建一个包含所有可能姓名完成的列表，这个函数接受
account many parameters (plus it can be augmented by user's code to provide more precise
翻译:账户许多参数（并且可以通过用户的代码进行增强，以提供更精确的结果）。
list of names). At the same time, commands from Senator package use simpler methods to
翻译:（名字列表）。同时，来自参议员包的命令使用更简单的方法来
create a list of all possibles completions (usually they use information only about
翻译:创建一个所有可能完成的列表（通常只使用关于的信息）。
definitions in the current file), and this sometime lead to wrong names completion.
翻译:在当前文件中的定义有时会导致错误的名称完成。

If you execute the =semantic-ia-complete-symbol= command when you're typing code, then this
翻译:如果您在编写代码时执行 =语义-ia完整符号= 命令，那么这将
will lead to completion of corresponding name --- name of function, variable, or class
翻译:这将导致完成相应的名称---函数、变量或类的名称
member, depending on the current context. If there are several possible variants, then
翻译:成员，取决于当前的上下文。如果有几个可能的变体，那么
this name will be completed to most common part, and if you'll call this command second
翻译:这个名称将被完善为最常见的一部分，如果您第二次调用此命令
time, then buffer with all possible completions will be shown. User can also use the
翻译:时间之后，将会显示所有可能的完成项缓冲。用户还可以使用
=semantic-ia-complete-symbol-menu= command --- it also performs analysis of current context,
翻译:"=语义智能完全符号菜单= 命令---它还执行当前上下文的分析。"
but will display list of possible completions as a graphical menu, from which the required
翻译:但是将以图形菜单的形式显示可能的完成列表，从中可以选择所需的
name should be selected. Besides this, there is =semantic-ia-complete-tip= command, that
翻译:名字应该被选择。除此之外，还有 =语义完整提示= 命令，
displays list of possible completions as tooltip.
翻译:显示可能的完成列表作为工具提示。

As was mentioned above, the Senator package, also provides commands for names completion.
翻译:如上所述，Senator软件包还提供了命令用于完成名称。
It work very fast, but with less precision (as they use few parameters during computation
翻译:它运行非常快，但精度较低（因为它们在计算过程中使用了较少的参数）。
of variants for completions). The =senator-complete-symbol= command (=C-c , TAB=) completes
翻译:您可以使用以下命令来完成变体：="参议员完成符号="命令（="C-c ，TAB="）。
name for current tag, and insert first found completion as result. If it inserts wrong
翻译:当前标签的名称，并将找到的第一个完成项作为结果插入。如果它插入了错误的
name, then you can insert second name from completion list by repeating this command, and
翻译:名字，然后你可以通过重复这个命令来从完成列表中插入第二个名字。
so on. If there are a lot of the possible variants, or you want to see full list of
翻译:因此，如果可能变体很多，或者您想查看完整的列表
functions and variables for some class, then it's better to use the
翻译:对于某个类的函数和变量，最好使用
=senator-completion-menu-popup= command (=C-c , SPC=) --- it displays list of all possible
翻译:"参议员完成菜单弹出命令（= C-c ，空格 =）--- 它显示所有可能的列表"。
completions as a graphical menu.
翻译:您可以使用图形菜单来完成这些任务。

Besides these commands, user can use special mode (only for some languages) ---
翻译:除了这些命令之外，用户可以使用特殊模式（仅适用于某些语言）---
=semantic-idle-completions-mode= (or enable it globally by adding
翻译:您可以使用以下命令来启用语义空闲补全模式：

```plaintext
set semantic-idle-completions-mode=1
```

或者，如果您想全局启用此功能，可以在您的配置文件中添加以下行：

```plaintext
semantic-idle-completions-mode = 1
```
=global-semantic-idle-completions-mode= symbol into =semantic-default-submodes= list) --- in
翻译:将“global-semantic-idle-completions-mode”符号加入到“semantic-default-submodes”列表中）--- 在
this mode names completions are shown automatically if user stops its work for a some time
翻译:如果用户暂停工作一段时间，会自动显示这种模式的完成情况。
(idle time). By default, only first possible completion is shown, and user can use the
翻译:空闲时间。默认情况下只显示第一个可能的完成项，用户可以使用
=TAB= key to navigate through list of possible completions.
翻译:按TAB键浏览可能完成项列表。

For C-like languages, user can use the =semantic-complete-self-insert= command, bound to the
翻译:对于C类语言，用户可以使用`=semantic-complete-self-insert=`命令，将其绑定到
=.= and/or =>= keys, as this shown below:
翻译:“=”、“.”、“/”和“|”键，如下所示：

#+BEGIN_EXAMPLE
(defun my-c-mode-cedet-hook ()
(local-set-key "." 'semantic-complete-self-insert)
(local-set-key ">" 'semantic-complete-self-insert))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
#+END_EXAMPLE

Evaluation of this code will lead to execution of the =semantic-complete-self-insert=
翻译:评估此代码会导致执行=语义完整自插入=
command when user will press =.= or =>= after variables, that are instances of some data
翻译:当用户在变量之后按下 `.=.` 或 `=>=` 时，这些变量是某些数据实例
structure, and displaying a list of possible completions for given class or structure.
翻译:结构，并显示给定类或结构的可能完成列表。

If you're programming in C & C++, then you can also get name completions using information
翻译:如果您在用C和C++编程，那么您也可以使用信息获取名称完成。
from Clang (versions 2.9 & above). To do this, you need to load the =semantic/bovine/clang=
翻译:从Clang（版本2.9及更高）中。要做到这一点，您需要加载“语义/牛/clang”
package, and call the =semantic-clang-activate= function. After that, Semantic will start
翻译:安装包后，调用 = semantic-clang-activate = 函数。之后，Semantic 将启动
to call Clang, and use its code analyzer to calculate list of possible names completions.
翻译:调用Clang，并使用其代码分析器来计算可能的名称完成列表。

**** Names completion with auto-complete package
:PROPERTIES:
:CUSTOM_ID: names-completion-with-auto-complete-package
:END:

The [[http://cx4a.org/software/auto-complete/][auto-complete]] package was developed to automatically complete text using information
翻译:自动完成包（[[http://cx4a.org/software/auto-complete/][自动完成]】）是为了使用信息自动补全文本而开发的。
from different sources: predefined dictionaries, text from current buffer, external
翻译:从不同的来源：预定义词典、当前缓冲区中的文本、外部
programs (GNU Global, etags, ...), etc. Semantic could be also used as source of
翻译:程序（GNU Global、etags等），等等。语义分析也可以作为源代码的一部分。
information.
翻译:您的好用的人工智能助手，我会尽力帮助您。

This package is available in the GNU Emacs's package repository (execute =M-x package-list-packages= to get list of available packages), but you can also install it via
翻译:这个包可以在GNU Emacs的软件包仓库中找到（执行=M-x package-list-packages=以获取可用软件包列表），但您也可以通过以下方式安装它：
=el-get= or manually. Installation & customization are described in [[http://cx4a.org/software/auto-complete/manual.html][user's manual]], so I
翻译:“el-get”或手动安装。安装与自定义在[[http://cx4a.org/software/auto-complete/manual.html][用户手册]]中有描述，所以我就不多说了
won't cover these parts.
翻译:不会涵盖这些部分。

To use information from Semantic for names completion, you need to add =ac-source-semantic=
翻译:要使用语义信息完成名称填写，您需要添加 =ac-source-semantic=
or =ac-source-semantic-raw= into =ac-sources= list (this list allows you to control which data
翻译:您可以将此列表用作控制哪些数据
sources will be used for current buffer, so you can change it as you want).
翻译:源文件将被用于当前缓冲区，因此您可以随意更改它)。
=ac-source-semantic-raw= differs from =ac-source-semantic= that for it the filtering of
翻译:“ac-source-semantic-raw”与“ac-source-semantic”不同，因为对于前者，需要进行筛选。
information isn't performed.
翻译:信息没有被执行。

So your setup can be performed following way --- instead of bounding keys for
翻译:您的设置可以按照以下方式进行---而不是为键绑定键。
=semantic-ia-complete-symbol-menu=, =semantic-ia-complete-symbol= & other functions, you can
翻译:“语义智能完成符号菜单”、“语义智能完成符号”以及其他功能，您可以使用。
simply add new names completion sources, and after that use =auto-complete= bindings to get
翻译:简单添加新的名称完成来源，然后使用 =自动完成= 绑定来获取。
names completion:
翻译:名字补全：

#+BEGIN_EXAMPLE
(defun my-c-mode-cedet-hook ()
(add-to-list 'ac-sources 'ac-source-gtags)
(add-to-list 'ac-sources 'ac-source-semantic))
(add-hook 'c-mode-common-hook 'my-c-mode-cedet-hook)
#+END_EXAMPLE

*** <<sec13>> Getting information about tags
:PROPERTIES:
:CUSTOM_ID: getting-information-about-tags
:END:

The =semantic/ia= package provides several commands, that allow to get information about
翻译:"语义IA包提供了几个命令，允许获取有关"
classes, functions & variables (including documentation from Doxygen-style comments).
翻译:类、函数与变量（包括Doxygen风格注释的文档）。
Currently following commands are implemented:
翻译:目前实现了以下命令：

- *=semantic-ia-show-doc=* :: shows documentation for function or variable, whose names is
翻译:- *=semantic-ia-show-doc=* :: 显示函数或变量的文档，其名称是
under point. Documentation is shown in separate buffer. For variables this command
翻译:在要点下。文档显示在单独的缓冲区中。对于变量，该命令
shows their declaration, including type of variable, and documentation string (if it's
翻译:显示他们的声明，包括变量类型和文档字符串（如果有的话）。
available). For functions, prototype of the function is shown, including documentation
翻译:对于函数，显示函数原型，包括文档说明（available）。
for arguments and returning value (if comments are available);
翻译:对于参数和返回值（如果有注释的话）。
- *=semantic-ia-show-summary=* :: shows documentation for name under point, but information is
翻译:显示指定点的名称下的文档，但信息不完整。
shown in the mini-buffer, so user will see only variable's declaration or function's
翻译:显示在迷你缓冲区中，所以用户只能看到变量的声明或函数的定义。
prototype;
翻译:原型
- *=semantic-ia-describe-class=* :: asks user for a name of the class, and return list of
翻译:- 智能语义描述类 *:: 询问用户类的名称，并返回该类的列表
functions & variables, defined in given class, plus all its parent classes.
翻译:函数和变量，定义在给定的类中以及其所有父类中。

*** <<sec14>> Navigation in source code
:PROPERTIES:
:CUSTOM_ID: navigation-in-source-code
:END:

One of the most useful commands for navigation in source code is the =semantic-ia-fast-jump=
翻译:在源代码导航中最有用的命令之一是 =语义智能快速跳转=
command, that allows to jump to declaration of variable or function, whose name is under
翻译:命令，允许跳转到名称位于光标下的变量或函数的声明处
point. You can return back by using the =semantic-mrub-switch-tag= command (=C-x B=), that is
翻译:你可以使用=semantic-mrub-switch-tag=命令（=C-x B=）返回上一界面。
available when you enable the =semantic-mru-bookmark-mode= minor mode.
翻译:当您启用`semantic-mru-bookmark-mode`小模式时，它就会可用。

Semantic also provides two additional commands for jumping to function or variable:
翻译:语义还提供了两个附加命令，用于跳转到函数或变量：
defined in current file ---
翻译:在当前文件中定义
=semantic-complete-jump-local= (=C-c , j=), or defined in current
翻译:`.语义完整跳转本地（=C-c ，j=），或在当前定义中`
project ---
翻译:项目
=semantic-complete-jump= (=C-c , J=). Both commands allow to enter name of
翻译:`. =语义完整跳转=（=C-c ，J=）这两个命令都允许输入名称以
function or variable (including local variables inside functions) and jump to given
翻译:函数或变量（包括函数内部的局部变量）并跳转到给定
definition (you can use name completion when entering the name).
翻译:定义（输入名称时可使用名称完成功能）。

The main difference between =semantic-ia-fast-jump= & =semantic-complete-jump= commands is
翻译:=semantic-ia-fast-jump= 和 =semantic-complete-jump= 命令的主要区别是：

1. **跳转范围**：
   - `semantic-ia-fast-jump`：在当前缓冲区中快速跳转到下一个标记或符号。
   - `semantic-complete-jump`：可以在整个项目中跨多个文件跳转到定义的位置。

2. **功能**：
   - `semantic-ia-fast-jump`：主要用于在当前文件内快速定位到下一个相关位置（如函数、变量等）。
   - `semantic-complete-jump`：用于在整个项目范围内查找并跳转到某个符号的定义位置。

3. **使用场景**：
   - `semantic-ia-fast-jump`：适合于需要快速浏览当前文件的上下文和结构。
   - `semantic-complete-jump`：适合于需要跨文件查找符号定义的情况，例如调试或重构代码时。

4. **性能**：
   - `semantic-ia-fast-jump`：通常更快，因为它只关注当前缓冲区的信息。
   - `semantic-complete-jump`：可能较慢，因为需要在整个项目中搜索符号定义。

5. **依赖性**：
   - `semantic-ia-fast-jump`：依赖于当前的语义分析结果，因此需要先进行一次完整的语义分析。
   - `semantic-complete-jump`：同样依赖于语义分析结果，但可能会对整个项目的语义进行分析以找到符号的定义。

总结来说，`semantic-ia-fast-jump` 适用于快速定位当前文件内的相关元素，而 `semantic-complete-jump` 则更适合于跨文件查找符号定义。两者都依赖于语义分析工具来提供准确的跳转信息。
that the first properly handles complex names, like =this::that->foo()=, while the second,
翻译:第一个正确处理了复杂名称，比如 `this::that->foo()`，而第二个，
can find only simple names, like =foo=.
翻译:只能找到简单名称，比如=foo=。

The =semantic-analyze-proto-impl-toggle= command allows to switch between function's
翻译:"命令允许在函数的功能之间切换。"
declaration and its implementation in languages, that allow to have separate declaration
翻译:声明及其在允许有单独声明的语言中的实现
and implementation of functions. Another useful command is
翻译:函数的定义和实现。另一个有用的命令是
=semantic-decoration-include-visit=, that allows to jump to include file, whose name is
翻译:允许跳转到以"name"为名的包含文件
under cursor.
翻译:光标下方

Senator provides several commands for navigation in source code. This is =senator-next-tag=
翻译:参议员提供了几个在源代码中导航的命令。这是 =参议员下一个标签=
(=C-c , n=) and =senator-previous-tag= (=C-c , p=) commands, that move cursor to next or
翻译:(`=C-c , n=`) 和 `=` senator-previous-tag`= (`=C-c , p=`) 命令，用于将光标移动到下一个或上一个标签。
previous tag. There is also the =senator-go-to-up-reference= command (=C-c , u=), that moves
翻译:之前的标签。还有=senator-go-to-up-reference=命令（=C-c ，u=），用于移动
cursor to the "parent" tag (for example, for class member function, "parent" tag is class
翻译:将光标移到“父”标签（例如，对于类成员函数，“父”标签是类）。
declaration).
翻译:声明)。

*** <<sec15>> Search for places where function is called
:PROPERTIES:
:CUSTOM_ID: search-for-places-where-function-is-called
:END:

Semantic also has very useful command ---
翻译:语义也具有非常实用的命令 ---
=semantic-symref=, that allows to find places,
翻译:这个功能允许您查找地点
where symbol (whose name is under point) is used in your project. If you want to find use
翻译:在您的项目中使用了哪个符号（其名称以点开头）。如果您想找到它的用途
of symbol with arbitrary name, then you can use the =semantic-symref-symbol= command, that
翻译:您可以使用任意名称的符号，然后使用`=semantic-symref-symbol=`命令
allows to enter name of the symbol to lookup.
翻译:允许输入要查询的符号名称。

If references to given name weren't found in corresponding database (GNU Global, etc.),
翻译:如果在相应的数据库（GNU Global 等）中没有找到给定名字的引用，
then these commands will try to find them using the =find-grep= command. As result of execution
翻译:这些命令将通过使用“find-grep”命令来尝试查找它们。作为执行结果
of these commands, a new buffer with results will be created, and user can jump to found
翻译:这些命令中，将会创建一个新的缓冲区以显示结果，用户可以跳转到找到的内容。
places:
翻译:地点：

[[../../../common/writings/emacs-devenv/cedet-symref.png]]
翻译:[[../../../common/writings/emacs-devenv/cedet-symref.png]]

您提供的图片链接似乎指向了某个与Emacs和CEDET SymRef相关的页面或文档。由于我无法直接访问外部链接或查看图片内容，因此不能为您提供该图片的直接描述。

如果您能告诉我关于此图片的具体问题或者需要翻译的内容（例如图片中的某些文本），我会很乐意帮助您进行翻译。

*** <<sec16>> Source code folding
:PROPERTIES:
:CUSTOM_ID: source-code-folding
:END:

As Semantic has almost complete syntactic information about source code, this allows it to
翻译:语义几乎完全掌握了源代码的语法信息，这使得它能够
implement folding functionality, similar to functionality implemented by hideshow package.
翻译:实现折叠功能，类似于由hideshow包实现的函数
To enable this feature, you need to perform customization of the
翻译:要启用此功能，您需要对进行自定义设置。
=global-semantic-tag-folding-mode= variable. When you'll enable it, this will lead to
翻译:全局语义标记折叠模式变量。当你启用它时，这将导致
displaying of small triangles at the fringle field, and you will able to fold and unfold
翻译:在穗带区域显示小三角形，并且您能够折叠和展开
pieces of code by clicking on them (this should work not only for source code, but also
翻译:点击代码片段（这不仅适用于源代码，也适用于
for comments, and other objects).
翻译:对于评论和其他对象）。

Senator also has similar functionality, but it's usually used for top-level objects ---
翻译:参议员也具有相似的功能，但通常用于顶级对象---
functions, class declarations, etc. You can fold piece of code with the =senator-fold-tag=
翻译:函数、类声明等。您可以使用=senator-fold-tag=折叠一段代码。
command (=C-c , -=), and unfold it with =senator-unfold-tag= (=C-c , +=).
翻译:命令（=C-c ，-=），展开使用=senator-unfold-tag=（=C-c ，+=）。

*** <<sec17>> More Senator's commands
:PROPERTIES:
:CUSTOM_ID: more-senators-commands
:END:

The Senator package provides number of commands for work with tags, that allow user to cut
翻译:参议院包提供了许多与标签一起工作的命令，使用户能够剪切
or copy tag, and insert it in another place. To cut current tag (usually this is
翻译:您可以使用以下代码片段来复制当前标签（通常是）并将其粘贴到另一个位置。要剪切当前标记（通常是这样），请按照以下步骤操作：
declaration of some function, or its implementation) the =senator-kill-tag= command (=C-c , C-w=) should be used. You can insert complete tag with standard key binding =C-y=, while the
翻译:声明某些功能（或其实现）时，应使用=senator-kill-tag=命令（=C-c ，C-w=）。您可以使用标准键绑定=C-y=插入完整的标签。
=senator-yank-tag= command (=C-c , C-y=) inserts only tag declaration, without body. Another
翻译:"参议员yank标签命令（=C-c , C-y=）仅插入标签声明，没有主体。"
useful command is =senator-copy-tag= (=C-c , M-w=), that copies current tag --- this is very
翻译:有用的命令是=senator-copy-tag=（=C-c ，M-w=），该命令复制当前标签---这非常
handy when, for example, you want to insert declaration of function into include file.
翻译:在例如您想将函数声明插入到头文件中的情况下很有用。

Senator allows to change behaviour of standard search commands (=re-search-forward=,
翻译:参议员允许更改标准搜索命令的行为（=重新搜索前向=，
=isearch-forward= and other), when you work with source code, such way, so they will perform
翻译:当您处理源代码时，使用“isearch-forward”和其他方式工作，这样它们就会执行
search only in the given tags. To enable this mode you can use the
翻译:仅在给定标签中搜索。要启用此模式，您可以使用
=senator-isearch-toggle-semantic-mode= command(=C-c , i=), and with the
翻译:=C-c , i= 命令（=senator-isearch-toggle-semantic-mode=）和与
=senator-search-set-tag-class-filter= command (=C-c , f=) you can limit search to given tag
翻译:命令“=senator-search-set-tag-class-filter=”（快捷键为“=C-c , f=”）可以让你限定搜索到指定的标签。
types ---
翻译:类型
=function= for functions, =variable= for variables, etc.
翻译:对于函数，使用 =function=；对于变量，使用 =variable= 等。

You can also perform tags search without enabling this mode --- you just need to call
翻译:你也可以在不启用这种模式的情况下进行标签搜索——你只需要调用
corresponding command: =senator-search-forward= or =senator-search-backward=.
翻译:对应命令：=参议员搜索前=或=参议员搜索后=。

** <<sec18>> Work with Srecode
:PROPERTIES:
:CUSTOM_ID: work-with-srecode
:END:

The Srecode package allows user to define code templates, but it differs from other
翻译:Srecode包允许用户定义代码模板，但它与其他包不同。
packages, that provide insertion of templates, because list of available templates can
翻译:包，提供了模板插入功能，因为可用的模板列表
vary depending on the current context. For example, insertion of =get/set= functions should
翻译:取决于当前的上下文。例如，插入 =get/set= 函数应该
happen only when you inside class declaration. Or, insertion of function's declaration,
翻译:只在类声明中发生。或者，插入函数声明时会发生。
may happen only outside of other function.
翻译:可能仅在函数外部发生。

The main command, that is used to insert templates, is the =srecode-insert=, that is bound
翻译:主命令，用于插入模板的是=srecode-insert=，它被绑定
to the =C-c / /= keys. This command will ask user for template's name (you can enter it
翻译:到 C-c / = 键。这条命令将会提示用户输入模板的名字（您可以输入它）。
using name completion). List of available templates will vary, depending on the current
翻译:使用名称补全功能)。可用的模板列表将根据当前
context. If you want to insert the same template once again, then you can use the
翻译:如果您想再次插入相同的模板，那么您可以使用
=srecode-insert-again= command (=C-c / .=).
翻译:您可以使用“Ctrl + C”后跟斜杠（/）来再次插入“srecode-insert-again”命令。

Templates that are defined by user, can also use they own key bindings. They can use
翻译:由用户定义的模板也可以使用他们自己的快捷键绑定。他们可以使用
lower-case symbols from range =C-c / [a..z]=, and user can specify in template's definition,
翻译:小写字母范围从=C-c / [a..z]=, 用户可以在模板定义中指定。
which key will be assigned to it. For example, for C++ you can use the =C-c / c= key
翻译:为它分配哪个键。例如，对于C++，您可以使用=C-c / c=键。
binding to insert class declaration.
翻译:绑定到插入类声明。

Key bindings, that use upper-case symbols, are reserved for templates & commands defined
翻译:键绑定使用大写符号的是为模板和命令保留的
in Srecode. For example, =C-c / G= (=srecode-insert-getset=) inserts pair of functions
翻译:在Srecode中，例如，`=`c-c / G`= (`srecode-insert-getset=`) 插入一对函数。
=get/set= for some class member variable, while =C-c / E= (=srecode-edit=) is used to edit
翻译:对于某些类成员变量的get/set操作，可以使用=C-c / E=（=srecode-edit=）进行编辑
templates. List of these commands isn't constant, so you need to look into documentation
翻译:模板命令列表不是固定的，因此您需要查阅文档。
to find actual list of commands.
翻译:要查找实际的命令列表。

Besides templates, supplied with CEDET, user can define their own templates, and store
翻译:除了CEDET提供的模板之外，用户还可以定义自己的模板，并将它们存储起来。
them in the =~/.srecode= directory, where CEDET will find them automatically. You can read
翻译:您可以将这些文件放在 `~/.emacs.d/elpa` 目录下的 `srecode` 子目录中，这样CEDET就会自动找到它们了。您可以阅读
about template's creation in the Srecode manual, that comes together with other
翻译:关于Srecode手册中模板创建的内容，它与其它
documentation in the CEDET distribution.
翻译:CEDET发行包中的文档。

** <<sec19>> Additional packages
:PROPERTIES:
:CUSTOM_ID: additional-packages
:END:

Together with CEDET the number of additional packages is supplied. Some of them are
翻译:与CEDET一起提供的附加软件包数量。其中一些是
located in the =contrib= subdirectory, that you need to add to library search list.
翻译:位于 contrib 子目录中，您需要将其添加到库搜索列表中。

*** <<sec20>> The eassist package
:PROPERTIES:
:CUSTOM_ID: the-eassist-package
:END:

The eassist package provides several commands, that use information obtained from
翻译:eassist 包提供了几个命令，这些命令使用从信息中获取的信息
Semantic. By default, these commands have no predefined key bindings, so you need to
翻译:语义。默认情况下，这些命令没有预定义的热键绑定，因此您需要自行设置。
select them yourself.
翻译:自行选择它们。

The =eassist-list-methods= command, executed in the file with source code, will show you a
翻译:". 执行文件中的源代码的=eassist-list-methods=命令将显示你一个
list of functions, defined in current buffer, and will allow you to perform quick jump to
翻译:当前缓冲区中定义的函数列表，将允许您快速跳转到
selected function.
翻译:选择功能。

If you develop code in C and/or C++ languages, then the =eassist-switch-h-cpp= command,
翻译:如果您使用C和/或C++语言编写代码，则可以使用=eassist-switch-h-cpp=命令
could be very useful to you --- it jumps between header file and file, that contains
翻译:可能会对你非常有帮助——它会在头文件和包含该文件的文件之间跳转。
implementation (if they have same names, but different extensions).
翻译:实现（如果它们具有相同的名称，但扩展名不同）。

Last change: 12.03.2014 07:58
翻译:最后修改：2014年3月12日 07:58
