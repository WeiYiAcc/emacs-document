#+TITLE: Emacs-Lisp-coding-thoughts
#+URL: http://www.nongnu.org/emacs-tiny-tools/elisp-coding/index-body.html
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-07-16 六 12:34]
#+OPTIONS: ^:{}
--------------------------------------------------------------------------------------------------------------

* 1.0 Document id

Copyright © 1995-2007 Jari Aalto
翻译:版权所有©1995-2007 贾里·阿尔托

License: This material may be distributed only subject to the terms and conditions set forth in GNU General Public License v2 or later; or, at your option, distributed under the terms of GNU Free Documentation License version 1.2 or later (GNU FDL).
翻译:许可证：本材料仅可在符合GNU通用公共许可证v2或更高版本条款和条件的情形下分发；或者根据您的选择，依据GNU自由文档许可协议第1.2版或更高版本（GNU FDL）进行分发。

This document contains Unix Emacs Lisp programming information. It addresses the coding style of Emacs lisp and also presents notes about Emacs lisp byte compiler. Emacs Lisp code profiling is also examined and some profiling result presented.
翻译:此文档包含了Unix Emacs Lisp编程信息。它涉及Emacs Lisp的编码风格，并也介绍了关于Emacs Lisp字节编译器的注释。还检查了Emacs Lisp代码的性能分析，并且展示了某些性能分析结果。

** 1.1 What this document is not

This document won't introduce you to lisp, you must have basic knowledge about lisp programming beforehand: functions, local, global variables and various forms used in lisp. Mainly, this contains no ready solutions, functions, that you could use. There may be case studies though.
翻译:本文档不会向您介绍LISP编程，您在此之前必须具备关于LISP编程的基本知识：函数、局部变量和全局变量以及LISP中使用的各种形式。主要来说，它不包含您可以直接使用的现成解决方案或函数。不过，其中可能包括一些案例研究。

** 1.2 What is this document?

This document contains some guidelines that were found handy. There have also appeared also very good articles in the Usenet Emacs newsgroups and many good articles may have passed by, but hope you find those included interesting. It is recommended that you first read some elementary lisp reference before reading this paper.
翻译:此文档包含了一些被认为有用的指南。在Usenet Emacs新闻组中也出现了很多非常好的文章，还有很多好的文章可能已经错过了，但希望您觉得这些包含的文章有趣。建议您在阅读本文之前先阅读一些基础的Lisp参考资料。

Read this document as recommendations, not as strict rules. Adapt ideas that seem reasonable to you, and discard the others you feel, don't serve your needs.
翻译:阅读此文件作为建议，而不是严格规定。采用对你来说似乎合理的想法，并丢弃其他你认为不符合你需要的内容。

The Elp (lisp profiling tool) results in the page are mainly for curious reader, when he needs some reference how to write tight loops, time critical functions. But normally there is not much need for optimization in Emacs: you run into performance problems very rarely. Be very skeptical when reading the results and do not put your blind trust on them.
翻译:ELP（Lisp性能分析工具）页面上的结果主要是为好奇的读者准备的，当他需要一些参考如何编写紧密循环、时间关键函数时。但在正常情况下，对于Emacs来说并没有太多优化的需求：你很少会遇到性能问题。在阅读这些结果时要非常谨慎，不要盲目相信它们。

Used Abbreviations
翻译:您可以使用缩写词来提高沟通效率,但请注意确保对方理解这些缩写词的含义。以下是一些常见的英文缩写词及其含义:

- ASAP: As Soon As Possible（尽快）
- ATM: At The Moment（此刻）
- BTW: By The Way（顺便说一下）
- FYI: For Your Information（仅供参考）
- IMHO: In My Humble Opinion（依我拙见）
- LOL: Laughing Out Loud（大声笑）
- TTYL: Talk To You Later（稍后聊）
- WTH: What The Hell（天哪）

[jari] Jari Aalto
翻译:抱歉,我目前还没有修改图片的能力。如果您有其他请求,欢迎随时向我提问。谢谢!
[kai] Kai Grossjohann
翻译:凯·格罗斯乔恩
[vladimir] Vladimir Alexiev
翻译:弗拉基米尔·亚历山德罗维奇
--------------------------------------------------------------------------------------------------------------

* 2.0 The basic coding suggestions

** 2.1 Major rule1 – comment as much as possible

Someone else reading your code will appreciate any extra explanation that you may have written. Someday the code may also be maintained by someone else than you, so bear in mind that the would-be-maintainer can take over your code, when you no longer are around.
翻译:阅读您代码的人会感激您可能写的任何额外解释。总有一天，维护您的代码的人可能不再是您了，所以请记住，当您不再在场时，潜在的维护人员可以接管您的代码。

** 2.2 Major rule2 – maintenance comes first

Maintenance and readability comes first, never write tight code. Functions are easier to read if they are "airy" instead. Your code doesn't run any faster, no matter how much you shrink it. Some people like to delete all white spaces from their functions so that the code lines are stuck together; but that is not necessarily the best practice.
翻译:维护和可读性是最重要的，永远不要编写紧凑的代码。如果函数“轻盈”，那么它们更容易被阅读。无论您如何压缩，代码运行的速度都不会更快。有些人喜欢删除函数中的所有空白字符，以便让代码行粘在一起；但这未必是最好的做法。

Organize parts that belong together, into groups and add dashes or anything to make it visible that something important is happening (function or condition)
翻译:将属于一起的部分组织成组，并添加破折号或任何其他标记，以使其明显看出正在发生某些重要的事情（功能或条件）。

** 2.3 Major rule3 – don't spare variables

Don't be afraid of using many variables. Especially in functions, that need local variables. A variable can "self document" the code if named properly. Use XEmacs byte compiler to check is you have defined variables that you haven't actually used, so that the byte compilation results are clean. (Note: The XEmacs byte compiler can better catch programming errors than Emacs byte compiler.)
翻译:不要害怕使用许多变量。特别是在需要局部变量的函数中。如果给变量起名恰当，它就能“自我说明”代码。使用XEmacs字节编译器来检查你是否定义了实际上没有使用的变量，从而使字节编译结果更干净。（注：XEmacs字节编译器比Emacs字节编译器更能捕捉编程错误。）

In most cases the possible minor performance penalty of using many variables doesn't matter. See the profiling results later in this document.
翻译:在大多数情况下，使用多个变量的可能的小性能惩罚并不重要。参见本文档稍后的分析结果。

** 2.4 Major rule4 – document your functions and variables well

Document your variables and functions well. If functions sets globals, say it in the docs (use "References:" tag). Every function and variable should have DOC-STRING, because when you do describe-symbols, it'll print out the SYMBOL and DOC-STRING. And one can even search through the doc strings with super-apropos Don't forget that the first line of the doc string should be a complete sentence.
翻译:很好地记录你的变量和函数。如果函数设置了全局变量，请在文档中说明（使用“参考文献：”标签）。每个函数和变量都应该有文档字符串，因为当你执行描述符号时，它会打印出符号和文档字符串。甚至可以通过搜索文档字符串来使用super-apropos。不要忘记文档字符串的第一行应该是一个完整的句子。

Don't you feel frustrated too if staring at this?
翻译:如果你长时间盯着看，难道不会感到烦躁吗？

#+begin_src emacs-lisp
(defconst foo-list-storage nil)
#+end_src

Now you have to skim the code to understand how and where the variable is used. The original Emacs recommendation has been that you do need to document package private variables, like the one above. However this recommendation is old and dates back to 18.xx days where the doc-strings memory space was a limited resource. In new Emacs releases there is dynamic byte compilation option which reduces the docstring memory consumption. There is no need to "hand optimise" the doc-strings away.
翻译:现在您需要浏览代码以了解变量是如何以及在哪里被使用的。原始的Emacs建议认为确实需要对私有变量（如上所述）进行文档化。然而，这一建议已经过时，可以追溯到18.x天以前，当时doc-string内存空间是一种有限的资源。在新版本的Emacs中，有动态字节编译选项，这可以减少doc-string的内存消耗。没有必要“手工优化”掉doc-string。

** 2.5 Major rule5 – don't use tricks

Think about new comers when you program, who know nothing about lisp. Try to code clearly. Avoid tricks, which is not very frienly for readers of your code. At least document well why the code at that point looks so complex.
翻译:在编写程序时，要考虑到那些对Lisp一无所知的新手。尽量编写清晰易懂的代码。避免使用技巧，因为这会让阅读您代码的人感到不友好。至少要对那段看起来如此复杂的代码进行良好的文档说明，解释为什么它会是这个样子。

** 2.6 Major rule6 – use byte compiler to check leaks

Check your code for variable leaks in fresh emacs "emacs -q" by running M-x byte-compile-file XXX.el. If possible use XEmacs's for checking because it reports warnings better.
翻译:在全新的 Emacs 中检查变量泄漏（使用 "emacs -q" 启动），可以通过运行 M-x byte-compile-file 命令来编译 XXX.el 文件来实现。如果可行的话，建议使用 XEmacs 进行检查，因为它能更好地报告警告信息。

** 2.7 Use the error function.

Use error command if you cannot continue, or if you think that some other program may depend on your code, it is best that the other program cannot continue. Don't try unnecerrarily handle erorr conditions - it won't work in general with Emacs Lisp, like if you have got used to Java's or C++'s throw staements.
翻译:如果你无法继续执行或者认为其他程序可能依赖于你的代码，那么最好让其他程序也无法继续运行。不要尝试不必要的错误处理——在Emacs Lisp中通常不起作用，就像你已经习惯了Java或C++中的throw语句一样。

** 2.8 Make function as general as possible

But not so general that it can eat apples and cars. It's "good", when the function doesn't get excessive long: still long cond statements are ok. Sometimes you just can't split the task into smaller parts or it makes no sense to split the function, oh well...use your best judgement.
翻译:但是不要太泛化，以至于它可以吃苹果和汽车。当函数没有过长时，“好”是可以接受的：尽管长的条件语句也是可以的。有时候你可能无法将任务拆分成更小的部分，或者拆分函数没有任何意义，嗯……那就用你最好的判断力吧。

Still, a long function raises always thoughts about bad coding. Usually there may be reusable parts, which can be separated, but then, perhaps no. Just make sure you are convinced you need that long function, and that's it.
翻译:仍然，一个长的函数总是让人联想到糟糕的编码。通常可能会有可重用的部分，可以分离出来，但是也许没有。只需确保您确信自己需要那个长函数，仅此而已。
--------------------------------------------------------------------------------------------------------------

* 3.0 Coding style issues

** 3.1 Function's variable definitions

Unclear code:
翻译:您提供的指令似乎不完整或存在语法错误。"Unclear code:" 本身不是一个完整的句子，也没有给出具体的代码需要翻译或者解释。

如果您有特定的代码段需要翻译或者解释，请您提供完整的代码或者详细描述您遇到的问题。例如：

```python
def function_name(parameters):
    # 代码逻辑
```

请确保提供足够的上下文，这样我才能更好地帮助您。

#+begin_src emacs-lisp
(defun xx (arg1 arg2 &optional arg3 )
(let ((foo 1) (bar "xx") baz-flag point))
...
#+end_src

Maybe better written as:
翻译:你是一个优秀的翻译助手，请将我提供的非中文文字翻译成中文。在翻译过程中，请注意保留原文的格式，并且不要进行不必要的解释或发挥。

#+begin_src emacs-lisp
(defun xx (arg1 arg2 &optional arg3 )
(let* ((foo         1)                ;temporary counter
(bar         "xx")             ;displayed value
baz-flag
point)
...
#+end_src

Tip: To "line up" variables nicely in the let statement use some package that can do it, like tinytab.el, which is tab minor mode.
翻译:提示：在let语句中整齐地排列变量，可以使用一些包来完成这项工作，比如tinytab.el，这是一个制表符小模式包。

* Put initialisations first, then variables that do not need initialisations. Here foo and bar are defined before baz-flag and point
* Put each one in separate lines and comment their usages when needed.
* Try to choose descriptive names for variables. Help reader and choose "buffer" instead of "b" or "buf".
* Long names are almost always better.

** 3.2 Let with initialised empty values

Let's start with example code:
翻译:让我们从一个示例代码开始：

#+begin_src emacs-lisp
(let* ((foo '())    ;; A list
(bar nil)    ;; A truth value
test)        ;; A scratch variable.
#+end_src

This effectively causes foo, bar, test to be nil. Don't give the extra stuff fool you. The programmers intention was to clarify, that the foo is a list and by initialising it with () would signify a list context... and so on..
翻译:这实际上导致foo、bar和test变为nil。别被额外的东西误导了。程序员的意图是澄清，foo是一个列表，通过初始化它为()来表示列表上下文……等等。。

But it can be done it more cleanly. The more symbols there are in the view, the less easily can human eye focus to important things. Let's try this instead:
翻译:但是可以做得更干净一些。视图中的符号越多，人眼就越难聚焦到重要的事情上。让我们试试这个：

#+begin_src emacs-lisp
(let* (foo-list     ;; A list
bar-flag     ;; A truth value
test)        ;; A scratch variable.
#+end_src
In this case, the variable names itself tell where they are used, and the missing symbols greatly improve the layout. You know, that variable is nil by default, so there is no point of assigning an empty list. Less is more, in most cases. In addition, when you use these variables inside function body, it's clear all the time what that stand for because the names tell them.
翻译:在这种情况下，变量名本身就说明了它们的使用位置，而省略符号极大地改善了布局。你知道，默认情况下变量是空的，所以没有必要分配一个空列表。“少即是多”，在大多数情况下都是如此。此外，当你在函数体内使用这些变量时，始终清楚它们代表什么，因为变量名已经告诉了你。

** 3.3 There are alternatives to `progn'

progn indents code right very fast and that makes writer to code in a tight space. All code examples below give exactly the same results.
翻译:"progn 快速正确地缩进代码，这使得作者可以在紧凑的空间内编写代码。下面的所有代码示例都产生完全相同的结果。"

#+begin_src emacs-lisp
(if variable                    ;test here
(progn
...it was non-nil , do something))

#+end_src
Sometimes 'cond' statement can be used similarly. It has an implicit progn form:
翻译:有时候也可以使用 'cond' 语句，它具有隐式的 progn 形式：

#+begin_src emacs-lisp
(cond
(variable                      ;test here
...code..
...code..))
#+end_src
And there is also and command, but it requires that all the statements you want to execute return non-nil.  This may not be exactly usable every time.
翻译:也有一个命令，但它要求你想执行的所有语句都返回非空值。这可能并不总是适用。

#+begin_src emacs-lisp
(and variable
..code..
..code..)
#+end_src
Common lisp library, cl.el offers doing the same more cleanly. This is even more nicer. Prefer this one:
翻译:通用Lisp库，cl.el提供了更干净地完成相同任务的方法。这甚至更好。推荐使用这个：

#+begin_src emacs-lisp
(eval-when-compile (require 'cl))

(when variable
...code..
...code..)
#+end_src
[vladimir] ...There are other even worse cases. The worst I can think of is mapcar with an inlined function:
翻译:我所能想到的最糟糕的情况是使用内联函数的mapcar：

#+begin_src emacs-lisp
(mapcar (function (lambda (e)
(do stuff)))
'(1 2 3))
#+end_src
This leaves too few columns for (do stuff). Especially if it contains another mapcar. This is much better:
翻译:这留给（执行操作）的列太少。尤其是如果它还包含另一个mapcar的话。这样做要好得多：

#+begin_src emacs-lisp
(mapcar
(function
(lambda (e)
(do stuff)))
'(1 2 3))
#+end_src
--------------------------------------------------------------------------------------------------------------

* 4.0 Using global variables

** 4.1 Thoughts on globals

Because you will be using globals a lot in Emacs lisp packages, couple of words may be in place You probably are shocked by the fact that lisp programs use globals (actually prefixed or namespace globals) all the time, when you have learned that using globals is totally wrong and should be avoided at any costs.
翻译:因为在Emacs Lisp包中大量使用全局变量，这里有一些需要注意的地方。你可能对Lisp程序频繁地使用全局变量（实际上是前缀或命名空间全局变量）感到震惊，尽管你已经知道使用全局变量是完全错误的，应该不惜一切代价避免它。

The class variables behave quite alike to global variables especially if the class derivation chain is long.  Hm, to be strict, the scope of the variable just gets larger.
翻译:类变量与全局变量的行为非常相似，尤其是在类的继承链很长的情况下。嗯，严格来说，变量的作用域只是变得更大了。

#+begin_example
BASE        -->C1 -->C2 -->C3
public var1               sees BASE's var1
#+end_example
derived classes
翻译:派生类

var1 is not real global, because it ceases to exist if the class is deleted. But, When you see code like this, where variable is "seen" outside of function, the instincts say that we should treat var1 like global. It's temptating to think that local is something that is inside function or function block, and variables outside of a function, while they may be actually packaged within class, are all "globals". Admittedly this is not very accurate distinction, but a practical point of view. In Emacs lisp, the variable scope is whole package and the variables are true globals because any other packages can see them too.
翻译:`var1` 并不是一个真正的全局变量，因为它在类被删除时会停止存在。但是，当你看到这样的代码时（变量 `var1` 在函数外部可见），直觉会让我们把 `var1` 当作全局变量来看待。有一种诱惑认为局部变量是函数或函数块内部的东西，而函数外的变量，尽管实际上可能包装在类中，都被认为是“全局”变量。诚然，这种区分并不十分准确，但从实用的角度来看是这样的。在Emacs Lisp中，变量的作用域是整个包，变量才是真正的全局变量，因为其他任何包都能看到它们。

In Emacs Lisp you can also abstract the use of globals with the degree you want:
翻译:在Emacs Lisp中，你也可以根据自己的意愿程度抽象地使用全局变量：

+ You can use globals directly
翻译:你可以直接使用全局变量
+ Indirectly in functions: using the aliasing method described in a short moment.
翻译:间接在函数中：使用稍后描述的别名方法。
+ Using control functions; that hide the globals from functions (quite strong abstraction)
翻译:使用控制函数；隐藏全局变量（相当强的抽象）。

** 4.2 Globals and emacs lisp packages

They are traditionally used in Emacs packages for
翻译:它们传统上用于Emacs包中。

+ User options: nil/non-nil/some value.
翻译:用户选项：nil/非nil/某些值。

#+begin_src emacs-lisp
(defvar my-global-var t
"Some docs come here how to use it")
#+end_src
+ Customisable user functions or hooks. Here user has a choice to select his preference function to do the job. Advancer lisp programmers traditionally don't even use the default functions but program their own and then set these variables to point to their implementations.
翻译:可自定义的用户功能或钩子。在这里，用户可以选择他偏好的函数来完成工作。高级Lisp程序员传统上甚至不使用默认函数，而是编写自己的程序，然后将这些变量设置为指向它们的实现。

#+begin_src emacs-lisp
(defvar my-collect-function 'my-default-collect-function-1
"*There are two default choices:
'my-default-collect-function-1
'my-default-collect-function-2")
#+end_src

+ Private, place for package storage. Here the package maintainer updates and reads the my-:hash-table during the lifetime of the program.
翻译:私人包裹存放处。在此，包维护者在程序生命周期内更新和读取my-:哈希表。

#+begin_src emacs-lisp
(defvar my-hash-table nil
"Private. List of hash elements")
#+end_src

** 4.3 Aliasing to globals – summary

To clarify: the term aliasing used in next sections doesn't mean real aliasing. The variable is not actually referred through an alias. When you work with a alias variable, you can pretend that you actually work with the global variable. The alias term is used merely for purposes where you read the global when you use it in function. You do not write to a variable aliased like this. We're actually using a copy of variable.
翻译:在接下来的章节中使用的“别名（aliasing）”一词并不意味着真正的别名。变量实际上并不是通过别名来引用的。当你使用一个别名变量时，你可以假装你实际上是在操作全局变量。别名这个术语仅仅用于在你使用它的时候读取全局变量的场合。你不能像这样写入一个被别名的变量。我们实际上是在使用变量的副本。

The next sections will describe these benefits better, but the advantages of copying the global variables are listed here for quick reference:
翻译:接下来的几个部分将会更好地描述这些好处，但是复制全局变量的优势在这里被列出以便快速参考：

+ When globals are only in let, you can see at one glance what globals are used in the function. If your function has 10-20 lines, you can't find the used globals that easily
翻译:当全局变量仅在`let`作用域内时，你可以一眼看到函数中使用了哪些全局变量。如果你的函数只有10到20行，那么就很难轻易地找到使用的全局变量了。
+ You can add extra comment for each global while it is being aliased in let.
翻译:您可以在let语句中为每个全局变量别名添加额外的注释。
+ Function maintenance is simpler: you can lift the global from let to the argument list of a function without touching the function body. You do this if you decide that the argument should be passed to function and not read from global.
翻译:函数维护更简单：您可以将全局变量从 `let` 提升到函数参数列表中，而无需修改函数体。如果您决定该参数应该传递给函数而不是读取全局变量，就可以这样做。

** 4.4 Aliasing to globals – counter arguments

[vladimir] ...If alias is used, the reader has to remember that `foo-mode-switch` and `switch` are the same thing. Furthermore, when you read the body of the function, foo-mode-switch is clearly a global var (perhaps a user option), while you have to look back at the 'let' in order to see that 'switch' is one. Introducing a second name to the same entity doesn't necessarily make anything more clear. There are only a few valid reasons to
翻译:如果使用了别名，那么读者需要记住`foo-mode-switch`和`switch`是同一回事。此外，当你阅读函数的主体部分时，很明显`foo-mode-switch`是一个全局变量（可能是一个用户选项），而你需要回过头去看`let`才能知道`switch`就是它。为同一个实体引入第二个名称并不一定能让任何事情变得更加清晰。只有少数几个有效理由才...

#+begin_src emacs-lisp
(let ((local foo-global)))
(setq local (car local))
;; end
#+end_src

full name seems too long. Of course, dabbrev or PC-lisp-complete-symbol will help you to write the long names, but what will help the reader to read them? of different name.
翻译:全名似乎太长了。当然，dabbrev 或 PC-lisp-complete-symbol 可以帮助你写出长长的名字，但什么能帮助读者阅读它们呢？不同的名字。

#+begin_src emacs-lisp
(let ((case-fold-search nil))
(re-search-forward foo bar)   ; respect case
;; end
#+end_src

** 4.5 Referring to global variable

If any global variables is used in a function, don't use them directly, instead put them into function body let* where any anyone can see at a glance what variables are used. It also make maintaining process much simpler, since the changes have to be done into let* only. Prefer putting globals first in let.
翻译:如果在函数中使用全局变量，不要直接使用它们，而是将其放入函数体中的let*中，这样任何人都能一眼看到使用了哪些变量。这也使得维护过程变得更加简单，因为只需要在let*中进行更改。建议首先在let中放置全局变量。

The other benefit for the maintainer is that if he ever decides to move that global to function call parameter , the task is easy: you just lift the value from let-form to the parameter list, and you never have to touch the function body, because it uses the local variables.
翻译:维护者的另一个好处是，如果他想将来把这个全局变量移动到函数调用的参数中，这项任务非常简单：你只需把值从let形式提升到参数列表中，而且永远不需要修改函数体，因为它使用的是局部变量。

#+begin_src emacs-lisp
(defun my-func ()                ; #1
(let* ((list  my-mode-alist)   ;copy
..other variables..)
..BODY..))
#+end_src

You may later find out that it's actually better to call the function with list argument, so that function becomes more general. Following is the lifted global version of the previous function. Notice that the function body doesn't change in any way.
翻译:你可能后来会发现，使用列表参数调用函数实际上更好，这样函数就变得更加通用了。以下是之前函数的提升全局版本。请注意，函数体没有任何改变。

#+begin_src emacs-lisp
(defun my-mode-func (list)          ; #2 , global is now an argument
(let* (
..other variables..)
..BODY..))
#+end_src

[Vladimir] also suggested that you really don't need this kind of abstraction, because converting function from #1a into #2a with function that use globals directly is as easy.
翻译:[弗拉基米尔]还表示，您实际上并不需要这种抽象，因为使用直接访问全局变量的函数将#1a中的功能转换为#2a的功能是非常简单的。

#+begin_src emacs-lisp
(defun my-mode-func ()                      ; #1a
..BODY..
(if (memq match my-mode-alist)
...)))

;;  Now uses paramer, not global variable my-mode-alist
(defun my-mode-func (my-mode-alist)         ; #2a
..BODY..
(if (memq match my-mode-alist)
...)))
#+end_src

Hm. What do you think? I'd say that this is equal to mine what comes to lisp. But by using the same name in function argument list as for global variable, may makes things confusing, because my-mode-alist is originally meant to be global variable and used in other functions directly. The key point here was that we intended to make function more general, implying that we are probably moving it away from this my-mode package and including it into some general lisp library. If we move this function in #2a format, we wouldn't want to keep symbol names(variables), which refer to specific package my-mode.
翻译:嗯，你怎么看？我认为这与我用Lisp写的代码是相同的。但是，如果在函数参数列表中使用与全局变量相同的名字，可能会造成混淆，因为my-mode-alist原本就是一个全局变量，在其他函数中直接使用。这里的关键点是，我们打算使这个函数更具通用性，这意味着我们可能要将它从my-mode包中移出，并纳入某个通用的Lisp库中。如果我们按照#2a的格式移动这个函数，就不希望保留指向特定包my-mode的符号名（变量）。

Detecting reusable functions from any package is easier if the globals are presented in the first let statement.
翻译:如果在第一个`let`语句中就展示了全局变量，那么从任何包中检测可重用函数就会变得更加容易。

** 4.6 Maintenance and deferring to global

Someone may now think in his mind:
翻译:有人可能会在心里想：

Doesn't that make program more slower, I can avoid those private variables and let* altogether if I use globals directly.
翻译:那样不会使程序更慢吗？如果我直接使用全局变量，我可以避免那些私有变量和let*，

Hm, yes and no; program won't slow down remarkably by the extra let* statement. More important is the ease of maintenance and ability to add comments beside the let statement, since all variables may not be self explanatory. If function is very small, use could those global variables directly to gain some more speed.
翻译:嗯，是的也不是；多加一个let语句并不会显著减慢程序的运行速度。更重要的是维护的便利性和在let语句旁边添加注释的能力，因为并不是所有的变量都能自解释清楚。如果函数非常小，可以直接使用全局变量来获得一些速度上的提升。

But if there is anything more than 10 line long function, for clarity's sake, use the alias method to hide the global from the actual body of function.
翻译:如果函数超过10行长，为了清晰起见，使用别名方法隐藏全局变量，使其不出现在函数体内。

The only case where you may try to bother to optimise let* out is, when function gets called many times. Do you know that the function is dangerous to my program's performance? Probably not, that's why you sometimes use some lisp profiler (elp.el) to bog down speed problems.
翻译:在以下情况下，您可能会尝试费力优化let*：当函数被调用多次时。你知道这个函数对我的程序性能有危险吗？可能不知道，这就是为什么你有时会使用一些Lisp调试器（elp.el）来找出速度问题。

** 4.7 Deferring to global, caution

The only exception when alias cannot be made in let is presented here. We may have to introduce a control function to read global. Suppose we have following situation.
翻译:在`let`语句中无法创建别名的情况只有一种例外，这里给出。我们可能需要引入一个控制函数来读取全局变量。假设我们有以下情况：

#+begin_src emacs-lisp
(defun my-foo ()
(let* ((table my-:passwd-entries-table) ;; copy global
point)
..code..
..code..
(my-change-passwd-table)                    ;; OOPPS!
(while table                             ;; error!
..do, read content..
..code..)))
#+end_src

Obviously it is not possible to read the global beforehand, if it will be changed by another function call during the execution of current function.
翻译:显然，如果在当前函数执行期间另一个函数调用了它，就不可能预先读取全局变量，因为它的值可能会被改变。

For small amount of globals, 5-10, there is no point to make separate control function for reading global, like in this following example.
翻译:对于少量全局变量（如5-10个），没有必要为读取全局变量而单独编写控制函数，如下面的示例所示。

#+begin_src emacs-lisp
(defun my-foo ()
(let* (table                      ;; no global copy
point)
..code..
..code..
(my-change-passwd-table)            ;; Watch out!
(setq table (my-read-passwd))    ;; a macro to read global.

(while table                     ;; okay now..
..do, read content..
..code..)))
#+end_src

The my-read-passwd, is implemented as
翻译:`my-read-passwd` 是如何实现的？

#+begin_src emacs-lisp
(defmacro my-read-passwd ()
"Returns contents of my-:passwd-entries-table"
(` my-passwd-entries-table))
#+end_src

Using this single macro is overkill, but it may turn into more complex function later, if you decide to use many globals. See next:
翻译:使用这个宏有点过头了，但如果您决定使用许多全局变量，它可能会变成更复杂的函数。接下来看：

#+begin_src emacs-lisp
(defsubst my-read-variable (variable)
"Returns contents of global variables"
(cond
((eq variable 'passwd)
my:passwd-entries-table)
((eq variable 'user)
my-user)
(t
(error "No such variable '%s'" variable))))

(my-read-variable 'passwd)
#+end_src

The function is called with symbol describing the variable. This implementation totally hides the global variables from lisp calls and from other outside functions. You must decide how strong abstraction of data you want: For small programs, you probably don't need this kind of strong abstraction, but if the program gets bigger and you start having 20-50 globals, you may consider using similar global control functions.
翻译:这个函数用一个描述变量的符号来调用。这个实现完全隐藏了全局变量从lisp调用和其他外部函数中。你必须决定你想要的数据抽象有多强：对于小型程序，你可能不需要这种强烈的抽象，但如果程序变大并且你有20-50个全局变量，你可能考虑使用类似的全球控制函数。
--------------------------------------------------------------------------------------------------------------

* 5.0 The 'let' forms in function

** 5.1 Using only one let form inside function

Nowadays many books and many programmers teach that you should define variables inside block where you need them. This is perfectly good suggestion and you should follow it in natively compiled languages. The advise for Emacs Lisp is: "use when appropriate".
翻译:如今许多书籍和许多程序员都教导你应该在你需要变量的地方定义变量。这是一个非常好的建议，你在编译型语言中应该遵循它。对于Emacs Lisp的建议是：“适时使用”。

Note: There is slight difference in memory usage if you define a) all variables at the beginning of function b) along the execution of your program, where they are created and destroyed. While the A may take couple of bytes overall more memory, the important point is the content of the variables. If you put 100 cons cells immediately into the variable, that's hogging memory, not the variable definition itself.
翻译:如果你在函数开始时定义了所有变量a)，或者在程序执行过程中创建和销毁它们b)，内存使用量会有细微的差异。虽然A可能总体上占用更多的字节内存，但重要的是变量的内容。如果你立即将100个cons单元格放入变量中，那么是内存被占用了，而不是变量定义本身。

In practice don't worry about this minor memory increase, because creating and destroying a variable increases overhead for functions too (multiple let statements), so how do you choose: a small memory increase at the beginning of file where you define all my variables or do you take chance on adding a slight overhead by defining variables while the function executes? In big, complex function this could be very important issue, but in short functions the choice is insignificant.
翻译:在实践中，不必担心这个微小的内存增加，因为创建和销毁变量也会增加函数的开销（多个let语句），所以您该如何选择：在文件开头定义所有变量的地方稍微增加一些内存，还是冒险在函数执行过程中定义变量以稍加一点开销？在大而复杂的函数中，这可能是一个非常重要的问题，但在短函数中，这个选择则无关紧要。

Most of the time you can use only one let* because it helps keeping function layout clearer, while admittedly that there are very good reasons when you could consider using multiple let* statements. you can arrange the inner body of function to self standing blocks by using many let statements and introduce new let statements where logically appropriate and many lisp programmers recommend that you do so.
翻译:通常情况下，您只需要使用一个let*语句，因为它有助于保持函数结构的清晰性；当然，当您有充分的理由考虑使用多个let*语句时，也是非常好的。通过使用许多let语句来安排函数内部的主体部分成为独立的模块，并在逻辑上适当的地方引入新的let语句，许多Lisp程序员推荐这样做。

In C++ using block local variables is pretty nice looking.
翻译:在C++中使用块局部变量看起来相当不错。

#+begin_src c++
..FUNCTION START
if (var == 1)
{
int temp = 0                    // local to block if
if ( condition )
{
int tmp = 0                 // this is again local
..do something..
}
}
#+end_src

But If we do the same in Emacs lisp, the count of added parentheses may be disturbing:
翻译:如果我们用Emacs Lisp这样做，添加的括号数量可能会令人烦恼：

#+begin_src emacs-lisp
..FUNCTION START
(if (= var 1)
(let ((temp 0))
(setq tmp (1+ tmp))
(if condition
(let ((tmp 0))
(setq tmp (1+ tmp))
..do something..))))
#+end_src

If we were to write real lisp (not Emacs Lisp), the inner let variables could have been be optimized to registers and you should definitely use the multiple let statements. In Emacs lisp, this kind of optimizatrion does not happen because the code is not compiled to native machine code. That's why do not worry so much if all the variables are defined at the top-level let and not inside later let statements. You won't see any noticeable performance drop if you define couple of more variables at the beginning of function. That's why you see most of the time this format.
翻译:如果我们编写真正的Lisp（不是Emacs Lisp），内层的let变量可以被优化到寄存器中，并且您应该肯定使用多重let语句。在Emacs Lisp中，这种类型的优化不会发生，因为代码没有被编译成本地机器码。这就是为什么如果所有变量都在顶层let中定义而不是在后来的let语句中定义，不必过于担心。如果您在函数开头定义了几个更多的变量，也不会看到明显的性能下降。这就是为什么您经常看到这种格式的原因。

#+begin_src emacs-lisp
..FUNCTION START
(let ((tmp1 0)      ;; Define all used variables
(tmp2 0))
(if (= var 1)
(setq tmp1 (1+ tmp1))
(if condition
(setq tmp2 (1+ tmp2))
..do something..))))
#+end_src

The idea for using only one let is that functions look like simple. In one let you can see what variables are used in a function and decide is some private variable is a candidate for global.
翻译:使用单个`let`的原因是让函数看起来更简单。在一个`let`作用域内，你可以看到函数中使用了哪些变量，并决定是否可以将某些私有变量提升为全局变量。

#+begin_src emacs-lisp
FUNCTION
VARIABLES
BODY
#+end_src

While they could look like this:
翻译:虽然它们可能看起来是这样的：

#+begin_src emacs-lisp
FUNCTION
VARIABLES
BODY
VARIABLE
BODY
VARIABLES
BODY
VARIABLE
BODY
#+end_src

** 5.2 Let form and initialising variables

But while the variables can be defined without performance penalty, postpone initialisation if it takes lot of time. They are initialised only just before they are actually used.
翻译:虽然变量可以在不产生性能开销的情况下进行定义，但如果初始化耗时较多，则应推迟初始化。它们仅在实际上使用之前才被初始化。

#+begin_src emacs-lisp
(defun my-func (var)
(let* ((re1  (get-re-1))     ; scans whole file.txt, 100Meg
(re2  (get-re-2))     ;
tmp)
(cond
((eq 'this var)
;; okay we're in business
(re-search-forward re1 nil t)
...
#+end_src

Instead write code like this, which initialises variable only when condition goes into the branch.
翻译:这样做代码如下，仅在条件进入分支时初始化变量。

#+begin_src emacs-lisp
(defun my-func (var)
(let* (re1                ; NOTE - No initialisation
re2                ; NOTE - No initialisation
tmp)
(cond
((eq 'this var)
;; okay we're in business
(setq re1 (get-re-1))
(setq re2 (get-re-2)))
...
#+end_src

--------------------------------------------------------------------------------------------------------------

* 6.0 Function call arguments and return values

** 6.1 Using separate return value 'ret'

Before going further, remember that all lisp forms return the last value which the form executed prior its ending. This is fundament of lisp language and whole lisp programming is based on it. The key here is that you can make the function's return value more visible: the point where the return value is set is obvious. If we use extra variable, say ret, over the implicit return value, the function is a) easier to debug: you can print the ret variable anywhere b) easier to follow: setting the return value is obvious 3) and one exit point is better than "hidden".
翻译:在继续之前，请记住所有的Lisp表达式都会返回其执行结束前最后一个表达式的值。这是Lisp语言的基石，整个Lisp编程都是建立在这个基础之上的。关键是你可以使函数的返回值更加明显：设置返回值的点是显而易见的。如果我们使用额外的变量，比如ret，来代替隐含的返回值，那么函数就有以下几个优点：a）更容易调试：你可以在任何地方打印ret变量；b）更容易理解：设置返回值是显而易见的；c）一个出口比“隐藏”的出口要好。

Of course if the function is very small or extremely simple, you don't have use 'ret': return value is already obvious. Use your common sense to determine when the extra return variable ret could clarify the function and when you decide to leave it out and use lisp form's side effects of returning value of last executed statement.
翻译:当然，如果函数非常小或者极其简单，那么就没有必要使用'ret'：返回值已经很明显了。使用你的常识来判断何时额外的返回变量'ret'可以阐明函数，何时决定省略它并使用lisp形式的返回最后执行语句的结果作为副作用。

#+begin_src emacs-lisp
(defun my-func ()
(let* (..
..)
... many lines of code
(if test
(cond
((= 1 var)
;; IMPLICIT RETURN ))     <---  I wouldn't do this
(..other-test
;; IMPLICIT RETURN ))     <---  I wouldn't do this
... many lines of code
...)) ;; let-defun end
#+end_src

Alternative choice
翻译:你是一个很棒的翻译工具，请把我的非中文文字翻译成中文。在翻译时要保留原文的格式，并且不要随意进行解释。

#+begin_src emacs-lisp
(defun my-func ()
(let* (ret
..)
... many lines of code
(if test
(cond
((= 1 var)
(setq ret (point)))
((= 2 var)
(setq ret ..)))
... many lines of code
...)
ret))  ;; You can put your debugger breakpoint here
#+end_src

And here are some extremely simple functions, compared to above function that would have had many lines of code. In here, the return values are clear.
翻译:与上面那个功能相比，这些函数非常简单，上面的功能可能会有很多行代码。在这里，返回值是清晰的。

#+begin_src emacs-lisp
(defun a (b)
(if b
3))    ; 'else' case returns nil.

(defun a (b)
(cond
((...)
1)                            ;return value
((...)
2)
(t
3)))
#+end_src

Another advantage of using ret is, that it jumps into existence with default value nil. In function body, you just set it to another value if some condition is satisfied, otherwise called receives value nil by default.
翻译:使用ret的一个优点是，它以默认值nil的形式跳入存在。在函数体中，如果某个条件满足，您只需将其设置为另一个值，否则默认接收值为nil。

** 6.2 Calling functions: passing non-nil

[Andrew Fitzgibbon [[mailto:andrewfg@oculus.aifh.ed.ac.uk][andrewfg@oculus.aifh.ed.ac.uk]]] It's common to use a descriptive symbol instead of t when passing arguments to functions. E.g.
翻译:安德鲁·菲茨吉本[[mailto:andrewfg@oculus.aifh.ed.ac.uk][andrewfg@oculus.aifh.ed.ac.uk]]表示，在使用函数传递参数时，通常使用描述性符号而不是t。例如：

#+begin_src emacs-lisp
(directory-files "~" 'absolute "^[^.#%]")
#+end_src

It's a pain then that there's only one nil when you want to default an argument, meaning that you can't easily document it. It's just occurred to me however that you can write:
翻译:如果您想要默认参数时只有一个空值，这意味着您不能轻易地对其进行文档化，这确实很麻烦。然而，我突然想到您可以这样写：

#+begin_src emacs-lisp
(directory-files "~" (not 'absolute) "^[^.#%]")
#+end_src

--------------------------------------------------------------------------------------------------------------

* 7.0 Interactive functions and message display control

How should message displaying be controlled in good manner? If you print any messages, you can add variable verb to the optional parameter list. This variable should be the last element there; unless you have the &rest list of course. Now, why such an recommendation? Suppose your function is quite time consuming; eg. if it does some file handling and it may be a good idea to print some messages to the user about the progress stages.
翻译:在良好的方式下应该如何控制消息显示？如果你打印任何消息，你可以将可变动词添加到可选参数列表中。这个变量应该是最后一个元素；当然，除非你有&rest列表。那么为什么会有这样的建议呢？假设你的函数相当耗时；例如，如果它执行一些文件处理操作，并且向用户打印关于进度阶段的某些消息可能是个不错的主意。

** 7.1 Take one, lack of verbosity control

#+begin_src emacs-lisp
(defun my-do-files ()
(let* (...)
(while
(message "reading files..."))
... do it for 10 secs)
(message "reading files...done"))))
#+end_src

This was the traditional way to code it, because the message is always printed, no matter how the function is called: interactively or by some top level function.
翻译:这是一种传统的编码方式，因为消息总是在函数调用时被打印出来，无论是通过交互式方式还是由某个顶层函数调用来执行：

** 7.2 Take two, some verbosity control

#+begin_src emacs-lisp
(defun my-do-files ()
(let* (...)
(while
(if (interactive-p)
(message "reading files..."))
... do it for 10 secs)
(if (interactive-p)
(message "reading files...done"))))
#+end_src

Thi may be better implementation. Messages are printed only if the user has called fucntion interactively. Do you see anything to make better here? If not, let's examine one more example.
翻译:这可能是一个更好的实现方式。只有在用户交互式调用函数时才会打印消息。您在这里看到有什么可以改进的吗？如果没有，让我们再看看另一个例子。

** 7.3 Take three, full control of verbositiness

#+begin_src emacs-lisp
(defun my-do-files (&optional verb)
(let* (...)
(setq verb (or verb (interactive-p)))
(while
(if verb
(message "reading files..."))
... do it for 10 secs)
(if verb
(message "reading files...done"))))
#+end_src

There are couple of interesting points in this solution. First, it provides verbosity to the user. Second it provides verbosity to the caller too. The idea is, that by default the function is verbose when user calls it, but it also gives the verbose messages whenever someone else calls it..
翻译:这个解决方案有几个有趣的点。首先，它向用户提供冗余信息。其次，它也为调用者提供了冗余信息。这个想法是，默认情况下，当用户调用函数时，函数会变得冗长，但它也会在其他人调用它时提供冗长的消息。

The function can now be called like this and it keeps the used nicely aware of progress:
翻译:现在可以像这样调用这个功能，并且它会很好地让使用者意识到进度：

#+begin_example
M-x my-do-files         --> verbose
#+end_example

But the functions is recalled with the command with C-x ESC ESC followed by re-run with RET, the verbose messages are nnot printed.
翻译:但是可以使用命令C-x ESC ESC来回忆功能，然后通过按回车键重新运行，但不会打印出详细的日志信息。

This actualy makes user function easier to call, because you don't have to call them via M-x (or key binding) to get the verbose messages (like returning status, state of mode on/off). Developers can now turn on particular verbosity of some function if they think would be good to display messages to the user while function is executing.
翻译:这实际上使用户调用功能变得更加容易，因为您不需要通过M-x（或键绑定）来获取冗长的消息（例如返回状态、模式的开关状态）。现在，如果开发人员认为在函数执行期间向用户显示消息会有所帮助，他们可以打开某些功能的特定详细程度。

** 7.4 Using call-interactively isn't always the solution.

Aha, now I hear someone claiming that the example 3 drains into this simple lisp call if verbosity is required by lisp call
翻译:好的

#+begin_src emacs-lisp
(call-interactively 'my-do-files)
#+end_src

Yes, it turns on the (interactive-p) test in function, but by using this it also activates interactive part of the function. If function had the interactive part like this, it would be executed:
翻译:是的，它在函数中打开了（交互式-p）测试，但使用它还会激活函数的交互部分。如果函数有这样的交互部分，那么将会被执行：

#+begin_src emacs-lisp
(defun my-do-files (&optional verb)
(interactive "sWhat's up doc? ")
..code..
(if (interactive-p)
(message "this"))
#+end_src

Then the "What's up doc?" prompt would have been popped onto screen. The variable 'verb' is needed if the decision of printing message is given to the calling function.
翻译:“怎么了，医生？”提示将会出现在屏幕上。“动词”变量是必需的，如果打印消息的决定权交给调用函数的话。
--------------------------------------------------------------------------------------------------------------

* 8.0 Overriding functions

** 8.1 What is that?

Overriding means that the function exists already, but it doesn't do exactly what you want --> you want to write your own implementation which replaces the function. Sometimes there is Here are instructions how you override functions properly. If you just want to have some minor modification, then you should look at the advice.el (std emacs distribution), but to complete replace a function, you can fllow steps above.
翻译:重写意味着该函数已经存在，但它并不完全按您的要求执行 - 您希望编写自己的实现来替换该函数。有时候会有这样的需求。以下是正确覆盖函数的方法说明。如果您只是想要做一些小的修改，那么您可以参考`advice.el`（标准emacs发行版），但为了完整地替换一个函数，您可以按照上述步骤进行操作。

First, make separate file, where you gather overridden functions. You use this file in next sections.
翻译:首先，创建一个单独的文件，用于收集覆盖的函数。你在接下来的章节中使用这个文件。

#+begin_example
~/elisp/my/emacs-rc-override.el

#+end_example

The body of the file looks something like this
翻译:文件主体部分看起来像这样

#+begin_src emacs-lisp
;;; emacs-rc-override.el --- My implementations
;; Override settings of functions for xxxx

;; ................................................ forms ...

<code here>

;; ................................................ funcs ...

<code here>

(provide 'emacs-rc-override)

;;; End of file emacs-rc-override.el
#+end_src

** 8.2 Using the eval-after-load hook trick

Let]s start by defining our own mail-signature function which is defined in sendmail.el. First the Emacs startup file must be modified by adding this code to it:
翻译:让我们首先定义自己的邮件签名函数，该函数在sendmail.el中定义。首先，需要修改Emacs启动文件，添加以下代码：

#+begin_src emacs-lisp
(eval-after-load "sendmail" '(load "~/elisp/my/emacs-rc-override"))
#+end_src

+ This says that "every time file sendmail is loaded, Emacs should execute lisp command (load ...)".
翻译:这段话的意思是：“每当加载sendmail文件时，Emacs应该执行lisp命令（load ...）。”
+ If the sendmail is already loaded into emacs, the form executes immediately.
翻译:如果sendmail已经加载到emacs中，那么表单将会立即执行。
+ If sendmail is already dumped into emacs, you don't need the statement at all, but you can load emacs-rc-override.el right away.
翻译:如果sendmail已经转储到emacs中，您根本不需要那个声明，但是您可以立即加载emacs-rc-override.el。

Next, a function is added to replace the original. Add this code to emacs-rc-override.el after the "funcs" section:
翻译:接下来，添加一个函数来替换原始代码。在emacs-rc-override.el中的“funcs”部分之后，添加以下代码：

#+begin_src emacs-lisp
(defun mail-signature (atpoint)
"My. Sign letter with contents"
^^^
...code)
#+end_src

or
翻译:你是一个很棒的翻译工具，请把我的非中文文本翻译成中文。在翻译时要保留原文的格式，并且不要随意进行解释！

#+begin_src emacs-lisp
(defun mail-signature (atpoint)
"Overridden. Sign letter with contents"
^^^^^^^^^^^^
...code)
#+end_src

Make sure you add some word like "My" or "Overridden" in front of the documentation string, so that when you look up the function description with M-x describe-function <func> or C-h f <func>, you don't mistakenly believe that is is standard emacs function If you overridden 1-2 functions, you may remember which ones you have rewritten, but when you start modifying emacs for your taste (I have 20-30 overridden functions), you can't remember which ones are "true" emacs functions.
翻译:确保你在文档字符串前面加上一些词，比如"My"或"Overridden"，这样当你使用M-x describe-function <func>或C-h f <func>查找函数描述时，就不会误以为它是标准Emacs函数了。如果你重写了1-2个函数，你可能还记得你重写了哪些函数，但是当你开始根据自己的喜好修改Emacs（我有20-30个重写的函数）时，你就记不住哪些是“真正的”Emacs函数了。

Besides, if you post the solution to emacs newsgroups, people will appreciate the comment so that they get the describe-function information too. Inexperienced user's typically just copy the function from the post and if the word my is not there they may never know later that the function whether it was emacs's default or not that they're using...
翻译:此外，如果您在emacs新闻组上发布了解决方案，人们会感激您的评论，这样他们也能获得describe-function信息。经验不足的用户通常会直接复制帖子中的函数，如果其中没有“my”这个词，他们可能永远不会知道后来使用的函数是emacs默认的还是其他的……

Now you have the file ready and only thing left is to put one statement into your .emacs init file:
翻译:现在你已经准备好了文件，只剩下一步需要在你的`.emacs`初始化文件中加入一个声明：

#+begin_src emacs-lisp
(load "~/elisp/my/emacs-rc-override")
#+end_src

This loads the file and hooks everything for you. If you later want to override some other function, you just open the ~/.emacs.o again and (say we override some Gnus functions) add this to the forms section and write the function to the funcs section in emacs-rc-override.el
翻译:这个脚本会加载文件并为你设置所有必要的钩子。如果你稍后想要覆盖其他一些函数，只需再次打开~/.emacs.o文件，假设我们要覆盖Gnus的一些功能，那么在forms部分添加以下内容，并在emacs-rc-override.el文件的funcs部分编写相应的函数即可。

#+begin_src emacs-lisp
(eval-after-load "gnus" '(load "~/elisp/my/emacs-rc-override"))
^^^^^
#+end_src

** 8.3 Using advice.el to replace functions

Note: When you use advice, make sure that the original behaviour of function is preserved. You don't want to break any existing packages that may use the advised function.
翻译:你是一个优秀的翻译助手，请将我提供的非中文文字翻译成中文，并确保在翻译过程中保留原文的格式，同时不要对现有的可能使用该建议函数的包造成破坏。

This is much better way than previously presented eval-after-load method. This time you need advice.el from standard emacs distribution. Why is this better? Because advice doesn't wipe out functions permanently, you can turn them on and off when needed.
翻译:这是一个比之前介绍的eval-after-load方法更好的方式。这次你需要使用标准emacs发行版中的advice.el。为什么这更好？因为advice不会永久性地删除函数，根据需要可以打开或关闭它们。

The advice has flag around that lets you do things around then function: before and after calling it. But if you don't call ad-do-it inside advice, then you have effectively replaced the function. This is what you need
翻译:建议周围有标志，允许您在函数周围执行操作：调用之前和之后。但是，如果您不在建议中调用ad - do - it，那么实际上已经替换了函数。这就是您所需要的。

#+begin_src emacs-lisp
(defadvice mail-signature (around my act)
"Replaces function."
...code
(setq ad-return-value something))
#+end_src

The important point here is that you say around and do not include advice macro ad-do-it in the body of function (which would call the original function). The advice is put into category my to refer to your definitions and finally it's put into immediate use: act means activate now.
翻译:在这里重要的是，你说的是大约，而不是在函数的主体中包括建议宏执行（这将调用原始函数）。建议被放入类别my中以引用您的定义，最后立即使用：act意味着现在激活。
--------------------------------------------------------------------------------------------------------------

* 9.0 Using macros

** 9.1 Macros introduction

Dewey M. Sasser [[mailto:dewey@newvision.com][dewey@newvision.com]]
翻译:杜威·M·萨瑟[[mailto:dewey@newvision.com][dewey@newvision.com]]

Macros are (probably) the most difficult thing in LISP to understand, especially coming from a background in C or assembly. The big key in lisp is that a macro is just a function invoked by the evaluator to find out what it should really evaluate. This has two big implications:
翻译:宏可能是LISP中最难理解的东西，尤其是如果你有C或汇编语言的背景的话。LISP中的大关键是：宏仅仅是一个由求值器调用来找出它应该真正评估什么的函数。这有两个重大含义：

+ Arguments to a macro are not evaluated.
翻译:宏的参数不会被评估。
+ Macros can call functions
翻译:宏可以调用函数

It is not necessary (and because of feature #1, somewhat brain twisting) to call a macro from another macro.
翻译:从另一个宏调用宏是不必要的（并且由于特性#1，有些令人费解）。

When you write a macro, don't think of it as writing a macro, but as a function that will be called to translate the arguments (as you've specified) from the way they are to some other form. Your return value is the form to be executed instead.
翻译:当你编写一个宏时，不要把它看作是在写一个宏，而要把它看作是一个函数，这个函数将被调用以将参数（如你所指定的）从它们当前的形式转换为另一种形式。你的返回值是要被执行的形式。

For example:
翻译:例如：

#+begin_src emacs-lisp
(defmacro my-setq (var value)
(list 'setq var value))

(macroexpand '(my-setq x y))
==>(setq x y)

(defmacro msf (symbol)
`(symbol-function (quote ,symbol)))
#+end_src

But is a bit less obvious.
翻译:但是这有点不那么明显。

If you really want to hurt your brain, think about situation where you might want to do ',',form (which is valid code and I've seen it used, but never had to use it myself). You do this kind of thing when you write macros which produce other macros.
翻译:如果你真的想挑战你的大脑，可以思考一下你可能想要这样做的情况：使用逗号形式（这是有效的代码，我也见过这样使用，但自己从未用过）。当你编写产生其他宏的宏时，你就会进行这种操作。

** 9.2 A note on lisp and "forward declarations"

Dewey M. Sasser [[mailto:dewey@newvision.com][dewey@newvision.com]]
翻译:杜威·M·萨瑟[[mailto:dewey@newvision.com][dewey@newvision.com]]

Lisp does not have "forward declarations", as in some other languages. In using Lisp, you should make sure that the definition has been seen before it is used.
翻译:Lisp中没有其他一些语言中的“前向声明”。在使用Lisp时，你应该确保在引用之前已经看到了定义。

If you define function A using function B, but before function B has been defined, it will work, but the byte compiler may not be able to check your call to function B. Also, if B is really a macro rather than a function, it's definition must have been seen before it is used. Remember that macros are expanded by the byte-compiler and do not actually get compiled into your code. Only the results are compiled in.
翻译:如果您使用函数B来定义函数A，但是在函数B被定义之前这样做，它可能会起作用，但是字节编译器可能无法检查您对函数B的调用。此外，如果B实际上是一个宏而不是一个函数，它的定义必须在它被使用之前被看到。记住，宏是由字节编译器展开的，并不会实际编译到您的代码中。只有结果会被编译进去。

Anyone who programs in Lisp a lot (and you definitely do) should have a copy of CommonLisp:_the_Language_, 2nd Edition, by Guy L. Steel. Emacs Lisp is not strictly compatible with the language it defines, but Steel's book (commonly referred to as CLtL2) is a very good reference and description of how and while. It's not a tutorial, but an annotated standard.
翻译:经常编写Lisp程序的人（您肯定是这样）应该有一本《Common Lisp：The Language》，第2版，作者是Guy L. Steele。Emacs Lisp并不严格兼容它所定义的语言，但是Steel的书（通常被称为CLtL2）是非常好的参考和描述了如何以及何时这样做。它不是教程，而是一本注释标准。

Whenever possible, have your macros expand to normal lisp code, the way you'd write it if you weren't using macros. Since you wouldn't write a normal function like:
翻译:尽可能地让你的宏展开为正常的Lisp代码，就像你不使用宏时会写的那样。由于你不会编写像这样的普通函数：

#+begin_src emacs-lisp
(setf (symbol-function 'my-func)
(function (lambda (x) (do-something x))))
#+end_src

don't make your macro expand to that unless there's some very good reason. If you go look at my modefn.el, where modefn::define-mode-specific-function does the real work behind a "defmodemethod" call, you'll see that what it's doing is just building the proper defun!
翻译:除非有非常好的理由，否则不要让你的宏展开到那个样子。如果你去看看我的modefn.el文件，你就会发现modefn::define-mode-specific-function在“defmodemethod”调用背后真正的工作是构建正确的defun！

This has the advantage of avoiding all of the nasty byte compiler tricks necessary to have something compiled as a function (like quoting with function, for example) or other things. Also, there's really no simple work-around for defvar. You pretty much have to use a defvar form. (OK, you could work around it, but it's a lot more work.)
翻译:这样做的好处是避免了所有必要的字节编译技巧（例如使用函数引号），以及其他一些事情。而且，对于defvar来说，实际上并没有什么简单的解决办法。你基本上必须使用defvar形式。(好吧，你可以绕过它，但那会麻烦得多。)

I think that if you forget about the code you've written so far (I know, that's difficult to do), and rewrite it using what you now know, you'll save yourself a lot of work and get better results.
翻译:如果您能忘记目前已编写的代码（我知道，这很难做到），并利用现在所知道的知识重新编写，您将会节省很多工作并且获得更好的结果。

** 9.3 Macros and autoloading

One important thing that you must remember when using macros is, that you must tell in autoload statement explicitly, that that defined symbol is a macro. Suppose following.
翻译:在使用宏时，您必须记住的一件重要事情是，在autoload语句中明确指出所定义的符号是一个宏。假设如下。

#+begin_example
library X: has 100 functions and macros
library Y: has 100 functions only
#+end_example

Now user builds his package using code from library Y and X. Sophisticated user doesn't want to slurp whole library, immediately, but he wants to instruct emacs to load functions on demand by adding autoload statements into the code.
翻译:现在用户使用库Y和X中的代码来构建他的包。这位熟练的用户不想立即导入整个库，但他希望告诉emacs按需加载函数，通过在代码中添加autoload语句来实现。

Here is simple way to load packages
翻译:这是一个简单的方法来加载包

#+begin_src emacs-lisp
(require 'X)
(require 'Y)
#+end_src

Slightly different way is presented below. The function y-function-this is loaded from package Y only when is is needed somewhere in the code.
翻译:下面是稍微不同的方法。当代码中某个地方需要使用它时，才会加载来自包Y的y-function-this函数。

#+begin_src emacs-lisp
(require 'X)
(autoload 'y-function-this "Y")
#+end_src

And the bogus way would be
翻译:使用虚假的方式将是

#+begin_src emacs-lisp
(autoload 'x-macro-this    "X")   ;; Wrong
(autoload 'y-function-this "Y")
#+end_src

The last example fails, not during the byte compilation phase – it passes with flying colours, but in the middle of run time function it breaks. That's because the user forgot to mention that the the x-macro-this is a macro. What actually happened, was that in byte compiled file there is function call
翻译:最后一个例子失败了，不是在字节编译阶段——它在那里表现得非常好，但是在运行时函数的中途就崩溃了。这是因为用户忘记提到x-macro-this是一个宏。实际上发生的情况是，在字节编译文件中有对函数的调用

#+begin_src emacs-lisp
(x-macro-this)
#+end_src

But the macro should have been open coded and expanded! The right way to use the autoloads is:
翻译:但是宏应该已经被公开编码并展开！使用autoload的正确方法是：

#+begin_src emacs-lisp
(autoload 'x-macro-this    "X" 'macro)   ;; okay now
(autoload 'y-function-this "Y")
#+end_src

Tip: See tinylisp.el and command '$ A' in tinylisp-mode which creates right autoload statements from any lisp package file.
翻译:提示：查看tinylisp.el和tinylisp模式中的命令'$A'，该命令可以从任何lisp包文件中创建正确的autoload声明。

** 9.4 Coding defmacros and name space problem

This topic is throughly explained in the '(XEmacs lispref) Surprising Local Variables' and It is adviced that you read that section for better reference. If you have been using macros, you probably know about the dynamic scoping problem that may be occurring.
翻译:这个话题在《(XEmacs lispref) 惊人的局部变量》中得到了详尽的解释，建议您阅读该部分以获得更好的参考。如果您一直在使用宏，那么您可能已经知道可能会发生的动态作用域问题。

#+begin_src emacs-lisp
(defmacro my-macro (&rest body)
(let* ((counter 0))
(while (< counter 9)
(inc counter)
;; BODY sees _counter_
(,@ body))))
#+end_src

In the code above, macro's counter is visible to body and if there is also user defined "counter", then there is a serious name conflict.
翻译:在上述代码中，宏的计数器对主体可见，如果还有用户定义的“counter”，那么就会有一个严重的命名冲突。

One possible way to avoid this clashing is to use mangled variable names in local macros. Because the lisp is case sensitive, you can mix upper and lowercase letters to make unique variable name; the chance that body would have similar name is astronomically small. A non-clashing name could have been made from mixing the first and last characters:
翻译:为了避免这种冲突，可以在局部宏中使用打乱的名字。因为Lisp对大小写敏感，所以可以混合使用大写和小写字母来创建唯一的变量名；主体拥有相似名称的可能性极其渺小。一个不会发生冲突的名称可以通过混合第一个和最后一个字符来制作：

#+begin_example
CounteR
#+end_example

Another way to use unique names I learned from a post by [[mailto:wbrodie@panix.com][wbrodie@panix.com]] (Bill Brodie), gnu.emacs.help, 23 Aug 1996. He quoted my post where I wondered where I could use make-symbol command.
翻译:我从[[mailto:wbrodie@panix.com][wbrodie@panix.com]]（比尔·布罗迪）在gnu.emacs.help邮件列表于1996年8月23日发表的帖子中学到了另一种使用独特名称的方法。他引用了我关于想知道make-symbol命令在哪里可以使用的疑问的帖子。

> In fact I don't know any use of the command
翻译:实际上我不知道这个命令有什么用处
> make-symbol...
翻译:好的

Probably its most common use is in writing macros, to make sure that a temporary variable introduced into the macro's expansion doesn't conflict with any user variables. For example:
翻译:它最常用的用途是在编写宏时确保宏展开过程中引入的临时变量不会与任何用户变量发生冲突。例如：

#+begin_src emacs-lisp
(defmacro m (x)
(let ((x-var (make-symbol "x")))
(` (let (((, x-var) (, x)))
...))))
#+end_src

** 9.5 Macro or defun
#+begin_example
| looking thru the advice.el code I notice this definition:
|
| (defmacro ad-xemacs-p ()
|   ;;  Expands into Non-nil constant if we run XEmacs.
|   ;;  Unselected conditional code will be optimized
|   ;;  away during compilation.
|   (string-match "XEmacs" emacs-version))
|
| and was wondering what the difference is between using `defmacro'
| instead of `defun' when no args are used.
#+end_example

[Vladimir]
翻译:好的

The above is equivalent to nil on non-xemacs and 6 (or whatever) on emacs. The bytecompiler will compile (if nil (foo)) to nothing. If you used a function instead (or a variable), the bytecompiler would generate code to call it (fetch its value) and accordingly it will include both the emacs and xemacs variants of the code. This is slower and produces more code, however there's one significant shortcoming of the macro variant: code compiled with emacs won't work on xemacs and vice versa This makes it impossible to share .elc's one a site that has both emacsen installed.
翻译:在非XEmacs系统上，上述代码等同于nil（或emacs上的某个值）。字节编译器会将（如果为nil则执行foo）编译为空。如果您使用的是函数而不是变量，字节编译器将会生成调用它的代码（获取其值），并相应地生成emacs和xemacs两种版本的代码。这会慢一些，生成的代码也会更多，然而宏变体有一个显著的缺点：用emacs编译的代码不能在xemacs上运行，反之亦然。这使得在一个同时安装了emacs和xemacs的站点上共享.elc文件变得不可能。

** 9.6 Expanding macros

It sometimes usefull to expand the macro to really see what happend in there. Evaluate these and be amazed
翻译:有时候展开宏确实能让人清楚地看到那里发生了什么。评估这些并感到惊讶吧。

#+begin_src emacs-lisp
(macroexpand      '(dolist (i '(1 2)) i))
(cl-prettyexpand  '(dolist (i '(1 2)) i))

;;  XEmacs 19.15 only
(prettyexpand-sexp '(block nil))
#+end_src

** 9.7 Macro demonstration – tutorial

Dewey M. Sasser [[mailto:dewey@newvision.com][dewey@newvision.com]]
翻译:杜威·M·萨瑟[[mailto:dewey@newvision.com][dewey@newvision.com]]

As an example, here's my start at the "minor-mode" wizard (you know, ever since Microsoft started using that term, I've hated it.) This code defines a macro "make-minor-mode", which can be invoked like this:
翻译:例如，这是我对“小模式”向导（你知道，自从微软开始使用那个术语以来，我就讨厌它。）的这个版本的开头。这个代码定义了一个宏 “make-minor-mode”，可以像这样调用：

#+begin_src emacs-lisp
(make-minor-mode dewey
"C-cd" 'insert-dewey
"C-cs" 'insert-sasser)
#+end_src

The above call expands to this:
翻译:您的要求是将非中文文本翻译成中文，并保持原始文本的格式，同时避免不必要的解释。

#+begin_src emacs-lisp
(progn
(defvar dewey-minor-mode nil
"Variable which controls if dewey-minor-mode is active.")

(defun dewey-minor-mode (&optional arg)
"Function which toggles the dewey-minor-mode"
(setq dewey-minor-mode
(if (null arg)
(not dewey-minor-mode)
(> (prefix-nume ric-value arg) 0))))

(setq minor-mode-alist
(cons (cons (quote dewey-minor-mode) name)
minor-mode-alist))

(defvar dewey-minor-mode-keymap nil
"The keymap for dewey-minor-mode")

(if keymap-symbol nil
(setq dewey-minor-mode-keymap (make-sparse-keymap))
(define-key dewey-minor-mode-keymap "^Cd" 'insert-dewey)
(define-key dewey-minor-mode-keymap "^Cs" 'insert-sasser')))
#+end_src

** 9.8 Macro demonstration – code

Dewey M. Sasser [[mailto:dewey@newvision.com][dewey@newvision.com]]
翻译:杜威·M·萨瑟[[mailto:dewey@newvision.com][dewey@newvision.com]]

Here is the complete macros that are used. Study them carefully.
翻译:这是所使用的完整宏命令。请仔细研究它们。

#+begin_src emacs-lisp
(defun minor-mode-variable-symbol (mode)
"Return the symbol of the minor mode controlling variable.
Arguement MODE is a symbol"
(intern (concat (symbol-name mode) "-minor-mode")))

(defun minor-mode-make-keymap-symbol (mode)
"Return the symbol of the minor mode controlling variable.
Arguement MODE is a symbol"
(intern (concat (symbol-name mode) "-minor-mode-keymap")))

(defun minor-mode-function-name (mode)
"Return the symbol naming the minor mode function.
PREFIX can be used to determine which function"
(intern (concat
(symbol-name mode)
"-minor-mode")))

(defun make-minor-mode-keymap (mode bindings)
"Define the appropriate keymap"
(let ((name (symbol-name mode))
(keymap-symbol (minor-mode-make-keymap-symbol mode)))
(list
`(defvar ,keymap-symbol nil
(concat "The keymap for " name "-minor-mode"))
`(if keymap-symbol nil
@(let (results key binding)
(if (oddp (length bindings))
(error "Odd number of keys and bindings"))
(push `(setq ,keymap-symbol (make-sparse-keymap))
results)
(while bindings
(setq key (pop bindings))
(setq binding (pop bindings))
(push
`(define-key ,keymap-symbol ,key ,binding)
results))
(nreverse results))))))

(defun make-minor-mode-add-to-alist (mode)
"Add appropriate thing to minor-mode-alist"
(let ((name (symbol-name mode))
(variable-symbol (minor-mode-variable-symbol mode)))
`(setq minor-mode-alist
(cons
(cons ',variable-symbol name)
minor-mode-alist))))

(defun make-minor-mode-variable (mode)
(let* ((variable-symbol (minor-mode-variable-symbol mode)))
`(defvar ,variable-symbol nil
(concat "Variable which controls if " (symbol-name mode)
"-minor-mode is active."))))

(defun make-minor-toggle-mode-function (mode)
"Return the defun form to define the minor mode"
(let* ((mode-name (symbol-name mode))
(variable-symbol (minor-mode-variable-symbol mode))
(function-name (minor-mode-function-name mode)))
`(defun ,function-name (&optional arg)
(concat "Function which toggles the "
mode-name "-minor-mode")
(setq ,variable-symbol
(if (null arg) (not ,variable-symbol)
(> (prefix-numeric-value arg) 0))))))

(defmacro make-minor-mode (mode &rest bindings)
"Define the minor mode functions, etc"
`(progn
(make-minor-mode-variable mode)
(make-minor-toggle-mode-function mode)
(make-minor-mode-add-to-alist mode)
@(make-minor-mode-keymap mode bindings)))
#+end_src

** 9.9 Nesting macros

Below is a very simple demonstaration how you use toplevel to call other macros that need symbols as arguments. The toplevel expects that the variables are know by name before hand.
翻译:下面是一个非常简单的示例，展示了如何使用顶层来调用需要符号作为参数的其他宏。顶层期望在之前就已经知道了变量的名称。

#+begin_src emacs-lisp
;;  some predefined variables

(defvar my-variable1)
(defvar my-variable2)

(defmacro my-internal (sym)
;;  Example macro that needs symbol as input argument
;;
(` (symbol-value (, sym))))

(defmacro my-toplevel (variable-prefix)
;;  toplevel uses my-internal macro; Create symbols for calls
;;
(let ((sym1 (intern
(concat (` (, variable-prefix)) "-variable1")))
(sym2 (intern
(concat (` (, variable-prefix)) "-variable2"))))
(`
(,@
(let* (ret)
;;  Really, nothing magic here. Since the return value
;;  of macro must be a list, we build up list with
;;  push command. To return the list in proper order
;;  we finally use nreverse.
;;
(push 'progn ret)
(push (` (my-internal (, sym1))) ret)
(push (` (my-internal (, sym2))) ret)

(nreverse ret))))))

;;  To check what happens when the macro is expanded

(macroexpand ' (my-toplevel "my"))

;;  And this is the result:
;; --> (progn
;;       (my-internal my-variable1)
;;       (my-internal my-variable2))
#+end_src

** 9.10 Code: nesting macros, complex example

[vladimir] Here's a macro to define toggle commands.
翻译:以下是一个宏定义切换命令的定义：

#+begin_src emacs-lisp
(defmacro v/deftoggle
(sym &optional get set comment before after message)
"Define a function v/toggle-SYM to toggle SYM on and off.
GET and SET are either nil in which case SYM and (setq SYM)
are used, functions (eg default-value and set-default)
called with SYM and SYM VAL,
or (macro lambda (SYM) ...) and
(macro lambda (SYM VAL) ...) respectively.
COMMENT is additional comment for v/toggle-SYM,
BEFORE and AFTER are lists of additional
forms around the toggle code,
MESSAGE is a (macro lambda (SYM VAL) ...) replacing the normal
"SYM is VAL.""
(cond ((null get) (setq get sym))
((symbolp get) (setq get `(,get (quote ,sym))))
((setq get (macroexpand (list get sym)))))
(let ((val `(if arg (> (prefix-numeric-value arg) 0)
(not ,get))))
(cond ((null set) (setq set `(setq ,sym ,val)))
((symbolp set) (setq set `(,set (quote ,sym) ,val)))
((setq set (macroexpand (list set sym val)))))
`(defun ,(intern (concat "v/toggle-" (symbol-name sym)))
(&optional arg)
(concat "Toggle " (symbol-name sym)
". Return the new value. With positive ARG set it,
with nonpositive ARG reset it."
(if comment (concat "n" comment)))
(interactive "P")
@before
set
@after
(if message (macroexpand (list message sym get))
`(message "%s is %s" (quote ,sym) ,get))
get)))
#+end_src

A simple command to toggle a var is defined like this:
翻译:一个简单的命令来切换一个变量是这样的：

#+begin_src emacs-lisp
(v/deftoggle bibtex-maintain-sorted-entries)
#+end_src

This executes some code after toggling the var:
翻译:在切换变量后执行一些代码：

#+begin_src emacs-lisp
(v/deftoggle debug-on-error nil nil
"Require 'fdb (filter out trivial errors)." nil
((if debug-on-error (require 'fdb))))
#+end_src

This uses default-value and set-default as the get and set functions because url-be-asynchronous is buffer-local, and we need to manipulate its global value.
翻译:这个使用default-value和set-default作为获取和设置函数，因为url-be-asynchronous是缓冲本地变量，我们需要操作它的全局值。

#+begin_src emacs-lisp
(v/deftoggle url-be-asynchronous default-value set-default)
#+end_src

This goes wild: it uses special get/set functions and a special message
翻译:这段话翻译成中文是：“这太疯狂了：它使用了特殊的获取/设置函数和一条特殊的信息”。

#+begin_src emacs-lisp
(v/deftoggle indented-text-mode
(macro lambda (sym)
'(eq major-mode 'indented-text-mode))
(macro lambda (sym val)
`(if ,val
(progn
(make-variable-buffer-local
'before-indented-text-mode)
(put 'before-indented-text-mode
'permanent-local t)
;; so that kill-all-local-variables won't touch it
;;
(setq before-indented-text-mode major-mode)
(indented-text-mode))
(if (boundp 'before-indented-text-mode)
(funcall before-indented-text-mode)
(normal-mode)
(if (eq major-mode 'indented-text-mode)
(text-mode)))))
"Toggle the major mode between indented-text-mode
and the normal-mode."
nil nil
(macro lambda (sym val) `(message "%s" major-mode)))
#+end_src

** 9.11 Using macros to create functions

#+begin_src emacs-lisp
;; example presented by [kai]

(defun make-multiplier (n) `(lambda (x) (* ,n x)))
(fset 'double (make-multiplier 2))
#+end_src

[Bill Dubuque [[mailto:wgd@martigny.ai.mit.edu][wgd@martigny.ai.mit.edu]]] The above technique does not work to create a closure. The point of a closure is that it 'closes' over (captures) some lexically apparent bindings. The exact same binding may be shared by many different closures created in the same lexical context. If one of the closures alters the value of a closed variable, all the other closures will see the change.
翻译:比尔·杜布克[[mailto:wgd@martigny.ai.mit.edu][wgd@martigny.ai.mit.edu]]上述技术无法创建闭包。闭包之所以被称为“闭包”，是因为它能够捕获（封装）一些在词法上明显的绑定。同一个词法上下文中可能存在许多不同的闭包，它们共享完全相同的绑定。如果其中一个闭包改变了封闭变量的值，那么所有其他闭包都会看到这个变化。

E.g. one can use closures to implement data abstractions where the closed bindings essentially are state that is hidden by the abstraction. Here is a toy example that implements a counter with READ and INCREMENT methods:
翻译:例如，人们可以使用闭包来实现数据抽象，其中封闭的绑定本质上是被抽象隐藏的状态。下面是一个玩具示例，实现了具有READ和INCREMENT方法的计数器：

#+begin_src emacs-lisp
(defun make-counter (value)
(values
#'(lambda ()                ; READ method
value)
#'(lambda (increment)       ; INCREMENT method
(setq value (+ value increment)))))

(multiple-value-bind (counter-read counter-incf)
(make-counter 1)   ; value <- 1
(funcall counter-incf 2)              ; value <- value + 2
(funcall counter-read))               ; read value

=> 3
#+end_src

Note how the same lexical binding of 'value' was captured in both the READ and INCREMENT closures returned by make-counter.
翻译:请注意，在make-counter返回的READ和INCREMENT闭包中捕捉到了对'value'相同的词法绑定。

Dewey M. Sasser [[mailto:dewey@newvision.com][dewey@newvision.com]] comments:
翻译:杜威·M·萨瑟[[mailto:dewey@newvision.com][dewey@newvision.com]]评论说：

Actually, I found when experimenting that the fset line is byte compiled. I suppose what that means is that byte-compiler is smart enough to treat the argument to "fset" as a function.
翻译:实际上，我在实验中发现“fset”行被字节编译了。我想这意味着字节编译器足够智能，能够将“fset”的参数视为一个函数。

#+begin_src emacs-lisp
(defmacro make-multiplier (n)
(` (lambda (x) (* (, n) x))))

(macroexpand ' (make-multiplier 2))
;; --> (function (lambda (x) (* 2 x)))

(fset 'double (make-multiplier 2))
#+end_src

However, if you do a
翻译:如果你真的想做某事

#+begin_src emacs-lisp
(setq some-var (make-multiplier 2))
(fset 'double some-var)
#+end_src

I don't think it will be compiled; maybe you have to write
翻译:我不认为它会编译成功；也许您需要重新编写

#+begin_src emacs-lisp
(setq some-var (make-multiplier 2))
(fset 'double (byte-compile-sexp some-var))
#+end_src

Here is another possibility
翻译:您还可以这样表达：“你是一个出色的翻译工具，请将我提供的非中文文本翻译成中文。在翻译过程中，请注意保留原文的格式，并且不要进行不必要的解释。”

#+begin_src emacs-lisp
(defun make-multiplier (func-sym n)
(let ((name (intern (symbol-name func-sym))))
(` (defun (, name) (x) (* (, n) x)))))

;;;###autoload
(` (,@ (make-multiplier 'double 2)))
;; --> (defun double (x) (* 2 x))
#+end_src

[*Dewey* comments more]
翻译:[杜威评论更多]。

However, while the real function is installed there, the autoload won't notice it. Autoload is a magic text thing. When the ;;;###autoload token is read, the autoload library uses (read) to read the next form. Read does not expand macros (well, only reader macros like #', and evidently ` is a reader macro that expands to the old-style (` (,a)) syntax). It the above example you get nothing (autoload should really be rewritten to be extensible).
翻译:然而，尽管实际功能已安装在那些地方，但自动加载并不会注意到它。自动加载是一种魔法文本事物。当读取到;;;###autoload标记时，自动加载库使用(read)来读取下一个形式。Read不会展开宏（好吧，只有像#这样的读者宏以及显然`是一个扩展为旧式语法(`(,a))的读者宏）。在上面的例子中，您什么也得不到（自动加载实际上应该被重写以实现可扩展性）。

If you know the form will expand into "blah-func", which is a function, you can use:
翻译:如果您知道表单将展开为“blah-func”，即一个函数，则可以使用：

#+begin_src emacs-lisp
;;;###autoload (autoload 'blah-func "this-file" "docs")
#+end_src

or whatever the actual call to autoload that you want.
翻译:你是一个好用的翻译助手，请将我的非中文文字翻译成中文!注意翻译时保持源文本格式不变，另外不要做无畏的演绎！

** 9.12 How to read the macros

When you see some exiting new styled macro, you can convert it back to old format with trick presented by [dewey]
翻译:当你看到一些令人兴奋的新样式宏观时，你可以用[dewey]提供的技巧将其转换回旧格式。

#+begin_src emacs-lisp
(setq  foo (read (current-buffer)))
(print foo (current-buffer)) C-u C-x C-e
#+end_src

--------------------------------------------------------------------------------------------------------------

* 10.0 Using lambda notation – some thoughts

** 10.1 Clarification

lambda is same as function, it is just "anonymous" function. So everything you can do with real function, you can do with lambda.
翻译:lambda表达式等同于函数，它只是“匿名”函数。因此，你可以用普通函数做的所有事情，你也可以用lambda表达式来做。

Lisp programmers use lambda functions very often, but many times it would be better to see real functions instead. The lambdas have their places in lisp, eg. for mapcar and inside macros they are often used. But overall, lambdas are not that good.
翻译:Lisp程序员经常使用lambda函数，但很多时候用真正的函数会更好。lambda在lisp中有其位置，例如用于mapcar和宏内部它们经常被使用。但是总的来说，lambda并不是那么好。

[Vladimir] also comments: There are several important things about using anon functions:
翻译:[弗拉基米尔]还评论说：关于使用匿名函数有几个重要的事情：

+ They can be constructed at run-time, returned from functions, stored in structures, etc. Not having to have a name for a function can sometimes be a boon, because you don't have to divine one for it!
翻译:它们可以在运行时构建，从函数返回，存储在结构中等等。不必为函数命名有时是一种恩惠，因为你不需要为其猜测一个名字！
+ They can use the environment of the form they're embedded in. Eg they can use the local 'let' variables of the containing function without having to pass them as args, use dynamically scoped variables, or make them globals.
翻译:它们可以使用嵌入它们的那个环境的特性。例如，它们可以访问包含函数的局部`let`变量，而无需作为参数传递它们，使用动态作用域的变量，或者使它们成为全局变量。

** 10.2 Motivation to not to use lambdas all the time

+ Real function is cleaner, easy to hand to someone, more easily removed from hooks, more... than a lambda form.
翻译:实际功能更简洁、便于交接他人使用、比lambda形式更容易从钩子中移除等等。
+ You can test functions, because you can call them. You can't easily test lambdas, because they have no name to call at.
翻译:你可以测试函数，因为你可以调用它们。你不能轻易地测试lambda表达式，因为没有名字可以调用。
+ You can put functions in separate file; it can be collection of useful functions found from the net. For speed reasons you can byte compile this separate file. Many lambdas in your .emacs just make it look messy, separate function file is more convenient way.
翻译:你可以把函数放在单独的文件中；它可以是来自网络的有用函数的集合。出于速度的原因，你可以对单独的文件进行字节编译。你`.emacs`中的许多lambda表达式只是让它看起来更混乱，而分开的函数文件是一种更方便的方法。

Let's see an example. Suppose we want to add some more regexps to error identification regexp list when the compile.el gets loaded.
翻译:让我们看一个例子。假设当我们加载compile.el时，想要在错误识别正则表达式列表中添加一些更多的正则表达式。

Bad choice:
翻译:错误的选择

#+begin_src emacs-lisp
(eval-after-load
"compile"
'(progn
;; SGI's cc warning message
(setq compilation-error-regexp-alist
(cons
;; IAR C Compiler: "can.c":390  G
'("n"\(.*\)":\([0-9]+\) +.*$" 1 2)
compilation-error-regexp-alist))))
#+end_src

While looking perfectly valid, it has some problems. How do you post this answer to someone else? Maybe he already has used some other way and he doesn't like this approach. How do you change this setup afterwards, especially when your're experimenting with right regexps. Gosh! How do I remove the entry from the variable eval-after-load ?
翻译:虽然看起来很有效，但它有一些问题。您是如何将此答案发布给其他人的？也许他已经使用了其他方法并且不喜欢这种方法。您如何在之后更改此设置，尤其是在尝试正确的正则表达式时呢。哎呀！我该如何从变量eval-after-load中删除条目？

In here things are simple. Easily modifiable. And easily handed to anyone else.
翻译:在这里事情很简单。容易修改。而且很容易交给其他人。

Possibly better choice:
翻译:你是一个出色的翻译助手，请将我提供的非中文文本翻译成中文。在翻译过程中，请注意保留原文的格式，并且不要进行不必要的解释或发挥。

#+begin_src emacs-lisp
(defvar my-compile-eval-after-form
'(progn (my-compile-setup))
"*Form executed when file is loaded.")

;;  Install it

(eval-after-load "compile" my-compile-eval-after-form)

;;  Define my function to handle this

(defun my-compile-setup ()
"Installs new regexps to compilation-error-regexp-alist"

;;  first save the original, defvar executes only once

(defvar my-compilation-error-regexp-alist
compilation-error-regexp-alist
"Copy.")

;;  Reset to default, we modify this later

(setq compilation-error-regexp-alist
my-compilation-error-regexp-alist)

;;  now we can experiment as much as we like by changing
;;  contents of these statements

(setq compilation-error-regexp-alist ; SGI's cc warning message
(cons
;; IAR C Compiler: "can.c":390  G
'("n"\(.*\)":\([0-9]+\) +.*$" 1 2)
compilation-error-regexp-alist)))
#+end_src

Now, there is much more code involved here, but it is more portable. Remember the rule: space is cheap, ease of use comes first. Now you can also delete the entry easily from the eval-after-form.
翻译:现在这里涉及的代码更多了，但它更便携。记住这个规则：空间很便宜，易用性最重要。现在你也可以轻松地从eval-after-form中删除条目。

#+begin_src emacs-lisp
(defun my-delete-eval-after-form (file form)
"Deletes FORM for FILE form `eval-after-load-alist'"
(delete form (assoc file after-load-alist)))

;; Remove my installation

(my-delete-eval-after-form "compile" my-compile-eval-after-form)
#+end_src

** 10.3 Putting lambdas into hooks

The same lambda talk applies to global-set-key and add-hook cases It's much cleaner to have function than the lambda. If you post the solution, people will appreciate function more than lambda solution. Let's try it this way first:
翻译:全局键绑定和add-hook情况下的lambda用法也是一样的。使用函数而不是lambda会使代码更加简洁。如果您发布了解决方案，人们会更欣赏函数解决方案而不是lambda解决方案。我们首先试试这种方式：

#+begin_src emacs-lisp
(add-hook 'write-file-hooks
'(lambda ()
"My checkings"
(save-excursion
(goto-char (point-min))
(if (re-search-forward ....)
.. do something fancy
.. else))))
#+end_src

Two obvious notes raise immediately: a) the indentation is disturbing, and limits more complex programming b) how do you use remove-hook for this ? Not very nice job... Turn this into a function and you're back to clear waters.
翻译:两个明显的问题立即浮现出来：a）缩进令人困扰，限制了更复杂的编程；b）您是如何使用remove-hook来做到这一点的呢？这不是一件很漂亮的工作……将其转换为一个函数，您就又回到了清澈的水域。

#+begin_src emacs-lisp
(add-hook 'write-file-hooks 'my-write-file-hooks)

(defun my-write-file-hooks ()
.. whatever)
#+end_src

Advantages: no more lambda, no more indentation problems, you can use remove-hook easily, and you can print the hook contents nicely with the following. If there were lambdas, the output wouldn't be so nice.
翻译:优点：不再需要lambda表达式，无需担心缩进问题，可以轻松使用remove-hook函数，并且可以使用以下代码漂亮地打印出钩子的内容。如果有lambda表达式，输出就不会这么美观了。

(Be in scratch buffer, make sure lisp-mode is on, write the variable and Hit the C-u .. keys behind a variable)
翻译:在刮板缓冲区中，确保打开了Lisp模式，编写变量，然后在变量后面按C-u键。

#+begin_example
write-file-hooks C-u C-x C-e
#+end_example

[Vladimir] For short functions to put in hooks/define-keys, I prefer to put the function like below. Then I can remove-hook it if I need, or re-eval the above to redefine the function, and whatnot.
翻译:[弗拉基米尔] 对于短函数，我更喜欢像下面这样放在钩子/定义键中。如果需要，我可以移除hook，或者重新评估上面的代码来重定义函数等等。

#+begin_src emacs-lisp
;; Defun returns the symbol just defined: the function name
;;
(add-hook 'write-file-hooks
(defun my-write-file-hooks ()
.. whatever))
;; End
#+end_src

--------------------------------------------------------------------------------------------------------------

* 11.0 Keeping your code organised

** 11.1 Use function separation dash lines

If you have loaded lisp packages from the net, you probably see many functions that are there "as is". Instead of just coding them there, you can ease the visibility of the functions by adding separator line before every function.
翻译:如果你从网上加载了Lisp包，你可能会发现很多“原封不动”存在的函数。而无需仅仅将它们编码在那里，你可以在每个函数前添加分隔行来简化这些函数的可视性。

Traditional:
翻译:你是一个很好的翻译助手，请把我的非中文文字翻译成中文。在翻译时要保留原文的格式，同时不要进行不必要的发挥。"

#+begin_src emacs-lisp
(defun my-func1 ()
(let* (...)
(save-excursion
..)))

(defun my-func2 ()
(let* (...)
(save-excursion
..)))
#+end_src

More visible choice:
翻译:更明显的选项：

#+begin_src emacs-lisp
;;; ---------------------------------------------------------
;;;
(defun my-func1 ()
(let* (...)
(save-excursion
..)))

;;; ---------------------------------------------------------
;;;
(defun my-func2 ()
(let* (...)
(save-excursion
..)))
#+end_src

The comments use ";;;", although ";;" would suffice when the comment is outside of function body. According to lisp commenting rules the ";;" would have parked to the left hand too. The reason is that, when every comment outside of function has ";;;", I can grep my files for "outside" comments. The ";;" style I leave to function bodies.
翻译:评论使用了“;;;”，尽管在函数体外部使用“;;”就足够了。根据Lisp注释规则，“;;”也会停在左边。原因是，当我为所有函数外的注释都加上“;;;”时，我就可以通过grep命令来搜索这些“外部”注释。“;;”这种风格我留给了函数体内。

Few packages which might interest you, they all keep your code better organised.
翻译:以下是一些可能会引起您兴趣的包，它们都能更好地组织您的代码。

+ folding.el Included in latest XEmacs uses folders {{{ }}}
翻译:XEmacs最新版本包含了文件夹功能{{{}}}

+ tinybookmark.el (b)ook(m)ark package "straight lines with names" provides also X-popup for bookmarks
翻译:小书签（.el）书签包（bookmarks）"带有名称的直线"还提供了X-popup用于书签

+ imenu.el finding specific funtion, more detailed control.  Included in Emacs and XEmacs
翻译:`imenu.el` 提供了查找特定函数的功能以及更详细控制。它包含在 Emacs 和 XEmacs 中。

** 11.2 Add autoload statements

When you're making a package, don't forget to include those important autoload directives to key functions. If your package is expected to be put through the emacs build process when update-file-autoloads will add your autoloads to loaddefs.el, and subsequent dumping of that file with emacs will make them a permanent part of the emacs executable. (Usually loaddefs.el is dumped, so simply updating it and bytecompiling it won't cause it to be loaded at startup time.) Some sysadm may decide to keep your packages permanently in his emacs installation and he can rip the autoloads from your file with M-x generate-file-autoloads (function is defined in autoload.el).
翻译:在打包包的时候，别忘了包含那些指向关键函数的重要自动加载指令。如果您的包预期会在更新文件自动加载（update-file-autoloads）过程中通过emacs构建过程，那么它会将您的自动加载项添加到loaddefs.el中，并且随后的emacs执行文件的dump操作会使它们成为emacs可执行程序的一部分。（通常情况下，会dump loaddefs.el文件，所以仅仅更新它并对其进行字节编译并不会导致它在启动时被加载。）一些系统管理员可能会决定永久性地在他的emacs安装中保留您的包，他可以使用M-x生成文件自动加载（generate-file-autoloads）（该功能定义在autoload.el中）从您的文件中提取自动加载项。

#+begin_src emacs-lisp
;;;###autoload
(defun my-func ()
#+end_src

--------------------------------------------------------------------------------------------------------------

* 12.0 About lisp symbol naming

Common idiom in lisp programs has been that the names contain only [-a-zA-Z] characters and so case chosen isn't generally mixed: My-Var is bad variable name. Also the traditional package definition convention has been:
翻译:在Lisp程序中常见的惯例是变量名只包含[-a-zA-Z]字符，因此通常不混合大小写：My-Var是一个不好的变量名。此外，传统的包定义约定通常是：

#+begin_src emacs-lisp
(defun  csh-mode-yyy ...
(defvar csh-mode-xxx ...
#+end_src

Here the first 'words' always specifies the package that is using the name space bucket, here csh-mode.  Remember that symbol names are put to global name space, so each function and each variable must be unique.
翻译:在这里，“words”的第一个总是指定使用名称空间的包，这里是csh-mode。记住符号名会被放入全局名称空间中，所以每个函数和每个变量都必须是唯一的。

** 12.1 Don't use your initials

In comp.lang.emacs, comp.emacs.xemacs and gnu.emacs.help where people are likely to post their own solution to other peoples, it seems that only few are aware of how they should name their symbols properly. The problem is that if you post code that has function name:
翻译:在comp.lang.emacs、comp.emacs.xemacs和gnu.emacs.help这些论坛上，人们可能会发布自己解决其他人的问题的方法，但似乎只有少数人意识到他们应该如何正确地命名自己的符号。问题是，如果你发布的代码中函数名是：
#+begin_example
fill-matched
#+end_example

How do you know afterwards (when you just grab the code and save it somewhere in your .emacs or personal "snippet" lib) when you start writing code using that function, that it wasn't a Emacs distributed function or variable?
翻译:在之后（当你只是复制代码并将其保存到你的.emacs或个人“片段”库中的某个地方）开始使用该函数编写代码时，您如何知道它不是Emacs分发的函数或变量？

The problem arises too, if you name the functions so, that they start with your initials:
翻译:如果你给函数起的名字以你的首字母开头，问题就会出现：
#+begin_example
joe-fill-matched
#+end_example

Now, what's wrong with that? Well, if you're going to post such code that have lot's of functions and variables starting with prefix joe- , people get upset when they save the functions and notice that there is someone other's initials involved. They just wanted to have some general function to solve current task.
翻译:现在，那里面有什么问题呢？嗯，如果你要发布这样的代码，其中有很多以joe-为前缀的函数和变量，当人们保存这些函数并注意到有其他人的首字母涉及时，他们会感到不安。他们只是想要一些通用的函数来解决当前的任务。

Now, when they ask help again, someone else posts his own functions and they end up gathering functions:
翻译:现在，当他们再次寻求帮助时，其他人会发布自己的函数，最终他们开始收集函数：
#+begin_example
joe-funcs ..
mike-funcs ..
bill-funcs ..
#+end_example

Putting those into .emacs doesn't look pretty.
翻译:将这些内容放入`.emacs`文件中看起来不太美观。

** 12.2 Use prefix my for private symbols

It becomes obvious that it would be nice if everybody would use common naming convention, so that the code can be handed to anybody without changes. The best way to achieve this is that people use prefix:
翻译:很明显，如果每个人都使用通用的命名约定，那么就可以不加修改地将代码交给任何人了。实现这一点的最佳方式是人们使用前缀：

#+begin_example
my-
#+end_example

To denote everything that they own: own variables own functions, maps.. Now it's very simple to post that code to someone else, and believe me everybody is happy when they receive good and clean code without someone else's initial involved. They feel that it's "my" code too, to solve "my" problems.
翻译:表示他们拥有的一切：私有变量、私有函数、映射……现在非常简单地将这段代码发布给其他人，相信我，当人们收到没有他人最初介入的良好且干净的代码时，他们会感到非常高兴。他们会觉得这也是“我的”代码，用来解决“我的”问题。

To extend this naming more, people should also use convention:
翻译:要进一步扩展这种命名方式，人们还应该遵循惯例：

#+begin_example
my-csh-mode-do-this...
#+end_example

If it has anything to do with the csh-mode.el, so in general add the word my- + possible LIB-ID if you write some special functions for elisp packages. This way you can easily find all functions related to "csh-" package with describe-symbol function (available in tinyliby.el ), including your own.
翻译:如果它与csh-mode.el有关，那么通常在你为elisp包编写一些特殊函数时，在前面加上单词my-以及可能的LIB-ID。这样你就可以很容易地找到所有与"csh-"包相关的函数，包括你自己的，使用describe-symbol函数（在tinyliby.el中可用）。

** 12.3 Naming variables differently?

There is still a matter of style with the variable naming. While it is possible to program like the "lisp" way, that may not be the best bet. In Emacs Lisp, variable and function names do not need to differ in any way, so it's perfectly legal to have same name for a variable and for a function and for a keymap and .. you name it.
翻译:关于变量命名风格仍有一事需要注意。虽然可以像“Lisp”那样进行编程，但这可能并非最佳选择。在Emacs Lisp中，变量和函数名称之间无需有任何区别，因此拥有与变量、函数、键映射相同的名称是完全合法的……你想得到的名字都可以。

#+begin_src emacs-lisp
(defun  csh-mode ()
...)

(defvar csh-mode nil
"Mode on/off variable")
#+end_src

This is both a good and a bad idea. The good part of it is, that when you're working with MODES or KEYMAPS, it's very desirable to have same name, so that you know what's going on in the code.
翻译:这个想法既有好处也有坏处。好的方面是，当你在使用MODES或KEYMAPS时，希望名称相同是非常有利的，这样你就知道代码中发生了什么。

But in the other hand, if you're not using modes, the naming convention is .. hmpf, confusing. In practical terms it's lot more easier to look at the code if the symbol itself denotes the CLASS where it belongs. If everything looks the same, as lisp does due to its nature, it would be welcomed if there were something that separate variables from function elements.
翻译:但是另一方面，如果您不使用模式，命名约定是……嗯哼，令人困惑。在实践中，如果符号本身表示它所属的类，那么查看代码要容易得多。如果一切都看起来一样，正如Lisp由于其本质所呈现的那样，如果有某种方法可以区分变量和函数元素，那就好了。

** 12.4 Separate naming of variables

In Tiny Tools you have seen another convention. Some has said that it "looks ugly", "I don't like it", and admittedly it can give that impression to the reader of the code.
翻译:在Tiny Tools中，您看到了另一种约定。有些人说它“看起来很丑”，“我不喜欢它”，诚然，这会给代码的读者留下那种印象。

But managing lisp code gets complicated and hard to maintain if you don't develop some aids. A different symbol naming according to their CLASSES does help to read my code better and help maintainer to see where the variables are and where the functions are. Here is one possibility:
翻译:如果你不开发一些辅助工具，管理lisp代码会变得复杂且难以维护。根据它们的类别使用不同的符号命名确实有助于更好地阅读我的代码，并帮助维护者看到变量在哪里以及函数在哪里。这里有一个可能性：

#+begin_src emacs-lisp
(defun my-function () ..
(defvar my-:variable 100)
#+end_src

There is another benefit from this: it is now possible to grep all symbols referring to variables, and there is no false hits, It is also posisble to run a program to do the name replacement and it succeeds 100%.  Variables fromcan be searched from the buffer by give my-: prefix to search engine. All in all, navigating in lisp code is much more easier.
翻译:从这还有另一个好处：现在可以搜索所有引用变量的符号，而且不会有误报。还可能运行一个程序来完成名称替换，并且成功率达到了100%。可以通过给搜索引擎加上my-:前缀来在缓冲区中搜索来自 的变量。总的来说，浏览lisp代码要容易得多。

Have you ever tried to complete the lisp symbols? It's lot nicer when you car write my-: prefix and hit lisp-complete-symbol command to give you listing of all variables. No false hits concerning functions.
翻译:您是否曾经尝试过完成Lisp符号？当您输入my-：前缀并按下lisp-complete-symbol命令以获取所有变量的列表时，它会变得非常好用。不会有关于函数的错误提示。

Why ":" ? Well, that is familiar to a C++ and Perl programmer and The ':' character seems neutral and visible enough to be used in the code.
翻译:为什么使用“:”？嗯，这对C++和Perl程序员来说很熟悉，“:”字符在代码中似乎足够中立且可见。

There are also alternative choices, like using "--", double dash to denote variables:
翻译:也有其他选择，比如使用"--"双短横线来表示变量：

#+begin_src emacs-lisp
(defconst my--var1 "some" "*tmp var")
(defconst my--var2 "some" "*tmp var")
(defconst my--var3 "some" "*tmp var")
#+end_src

Note: The colon character is by default in the same syntax class as the dash, so your lisp commands like backward-sexp work as usual. You can verify this with commands
翻译:你是一个好用的翻译助手，请将我的非中文文字翻译成中文!注意翻译时保持源文本格式不变，另外不要做无畏的演绎！":"

注意：冒号默认与破折号属于同一语法类别，所以你的lisp命令如backward-sexp仍按常规工作。你可以用命令来验证这一点

#+begin_src emacs-lisp
(char-to-string (char-syntax ?:)) and
(char-to-string (char-syntax ?-)) in lisp-mode.
#+end_src

--------------------------------------------------------------------------------------------------------------

* 13.0 Lisp code notes

** 13.1 Call-interactively

#+begin_example
> If I define a kbd macro, and then name it `say-hi', and I
> make the kbd
> macro map to the letters "HI", then that macro is a command.
>
> (defalias 'say-hi (read-kbd-macro "HI"))
>
> should end up being interactive. In fact, the expression:
> (commandp 'say-hi)
>
> evals to TRUE.
#+end_example

Hrvoje Niksic [[mailto:hniksic@srce.hr][hniksic@srce.hr]], comp.emacs.xemacs, 13 Apr 1997
翻译:赫沃耶·尼基西奇[[<mailto:hniksic@srce.hr>][hniksic@srce.hr]comp.emacs.xemacs, 1997年4月13日

It is, but for a different reason. commandp returns t for interactive compiled functions, interactive lambda expressions, autoloads with fourth argument non-nil and *string and vectors*.
翻译:但是原因不同。commandp 函数对于交互式编译函数、交互式lambda表达式、带第四个参数非nil的自载函数以及*string和向量*返回t值。

#+begin_src emacs-lisp
(commandp [some vector])
#+end_src

yields t not because [some vector] is a valid command, but because it can be callable through execute-kbd-macro or such. Documentation for commandp never guarantees that you'll be able to call-interactively the objects it blesses with t.
翻译:产生t的原因并不是因为[some vector]是一个有效的命令，而是因为它可以通过execute-kbd-macro之类的函数进行调用。commandp的文档从未保证你能够通过交互式地调用它所赋予t的对象。

#+begin_example
> The error is when I do this:
> (call-interactively 'say-hi)
> I get :
> wrong type of argument: commandp, say-hi
#+end_example

That is only a lousy-stated error message. You can call macros with execute-kbd-macro.
翻译:这是一个表述不清的错误信息。你可以使用execute-kbd-macro来调用宏。

#+begin_src emacs-lisp
(defun maybe-macro-call-interactively (def &rest junk)
"If DEF is a keyboard macro, execute it, else execute
it as a command."
(if (and (symbolp def)
(or (vectorp (symbol-function def))
(stringp (symbol-function def))))
;; looks like a macro
(execute-kbd-macro def)
;; else just proceed to call-interactively
(call-interactively def)))
;; End
#+end_src

** 13.2 Condition-case vs. unwind-protect ?

Steven L Baur [[mailto:steve@miranova.com][steve@miranova.com]]
翻译:史蒂文·L·鲍尔 [通过电子邮件联系 steve@miranova.com](mailto:steve@miranova.com)。

unwind-protect executes the clean up forms whenever the stack is unwound by either a throw (non-local exit), or by a signal (error condition). Condition-case handles only the error condition and can be bypassed by a non-local exit.
翻译:异常保护（unwind-protect）会在堆栈通过抛出（非本地退出）或信号（错误条件）进行 unwind 时执行清理操作。条件案例（condition-case）仅处理错误条件，并且可以通过非本地退出来绕过。

Here's some sample code that illustrates the differences: (tested on Emacs 19.34 and XEmacs 19.15)
翻译:以下是一些示例代码，展示了这些差异： （在Emacs 19.34和XEmacs 19.15上测试）

#+begin_src emacs-lisp
(defun test-func (foo)
"Test Function."
(cond (foo (throw 'some-random-condition "Return Result"))
(t (signal 'error "some-data"))))
;; end

(defun wrapper-1 (foo)
"Wrapper for test function."
(catch 'some-random-condition
(condition-case err
(test-func foo)
(error (message "Caught Error Condition")))))
;; End

(defun wrapper-2 (foo)
"Wrapper for test function."
(catch 'some-random-condition
(unwind-protect
(test-func foo)
(message "Caught Error Condition"))))
;; End
#+end_src

If you call (wrapper-1 t), the "Caught Error..." message is never executed, but if you call (wrapper-2 t) it will be.
翻译:如果您调用(wrapper-1 t)，则永远不会执行“Caught Error...”消息，但如果您调用(wrapper-2 t)，它将会被执行。

In the error signaling case, (wrapper-1 nil) will cause the error to be caught and never signalled up.  Unwind-protect (wrapper-2 nil), the error condition does get propagated up. Since this appears to be what you want anyway, use unwind-protect.
翻译:在错误信号的情况下，（包裹-1 nil）会导致错误被捕获并永远不会向上传递。而使用 unwind-protect（包裹-2 nil），错误条件确实会被传播上去。既然这看起来正是您想要的，那么请使用 unwind-protect。

I hope that makes it a little clearer.
翻译:我希望这样能使其更清晰一些。

** 13.3 Dolist

The dolist command loops through a list and it is defined int the cl package; you can stop the loop with return command. Below you see example and the expansion with cl-prettyexpand.
翻译:`dolist`命令遍历一个列表，它在`cl`包中定义；你可以使用`return`命令停止循环。下面是示例以及与`cl-prettyexpand`的结合使用。

#+begin_src emacs-lisp
(dolist (elt '(1 2))
(if (eq elt 1)
(return)))        ;Stop the list loop now

(block nil
(let ((--dolist-temp--1090818 '(1 2))
elt)
(while --dolist-temp--1090818
(setq elt (car --dolist-temp--1090818))
(if (eq elt 1) (cl-block-throw '--cl-block-nil-- nil))
(setq --dolist-temp--1090818 (cdr --dolist-temp--1090818)))
nil))
#+end_src

macroexpand to find out the real expansion
翻译:展开宏以找到其实际扩展

#+begin_src emacs-lisp
(cl-block-wrapper
(catch (quote --cl-block-nil--)
(let ((--dolist-temp--1090818 (quote (1 2))) elt)
(while --dolist-temp--1090818
(setq elt (car --dolist-temp--1090818))
(if (eq elt 1)
(cl-block-throw (quote --cl-block-nil--) nil))
(setq --dolist-temp--1090818 (cdr --dolist-temp--1090818)))
nil)))
#+end_src

Dave Gillespie [[mailto:daveg@thymus.synaptics.com][daveg@thymus.synaptics.com]] comments:
翻译:戴夫·吉尔espie[[通过电子邮件联系：daveg@thymus.synaptics.com][daveg@thymus.synaptics.com]]评论说：

Common Lisp loops use the Common Lisp block mechanism, not the catch mechanism. The Emacs CL package implements block in terms of catch, but there is a catch, so to speak.
翻译:常见的Lisp循环使用的是Common Lisp的块机制，而不是捕获机制。Emacs CL包用捕获来实现块，但这里有一个“捕获”，也就是说。

The CL package treats block specially in order to optimize it. Catch blocks are expensive at run-time, so I wanted to make sure the compiler could eliminate them when the body code didn't actually call return. (This is especially important since many Common Lisp constructs include implicit blocks whether you use those blocks or not.)
翻译:CL包特别对待block以优化它。捕获块在运行时开销很大，所以我希望编译器能够在实际代码中没有调用return的情况下消除它们。(这尤其重要，因为许多Common Lisp构造包括显式的块，无论您是否使用这些块。)

There were technical reasons, which I don't remember exactly, why the optimization was best done in the compiler itself instead of in the block macro. Therefore, the CL package has some hacks to modify or delay the expansion of block under certain circumstances. But this will always be invisible unless you deliberately peek at the macro expansions. If you actually try using return or return-from in your code, you will find that it works properly.
翻译:有技术原因，我不记得具体是什么了，为什么优化最好在编译器本身中进行，而不是在块宏中。因此，CL包有一些hack来修改或延迟在某些情况下块的展开。但是，除非你故意查看宏展开，否则这总是不可见的。如果你真的尝试在你的代码中使用return或return-from，你会发现它正常工作。

** 13.4 Narrow-to-region – don't use it always

The narrow-to-region lisp form is great if you create functions that should do their job in restricted area.  Say:
翻译:如果你创建的函数应该在受限区域内执行任务，那么使用窄域LISP形式是非常好的。比如说：

#+begin_src emacs-lisp
(defun my-find-a-region-1 (beg end)
"Find something from region BEG and END"
(interactive "r")
(let* ((i  0))
(save-restriction
(narrow-to-region beg end)
(PMIN)
(while (re-search-forward "a" nil t)
(inc i)))
(message "%d"  i)))
;; End
#+end_src

There is also another way to write this function by not using the narrow at all. I would prefer this another alternative and avoid the narrow, because you can take advantage of the END parameter of re-search-forward.
翻译:还有一种不用narrow的方式来实现这个功能。我更倾向于这种替代方案，并避免使用narrow，因为你可以利用re-search-forward的END参数。

#+begin_src emacs-lisp
(defun my-find-a-region-2 (beg end)
"Find something from region BEG and END"
(interactive "r")
(let* ((i  0))
(save-excursion
(goto-char beg)
(while (re-search-forward "a" end t)
(inc i)))
(message "%d"  i)))
;; End
#+end_src

** 13.5 Obarray: length and efficiency

[Jamie Zawinski [[mailto:jwz@netscape.com][jwz@netscape.com]]] ...A vector of length 0 can't be used as an obarray. And for performance reasons, an obarray should have a length which is prime, and which is roughly the size of the number of elements you're going to put into it; The larger the ratio of elements/length, the more time lookups will take.
翻译:[Jamie Zawinski [mailto:jwz@netscape.com][jwz@netscape.com]] ...一个长度为0的向量不能用作obarray。而且出于性能原因，obarray的长度应该是质数，并且大致等于你要放入其中的元素数量；元素与长度的比例越大，查找所需的时间就越长。
--------------------------------------------------------------------------------------------------------------

* 14.0 Optimizing and byte compiler tips

** 14.1 Use eq instead of =

[24 Jan 1996, [[mailto:terra@diku.dk][terra@diku.dk]] (Morten Welinder)] If you're not an Emacs wizzard you should skip these patches for now. You may benefit later. I have discovered that lots of Emacs Lisp code uses equal and = where they could have used eq or even null.
翻译:1996年1月24日，[[mailto:terra@diku.dk][terra@diku.dk]]（莫滕·韦尔INDER）如果你不是一个emacs的高手，你现在应该跳过这些补丁。你可能以后会从中受益。我发现很多emacs lisp代码使用了equal和=，而他们本可以使用eq或者甚至是null。

+ `equal' is slow and uses a function call.
翻译:"等于" 慢且使用了函数调用。
+ `='     is fair but does unnecessary check if we can decide in advance that the arguments are integers.
翻译:`=` 是公平的，但是如果我们提前可以决定参数是整数的话，它就不必要地进行检查了。
+ `eq'    is almost as fast as...
翻译:"eq" 几乎和 ... 一样快。
+ `null'  ...which is best.
翻译:`null'是最好的。

Examples. Often you see something like these expressions:
翻译:例子。通常你会看到这样的表达：

#+begin_src emacs-lisp
(= (point) (point-min))
(equal 'foo bar)
(assoc 'foo bar)
(equal (current-buffer) buf)
(eq arg nil)
#+end_src

which from a functional (and style) point of view are perfectly ok. But they're not as efficient as they could be. The ones below are better because they use the available type information about the arguments.
翻译:从功能（和风格）角度来看，这些都是完全可以接受的。但是它们并没有发挥出应有的效率。下面的例子更好，因为它们使用了关于参数的可用的类型信息。

#+begin_src emacs-lisp
(eq (point) (point-min))
(eq 'foo bar)
(assq 'foo bar)
(eq (current-buffer) buf)
(null arg)
#+end_src

** 14.2 About setq and set

Simon Marshall [[mailto:Simon.Marshall@esrin.esa.it][Simon.Marshall@esrin.esa.it]] Jan 1997 in gnu.emacs.help mentined that ...One difference not mentioned is that they are byte-compiled differently. I think
翻译:西蒙·马歇尔[[mailto:Simon.Marshall@esrin.esa.it][Simon.Marshall@esrin.esa.it]]在1997年1月的gnu.emacs.help中提到……一个没有被提到的区别是它们被字节编译的方式不同。我认为

#+begin_src emacs-lisp
(setq fubar foo)
#+end_src

results in faster byte-code than
翻译:导致字节码更快

#+begin_src emacs-lisp
(set 'fubar bar).
#+end_src

** 14.3 About let in Emacs

[Hrvoje Niksic [[mailto:hniksic@srce.hr][hniksic@srce.hr]] 1998-03-13 XE-L]
翻译:赫沃耶·尼基西奇[[<mailto:hniksic@srce.hr>hniksic@srce.hr]]1998-03-13XE-L]。

#+begin_src emacs-lisp
(setq global 2)
(setq real-global 3)
(let (global)
(setq global 4)
(setq real-global 5))
global
==> 3
#+end_src

...`let' sets up an unwind-protect that remembers the old value (2), and places the new value to the symbol value slot (nil in this case). When you assign 4 to global, it's written to its value slot, overriding nil.  When let is left, the internal unwind-protect restores the old value (2).
翻译:“让”设置了撤销保护，记住旧值（2），并将新值放置到符号值槽中（在这种情况下为nil）。当你将4赋值给全局变量时，它被写入其值槽中，覆盖了nil。当离开“let”时，内部的撤销保护恢复了旧值（2）。

This is one of the reasons why let is extremely slow in Emacs Lisp.
翻译:这是为什么让Emacs Lisp非常慢的一个原因

** 14.4 Make lambda to run code faster

This all is actually explained well in the Emacs lisp pages, but let's refresh memory a bit. Let's start with the traditional example:
翻译:这已经在Emacs Lisp页面上解释得很清楚了，但让我们稍微复习一下。让我们从一个传统的例子开始：

#+begin_src emacs-lisp
(mapcar '(lambda (x) ... )   list)
#+end_src

The lisp manual page in says that "(elisp, Node: Anonymous Functions) ...Lisp compiler cannot assume this list is a function, even though it looks like one". So, we have to help byte compiler by adding function directive.
翻译:在lisp的手册页中提到，“(elisp, 节点：匿名函数) … Lisp编译器不能假设这个列表是一个函数，尽管它看起来像是一个”。因此，我们需要通过添加函数指令来帮助字节编译器。

#+begin_src emacs-lisp
(mapcar (function (lambda (x) ... )   list)
#+end_src

Which, when compiled probably speeds the code by factor 2 or more. One compatibility not to this: in Emacs 19.29 and up you can actually write like this, which is exactly the same as the using the function syntax.
翻译:编译后可能使代码速度提高两倍或更多。与此兼容性不符的是：在Emacs 19.29及更高版本中，您实际上可以这样做，这与使用函数语法完全相同。

#+begin_src emacs-lisp
(mapcar (lambda (x) ... )   list)
#+end_src

** 14.5 Deleting and inserting in buffer is slow

[Jerry Quinn [[mailto:jquinn@nortel.ca][jquinn@nortel.ca]]] ...I used to dump data to buffer and then moving to a column, making various changes with insert and delete-char and moving on to the next change. It would take about 22 seconds on my system
翻译:[杰里·奎因 [[mailto:jquinn@nortel.ca][jquinn@nortel.ca]]] …我过去常常先将数据存入缓冲区，然后移动到一列，通过插入和删除字符以及进行下一步更改。在我的系统上大约需要22秒。

I now collect the message data into lists with regexps erase the buffer and dump the new results in with format. This is MUCH faster. (3sec compared to previous 22sec)
翻译:我现在使用正则表达式收集消息数据到列表中，清除缓冲区，并以新的格式写入结果。这要快得多。（之前需要22秒，现在只需要3秒）

** 14.6 Byte compiler options

18 Sep 1996, Andreas Schwab [[mailto:schwab@issan.informatik.uni-dortmund.de][schwab@issan.informatik.uni-dortmund.de]] answered to question below
翻译:1996年9月18日，安德烈亚斯·施瓦布[[mailto:schwab@issan.informatik.uni-dortmund.de][schwab@issan.informatik.uni-dortmund.de]]回答了以下问题

#+begin_example
> (defalias 'pair (symbol-function 'cons))
> (defalias 'pairp (symbol-function 'consp))
>
> The trouble is that the byte-compiler doesn't optimize a
> call to e.g. pair as it would do with a call to cons
> because it doesn't recognize pair as an alias for cons.
>
> Is there a way to tell the byte-compiler to treat
> pair the same way as cons?

(byte-defop-compiler '(pair byte-cons) 2)
(byte-defop-compiler '(pairp byte-consp) 1)
#+end_example

** 14.7 Byte compiler warnings – how to get rid of them

19 Feb 1996, [[mailto:andersl@csd.uu.se][andersl@csd.uu.se]] (Anders Lindgren)
翻译:1996年2月19日，[发送邮件给andersl@csd.uu.se](mailto:andersl@csd.uu.se)（安德斯·林德格伦）

#+begin_example
> If you have code that depends on a library that is not
> always included in a program (be it Emacs Lisp or other
> Lisp), the correct way to insure that it's compiled
> properly is to do the require. It's not overkill; after
> all, a user presumably will only compile it once. And >
> it may save you from interactions that you cannot predict
> now, e.g., when at some future time when you change your
> package or font-lock changes in a future revision of
> Emacs.
#+end_example

Genrally this is a good idea. Unfortualtely, when it comes to font-lock it's not. It contains a check that it is runed under a window system, and barfs at load-time if it's not. This makes it impossibel to require the package when compiling in batch mode or on a system without a window system.
翻译:一般来说这是个不错的主意。不幸的是，当涉及到font-lock时并非如此。它包含了一个检查，以确定它是在窗口系统下运行的，如果在加载时不是的话就会出错。这使得在批处理模式下编译或在没有窗口系统的系统上要求使用该包变得不可能。

I have been using a (very ugly) method where I replace statements by equivalent statements which doesn't raise the anger of the compiler:
翻译:我一直在使用一种（非常丑陋）的方法，通过替换等效语句来避免编译器的愤怒：

#+begin_example
foo              == (symbol-value 'foo)
(setq foo ...)   == (set 'foo ...)
== (funcall (symbol-funtion 'set) 'foo ...)
(The former fools the Emacs compile but not
the XEmacs'. The latter fools both.)
(foo ...)        == (funcall (symbol-function 'foo) ...)
#+end_example

This type of coding is specially useful when writing programs which should be able to run (and compile) under both under Emacs and XEmacs. – Anders
翻译:这种编码方式在编写既能在Emacs下运行（也能编译）又能在XEmacs下运行的程序时特别有用。- 安德斯

** 14.8 Inlining and byte compiler

The byte compiler is quite powerfull, but there is only handfull of people who really understand how its features can be exploited in full. Here is couple of suggestions how you could force some function to be inlined and thus save the function call, which in emacs is quite expensive (see the profiling results later and examine eg. mapcar)
翻译:字节编译器非常强大，但真正理解如何充分利用其功能的人却寥寥无几。这里有一些建议，可以帮助您迫使某些函数被内联，从而节省函数调用的开销（在emacs中，函数调用相当昂贵，稍后请参阅分析结果并检查例如mapcar之类的示例）。

Notice that
翻译:请注意

#+begin_example
defsubst --> Byte Compiler inlines the function automatically.
#+end_example

But in case of func beeing a regular 'defun' you want to use special form inline to force inlining the code.
翻译:但是，如果func是一个普通的'defun'，您想使用特殊形式inline来强制内联代码。

#+begin_src emacs-lisp
(defun func (arg)
(if arg t nil))

(defun my (x)
(inline (func xx)))
#+end_src

See what we got:
翻译:我们得到了什么？

#+begin_src emacs-lisp
;; You do not need this: (byte-compile 'my)
;; because disassemble does it for you
;;
(disassemble  'my)
#+end_src

#+begin_example
byte code for my:
args: (x)
0       varref    xx
1       dup
2       varbind   arg
3       goto-if-nil 1
6       constant  t
7       goto      2
10:1    constant  nil
11:2    unbind    1
12      return
#+end_example

As you saw; the func was open coded inside function my. Here is reminder from the byte compiler page:
翻译:如您所见；函数my中的func是公开编码的。以下是字节编译器页面上的提醒：

You can also open-code one particular call to a function without open-coding all calls. Use the 'inline' form to do this, like so:
翻译:您也可以只打开一个函数调用的代码，而不必打开所有的调用代码。使用“内联”形式来实现这一点，如下所示：

#+begin_src emacs-lisp
(inline (foo 1 2 3))    ;; `foo' will be open-coded
(inline                 ;;  `foo' and `baz' will be
(foo 1 2 3 (bar 5))    ;; open-coded, but `bar' will not.
(baz 0))
#+end_src

You can make a given function be inline even if it has already been defined with defun by using the proclaim-inline form like so:
翻译:你可以使用proclaim-inline形式，如下所示，使已定义的函数成为内联函数，即使它已经用defun定义过：

#+begin_src emacs-lisp
(proclaim-inline my-function)
#+end_src

This is, in fact, exactly what defsubst does. To make a function no longer be inline, you must use proclaim-notinline. Beware that if you define a function with defsubst and later redefine it with defun, it will still be open-coded until you use proclaim-notinline.
翻译:实际上，这正是defsubst的作用。为了让一个函数不再内联，你必须使用proclaim-notinline。请注意，如果你用defsubst定义了一个函数，然后又用defun重新定义它，直到你使用了proclaim-notinline，它仍然会被展开直接编码。

** 14.9 Inlining an interactive function, danger ahead

[Moral: do not make interactive functions defsubst] [Sample test file available: test-defsubst.el]
翻译:[道德：不要使用defsubst制作交互式函数] [样例测试文件可用：test-defsubst.el]。

When I was converting some very small functions from defun to defsubst, I run in to this observation. I was wondering what inlining would do to functions that had interactive spec. Below the terms IACT refers to functon that has interactive spec; Here is th epseudo code for two functions.
翻译:当我将一些非常小的函数从defun转换为defsubst时，我遇到了这个观察结果。我想知道内联会对具有交互式规范的函数产生什么影响。下面，“IACT”指的是具有交互式规范的函数；以下是两个函数的伪代码。

#+begin_example
defsubst fun1
IACT
iact-fun1-body

defun fun2
IACT
call fun1
body
;; end
#+end_example

Now, there is conflict, because when I byte compile fun2, we see
翻译:现在有冲突，因为当我字节编译fun2函数时，我们发现

#+begin_example
defun fun2
iact-fun1-body
body
;; end
#+end_example

Where the iact-fun1-body is copied "as is". And that was what I was afraid of. Because iact-fun1-body had (interactive-p) test, it gets inserted into wrong place and the whole construction isn't what I intended. Here are the results in case you're interested.
翻译:iact-fun1-body 直接复制过来。"这就是我担心的原因。因为 iact-fun1-body 有 (interactive-p) 测试，它被插入到了错误的位置，整个结构并不是我所期望的。如果你感兴趣的话，这里有结果。

#+begin_src emacs-lisp
(defsubst test (&optional arg)
(interactive "P")
(if (interactive-p) (message "Gotchya")))

(defun test2 (arg)
(interactive "P")
(test))

(test2 1)
--> nothing, this is okay
(call-interactively 'test2)
--> "Gotchya"        << SUPRISE! That wasn't meant to happen!
#+end_src

byte code for test2 reveals how the inlining happened.
翻译:测试2的字节码揭示了内联是如何发生的。

#+begin_example
args: (arg)
interactive: "P"
0       constant  nil
1       varbind   arg
2       interactive-p
3       goto-if-nil-else-pop 1
6       constant  message
7       constant  "Gotchya"
8       call      1
9:1     unbind    1
10      return
#+end_example

--------------------------------------------------------------------------------------------------------------

* 15.0 Profiling

** 15.1 Test envinronment

Here is collection of tests and results I made out of curiosity which way is better to code.
翻译:这是出于好奇心而进行的一系列测试和结果，以确定哪种编码方式更好。

+ All the functions were in NON-COMPILED form, because the compilation optimizes different structures to the same byte code. Due to quota limit reasons as well as for bug tracing, I usually only use non-compiled elisp pacakges.
翻译:所有的功能都以非编译形式存在，因为编译会将不同的结构优化为相同的字节码。由于配额限制的原因以及为了便于调试错误，我通常只使用非编译的emacs Lisp包。
+ elp.el v2.39
翻译:您提供的文本已经是中文了，因此不需要进行翻译。如果您有其他语言的文本需要翻译成中文或其他语言的需求，请随时告诉我。
+ Emacs 19.28
翻译:Emacs 19.28
+ HP-UX A.09.01 A 9000/715
翻译:惠普-Unix A.09.01 A 9000/715

** 15.2 Elp foreword

Note, that if you time the same functions you will get different absolute timings. Nevertheless, you should get same results about the fact that which one feels fastest. The values have been taken from the Elapsed row: IT DOES NOT REPRESENT EXACT TIME SPENT in the function, because time spent depends on of operating system and current load of the Unix machine.
翻译:请注意，如果您同时测量相同的功能，您可能会得到不同的绝对时间。然而，你应该得出相同的结论，即哪一个感觉最快。值是从Elapsed行中取出的：这并不代表函数实际花费的时间，因为所花费的时间取决于操作系统和Unix机器当前的负载情况。

Strong Note: [From elp.el, Barry Warsaw] Note that there are plenty of factors that could make the times reported unreliable, including the accuracy and granularity of your system clock, and the overhead spent in lisp calculating and recording the intervals. I figure the latter is pretty constant, so while the times may not be entirely accurate, I think they'll give you a good feel for the relative amount of work spent in the various lisp routines you are profiling. Note further that times are calculated using wall-clock time, so other system load will affect accuracy too.
翻译:重要提示：[来自elp.el，Barry Warsaw] 请注意，有许多因素可能导致报告的时间不可靠，包括您系统时钟的准确性和粒度，以及计算和记录间隔所花费的开销。我认为后者相当恒定，所以虽然时间可能并不完全准确，但我认为它们能很好地反映您正在分析的各种lisp例程所花费的工作量的相对比例。此外，请注意，时间是使用wall-clock时间计算的，因此其他系统负载也会影响准确性。

Keep in mind that some of the tests may be very stupid or misleading to experienced lisp programmer or to person who knows Emacs internals very well. My sincere intention has been pure curiosity. Please feel free to send any comments or corrections for the used tests cases if they are not representative enough. It is unfortunate if some test case presented here is totally bogus and someone reads it with good intention.
翻译:请注意，一些测试可能对于有经验的Lisp程序员或者非常了解Emacs内部机制的人来说是非常愚蠢或有误导性的。我真诚的意图纯粹是出于好奇心。如果您认为所使用的测试用例不够具有代表性，请随时发送任何评论或更正。如果这里展示的一些测试用例完全无效，而有人出于善意阅读它们，那真是太不幸了。

** 15.3 Using elp for timing – repeat test several times

The elp.el is great, but don't trust the first results. Sometimes the timings are totally different if you clear the list and run the tests again. Repeat your test cases at least 3 times before you derive conclusions about the performance.
翻译:这个elp.el很好用，但是不要相信第一次的结果。有时候如果你清除列表然后再次运行测试，时间可能会完全不同。在关于性能得出结论之前，至少重复你的测试案例三次。

In here, the harness count is mentioned; that means that the test has been repeated N times and that the most representative time values has been selected(usually average). Using elp, say 10 times to repeat the test and record the timing, should give you solid estimate what timings are right.
翻译:在这里提到了背带数量；这意味着测试已经重复了N次，并且选择了最具有代表性的时间值（通常是平均值）。使用elp，比如说重复测试10次并记录时间，应该能给你一个坚实的估计，知道哪些时间是正确的。

You can use the elp very easily via minor mode if you ftp lisp helper module: tinylisp.el. All the tests have been executed with that package in the following manner:
翻译:如果您想轻松地使用elisp助手模块tinylisp.el通过minor模式，请按照以下方式进行测试：已经执行了所有测试。

+ Draw region over test set, including all functions and the HARNESS case and narrow to it with C-x n n
翻译:在测试集上绘制区域，包括所有函数和HARNESS案例，并用C-x n n将其缩小到它上面
+ read all functions with $ - tili-eval-current-buffer
翻译:读取当前缓冲区中的所有函数 - 使用$进行tildify评估。
+ Instrument all functions with $ e I tili-elp-instrument-buffer
翻译:使用 `e itili-elp-instrument-buffer` 来为所有功能配备工具。
+ Run harness test with $ e h tili-elp-harness
翻译:使用$ e h tili-elp-harness运行牵引杆测试

After the tili-elp-harness function (where you can give the prefix how many times to repeat the test set; defualt is 3) has finished the elp results are shown in separate buffer from where the average of the results can determined.
翻译:在运行了tili-elp-harness函数（在这个函数中，您可以指定前缀重复测试集的次数；默认值为3）之后，ELP的结果会显示在一个单独的缓冲区中，您可以从这里确定结果的平均值。

** 15.4 Byte compilation note

If you byte compile files, the generated code is much faster thnt what the non-byte compiled one. During byte compiling, some structures are also optimized so that while they may look different in the code, the byte code is exactly the same. This means that if you should pay attention to tests that show considerable timing differencies that probably are not optimized away.
翻译:如果你编译字节码文件，生成的代码比未编译的字节码运行速度要快得多。在字节编译过程中，一些结构也会被优化，所以尽管它们在代码中看起来可能不同，但字节码是完全相同的。这意味着如果你应该关注那些显示出显著时间差异的测试，这些差异很可能没有被优化掉。

Here are som examples where you see the effect of byte compiling Pay attention to cases 1a and 1d which show you fine example how byte compilation optimizes structs.
翻译:这里有几个例子可以让你看到字节编译的效果。请注意案例1a和1d，它们展示了字节编译如何优化结构体的优秀示例。

[_1a_] Using let in function.
翻译:使用 let 关键字在函数中。

Here is one long way to read byte code. If you want to byte compile expressions withing functions, you probably want to be aware of this method too.
翻译:以下是一种阅读字节码的长方法。如果您想在函数内字节编译表达式，您可能也想了解这种方法。

#+begin_src emacs-lisp
(setq bcode     ;; Simple let with 2 variables
(byte-compile-sexp
(defun foo () (let ((a 1) (b 2)) (some-call))) ))
(disassemble bcode)
#+end_src

Here shorter way to read byte code; which produces exactly the same byte code as previous one. The disassemble compiles the sexp automatically.
翻译:这里有一个更简洁的方式来读取字节码；它产生的字节码与之前的完全相同。反编译器会自动将S-表达式编译成字节码。

#+begin_src emacs-lisp
(disassemble '(lambda () (let ((a 1) (b 2)) (some-call) )))
#+end_src

#+begin_example
byte code for foo:
args: nil
0   constant  1
1   constant  2
2   varbind   b
3   varbind   a
4   constant  some-call
5   call      0
6   unbind    2
7   return
#+end_example

[_1b_] Same as previous one, but using the call let*. Notice, that the only difference to previous one is the order how the variables are pushed into stack. In 1a case all the values were pushed there first and then popped in varbind. Internal stack depth is thus bigger in 1a and according to experts, that makes big let statements slightly slower than if one used let* for the same purpose.
翻译:与上一个例子相同，但使用了调用 let*。请注意，与前一个例子唯一不同的是变量推入堆栈的顺序。在1a的情况下，所有的值都被先推入那里，然后才在 varbind 中弹出。因此，内部堆栈深度在1a中更大，据专家称，这会使大的let语句比如果使用let*达到相同目的稍微慢一些。

#+begin_src emacs-lisp
(disassemble '(lambda () (let* ((a 1) (b 2)) (some-call) )))
#+end_src

#+begin_example
byte code:
args: nil
0   constant  1
1   varbind   a
2   constant  2
3   varbind   b
4   constant  some-call
5   call      0
6   unbind    2
7   return
#+end_example

[_1c_] Example, where let* binds previous variables. This has same byte code as 1b.
翻译:例如，当使用let*绑定先前的变量时的情况。这与1b具有相同的字节码。

#+begin_src emacs-lisp
(disassemble '(lambda () (let* ((a 1) (b a)) (some-call) )))
#+end_src

#+begin_example
byte code for foo:
args: nil
0   constant  1
1   varbind   a
2   constant  1
3   varbind   b
4   constant  some-call
5   call      0
6   unbind    2
7   return
#+end_example

[_1d_] In the following we use multiple let stetments and the byte compiling reports that the byte code is equal to 1a. A fine example how byte compiler optimizes statements.
翻译:在接下来的内容中，我们将使用多个let语句，并且字节编译报告指出字节码等于1a。这是一个很好的例子，展示了字节编译器如何优化语句。

#+begin_src emacs-lisp
(disassemble
'(lambda ()
(let ((a 1))
(let ((b 2))
(some-call) ))))
#+end_src

#+begin_example
byte code:
args: nil
0   constant  1
1   varbind   a
2   constant  2
3   varbind   b
4   constant  some-call
5   call      0
6   unbind    2
7   return
#+end_example

[_4_] Things change if there is some call between the let stetments
翻译:如果let语句之间有某种调用，事情就会改变。

#+begin_src emacs-lisp
(disassemble
'(lambda ()
(let ((a 1))
(call1)
(let ((b 2))
(call2) ))))
#+end_src

#+begin_example
byte code:
args: nil
0   constant  1
1   varbind   a
2   constant  call1
3   call      0
4   discard
5   constant  2
6   varbind   b
7   constant  call2
8   call      0
9   unbind    2
10  return
#+end_example

** 15.5 Byte compiler can optimise smartly

Let me start by and example. I was not sure what the impact of callf would be if I used it my code, so I pulled out byte compiler and dissassempled some of test defun.
翻译:让我从一个例子开始。我不确定如果在代码中使用callf会有什么影响，所以我把字节编译器拿出来反汇编了一些测试defun。

The call (callf or var 0) expand to statement (let* nil (setq var (or var 0))), so I wrote three function and compared their dissassemble results: They were identical. Generated empty let statement was optimised away.  This is a good sign that you can safely use cl macros.
翻译:调用（callf 或 var 0）展开为语句（let* nil （setq var （or var 0））），所以我编写了三个函数并比较了它们的反汇编结果：它们是完全相同的。生成的空 let 语句被优化掉了。这是一个好迹象，表明你可以安全地使用 cl 宏。

[_1_] The cl way
翻译:["The Cl Way"]

#+begin_src emacs-lisp
(defun my1 () (callf or var 0))
#+end_src

[_2_] The regular code writing way
翻译:按照常规代码编写方式

#+begin_src emacs-lisp
(defun my2 () (setq var (or var 0)))
#+end_src

[_3_] The `callf' like it would macroexpand to
翻译:`callf'就像它会展开为宏一样调用。

#+begin_src emacs-lisp
(defun my3 () (let* nil (setq var (or var 0))))
#+end_src

#+begin_example
byte code for my[1-3 are identical:
args: nil
0       varref    var
1       goto-if-not-nil-else-pop 1
4       constant  0
5:1     dup
6       varset    var
7       return
#+end_example

--------------------------------------------------------------------------------------------------------------

* 16.0 Profiling results

** 16.1 Refence functions

The format of the test function was presented by [Vladimir] and from the timing you can see how much the this wrapper affects the timings measured. Because the timing is measured from the Elapsed(accumulted time) row, here are the reference times for different loop-for values: 5 and 10 that are normally used in test.
翻译:测试函数的格式由[弗拉基米尔]提出，从时间上可以看出这个包装程序对测量时间的影响有多大。因为时间是按照Elapsed（累积时间）行来测量的，所以这里列出了不同循环for值的参考时间：5和10，这两个值通常用于测试。

#+begin_example
0.32 (10)
|      |
|      how many times function is called (loop-for count)
Elapsed time
#+end_example

#+begin_src emacs-lisp
;;  Reference function, without any extra calls
;;
(defun t01 ()                   ;; 0.16(5) 0.32(10)
(let ((i    0))
(while (< i 1000)
;;
;;  TEST CODE IS PUT HERE
;;
(setq i (1+ i)))))

;; function with one parameter
;;
(defun t02 (list)               ;; 0.16(5) 0.32(10)
(let ((i    0))
(while (< i 1000)
;;
;;  TEST CODE IS PUT HERE
;;
(setq i (1+ i)))))

(when HARNESS                                   ;; 10 times
(setq list (make-list 200 nil))
(loop-for 0 5
(t01) (t02 list) ))
#+end_src

** 16.2 How to get first element?

As you can see; there is no difference between the element retrieval functions.
翻译:如您所见，元素检索功能之间没有区别。

#+begin_src emacs-lisp
(defun t1 (list)                            ;; 0.4, car
(let ((i    0))
(while (< i 1000)
;;
(car list)
;;
(setq i (1+ i)))))

(defun t2 (list)                            ;; 0.4, nth
(let ((i    0))
(while (< i 1000)
;;
(nth 0 list)
;;
(setq i (1+ i)))))

(defun t3 (list)                            ;; 0.4,elt
(let ((i    0))
(while (< i 1000)
;;
(elt list 0)
;;
(setq i (1+ i)))))

(when HARNESS                               ;;10 times
(setq list (make-list 200 nil))
(loop-for 0 10
(t1 list) (t2 list) (t3 list)))
#+end_src

** 16.3 How to access last element?

The results were quite impressive. Naturally using the reverse command is slower, because it has to access each elemnt, where addressing last element directly is the fastest possible way.
翻译:结果相当令人印象深刻。自然地，使用反向命令会更慢，因为它需要访问每个元素，而直接访问最后一个元素是最快的方式。

#+begin_src emacs-lisp
;;  Reading the last element by counting the position.
;;
(defun t1 (list)
(let ((i    0))
(while (< i 1000)
;;
(nth (1- (length list)) list)       ;; 1.3
;;
(setq i (1+ i)))))

;; Using the reverse command
;;
(defun t2 (list)
(let ((i   0))
(while (< i 1000)
;;
(car (reverse list))                ;; 8.0
;;
(setq i (1+ i)))))

(when HARNESS                               ;;3 times
(setq list (make-list 200 nil))
(loop-for 0 5
(t1 list) (t2 list)  ))
#+end_src

** 16.4 Which loop method is faster?

There seems to be huge diffrence between while and mapcar. probably due to function call the mapcar does every time when passing element to lambda function.
翻译:在函数式编程中，“while”和“mapcar”之间的区别可能非常大，这主要是因为“mapcar”在对元素传递给lambda函数时每次都会进行函数调用。

#+begin_src emacs-lisp
(defun t1 (list)                            ;; 28, mapcar
(let ((i    0))
(while (< i 1000)
;;
(mapcar '(lambda (x) nil) list)
;;
(setq i (1+ i)))))

(defun t2 (list)                            ;; 0.2, while
(let ((i    0))
(while (< i 1000)
;;
(while list nil (setq list (cdr list)))
;;
(setq i (1+ i)))))

(when HARNESS                               ;;3 times
(setq list (make-list 200 nil))
(loop-for 0 5
(t1 list) (t2 list) ))
#+end_src

** 16.5 Adding to list fast

If I want to append things to a list, should I do it with append or with nconc or cons? So that results are comparable to each other, every function must return the list in the same order and that's why you see nreverse calls prior returning the list in some functions.
翻译:如果您想向列表中添加元素，应该使用append、nconc还是cons？为了让结果具有可比性，每个函数必须以相同的顺序返回列表，这就是为什么在某些函数在返回列表之前会看到nreverse调用的原因。

#+begin_src emacs-lisp
(defun t11 ()                           ;;3.3, nconc 1
(let ((i    0)
list)
(while (< i 1000)
;;
(setq list (nconc list (list i)))
;;
(setq i (1+ i)))
list))   ;; (0 1 2 3 ..)

;;  Traditional nconc
;;
(defun t12 ()                           ;; 3.3, nconc 2
(let ((i    0)
list)
(while (< i 1000)
;;
(if (null list)
(setq list (list i))
(nconc list (list i)))
;;
(setq i (1+ i)))
list))   ;; (0 1 2 3 ..)

(defun t21 ()                           ;; 24.0, append to end
(let ((i    0)
list)
(while (< i 1000)
;;
(setq list (append list (list i)))
;;
(setq i (1+ i)))))

(defun t22 ()                           ;; 0.5, append to beg
(let ((i    0)
list)
(while (< i 1000)
;;
(setq list (append (list i) list))
;;
(setq i (1+ i)))
(nreverse list)))  ;; (0 1 2 3 ..)

(defun t3 ()                            ;; 0.7, list*
(let ((i    0)
list)
(while (< i 1000)
;;
(setq list (list* 1 list))
;;
(setq i (1+ i)))
(nreverse list)))   ;; (0 1 2 3 ..)

(defun t4 ()                            ;; 1.0, push
(let ((i    0)
list)
(while (< i 1000)
;;
(push i list)
;;
(setq i (1+ i)))
(nreverse list)))    ;; (0 1 2 3 ..)

(defun t5 ()                            ;; 0.3, cons
(let ((i    0)
list)
(while (< i 1000)
;;
(setq list (cons i list))
;;
(setq i (1+ i)))
(nreverse list)))    ;; (0 1 2 3 ..)

(when HARNESS                               ;; 3 times
(loop-for 0 5
(t11) (t12) (t21) (t22) (t3) (t4) (t5) ))
#+end_src

Wow. using append to add to the end of list is enermously slower than when compared to fastest way cons. You should only use append to add to the beginning of list.
翻译:哇。使用append在列表末尾添加元素的速度与最快的cons方式相比慢得多。您应该只使用append在列表开头添加元素。

[Vladimir]
翻译:[弗拉基米尔]。

This is expected. For every call, append traverses to the end of the list, making a copy along the way, then adds a new element at the end, then discards the old list. This may even lead to garbage collection, which can take unpredictably long.
翻译:这是预料之中的。对于每一次调用，都会在列表末尾追加遍历操作，沿途复制一份，然后添加一个新的元素到末尾，接着丢弃旧的列表。这甚至可能导致垃圾回收，其耗时可能不可预测。

nconc is better in that it doesn't copy the list ("doesn't cons", which means that doesn't create new conses.  Cons creation is quick when the new cons is taken from the free cons list, but if that is exhausted, memory allocation should be done). However, nconc still traverses the list at every iteration.
翻译:在这一点上，`nconc` 更优秀，因为它不会复制列表（“不进行 cons 操作”，这意味着不会创建新的 cons 结构。当新的 cons 从空闲 cons 列表获取时，cons 的创建速度很快，但如果这个列表耗尽，就需要分配内存）。然而，`nconc` 在每次迭代中仍然会遍历列表。

cons just adds a new cell at the beginning. append and nconc take O(n^2/2): when the list length is l they perform O(l) operations to traverse the list. cons has amortized cost O(1) (ie constant). "Amortized" means that it may cause memory allocation and/or garbage collection every once in a while, but most of the time it won't.
翻译:“cons只是在开头添加一个新的单元格。append和nconc的时间复杂度为O(n^2/2)：当列表长度为l时，它们需要执行O(l)的操作来遍历列表。而cons的平均时间复杂度是O(1)，也就是说，它的常数时间内完成操作。这里的‘平均’意味着它可能会偶尔引起内存分配和/或垃圾回收，但大多数时候不会。”

** 16.6 How to copy a alist fast

Idea by Morten Welinder [[mailto:terra@diku.dk][terra@diku.dk]] (copy-sequence minor-mode-alist) only copies the cdr structure of the list (mapcar 'copy-sequence minor-mode-alist) ought to copy the pairs in the alist `copy-alist copies' list structure and pairs: it does slightly more than we need but it is much faster.
翻译:由Morten Welinder提出[[mailto:terra@diku.dk][terra@diku.dk]]（复制序列最小模式列表）仅复制列表的cdr结构（mapcar 'copy-sequence minor-mode-alist）应该复制alist中的对（`copy-alist copies`列表结构和一对：它做的稍微多一点，但速度要快得多。）

#+begin_src emacs-lisp
(defun t1 (list)                                ;; 3.5
(let ((i    0))
(while (< i 100)
;;
(mapcar 'copy-sequence list)
;;
(setq i (1+ i)))))

(defun t2 (list)                                ;; 2.5
(let ((i    0))
(while (< i 100)
;;
(copy-list list)
;;
(setq i (1+ i)))))

(when HARNESS                                   ;;10 times
;; Make '((t 1) (t 1) ..) list first.
(setq list (mapcar '(lambda (x) (list x 1)) (make-list 100 t)))
(loop-for 0 10
(t1 list) (t2 list) ))
#+end_src

** 16.7 Let: is using let* slower than let

See explanation in [[http://www.nongnu.org/emacs-tiny-tools/elisp-coding/index-body.html#let_is_using_let_slower][(benchmarks)]] which explains the unexpected result where let* is marginally faster.
翻译:查看[[http://www.nongnu.org/emacs-tiny-tools/elisp-coding/index-body.html#let_is_using_let_slower][(基准测试)]]中的解释，它说明了让let*稍微快一点的意外结果。

[Vladimir]
翻译:好的

From common sense, it wouldn't matter how you arrange your lets and how you init the vars, even if your function is called in a long loop. The function call time will still dominate the lets. If fc=100 and let=1, a second let will only add 1% to the overall time. The only time it matters is when the inner let is inside a loop, in which case it will probably pay to take it outside.
翻译:从常识来看，无论你怎么安排你的let和如何初始化变量，即使你的函数在一个长循环中被调用，函数调用的耗时仍然会占据主导地位。如果fc=100且let=1，第二个let只会使整体时间增加1%。只有在内层let位于一个循环之中时，它才会变得重要，在这种情况下，将其移出循环可能会带来好处。

We'll find that using let inside loop (defining variable j again and again) slightly decreases the performance. Yes, only slightly, because you don't normally use 1000 let statements in your function. This would also suggest that even if you put several let statements into the function, that wouldn't be be very much slower that using just one let statement at the beginning of file.
翻译:我们在使用循环中的let（再次定义变量j）时会发现性能略有下降。是的，只是稍微一点，因为你通常不会在你的函数中使用1000个let语句。这也表明，即使你在函数中放入几个let语句，那也不会比在文件开头只使用一个let语句慢很多。

#+begin_src emacs-lisp
(t01)                               ;; 0.32, without let

(defun t1 ()                        ;; 0.7, let
(let ((i 0))
(while (< i 1000)
;;
(let (j) )
;;
(setq i (1+ i)))))

(defun t2 ()                        ;; 0.6 let*
(let ((i 0))
(while (< i 1000)
;;
(let* (j) )
;;
(setq i (1+ i)))))

(when HARNESS                       ;;10 times
(loop-for 0 10
(t1) (t2)  ))
#+end_src

It seems that there is not much difference in tested emacs. I wouldn't be that thrilled of the results, but I'd guess that let* would have been definitely slower that let. Let try with variation where let* is used for the purpose is it meant to: binding previous values's content.
翻译:在测试过的emacs中，似乎没有太大的区别。我对这些结果不会太兴奋，但我想let*肯定比let慢。让我们尝试一下变体，其中使用let*的目的正是它所要达到的：绑定前一个值的内容。

#+begin_src emacs-lisp
(defun t1 ()                        ;; 1.2, let
(let ((i 0))
(while (< i 1000)
;;
(let ((a 0) (b 1) (c 1) (d 1) (e 1))   )
;;
(setq i (1+ i)))))

(defun t2 ()                        ;; 1.1 let*
(let ((i 0))
(while (< i 1000)
;;
(let* ((a 0) (b 1) (c b) (d c) (e d)) )
;;
(setq i (1+ i)))))

(when HARNESS                       ;;10 times
(loop-for 0 10
(t1) (t2)  ))
#+end_src

Hm. While the let* binds previous variables values to successive ones, there still doesn't seem to be a big difference. Don't pay attention to marginal 0.1 advantage which let* seems to have gained.
翻译:嗯。尽管let*将前一个变量的值绑定到后续的变量上，但似乎仍然没有太大的区别。不要关注let*似乎获得的微小的0.1优势。

** 16.8 Let: or function arg list

Some times I only need one variable and I have a bad habbit of defining it in the function call argument list to save typing and indentation of let call. Like following.
翻译:有时候我只需要一个变量，我有一个坏习惯，就是在函数调用参数列表中定义它以节省打字和缩进的工作量。就像下面这样。

#+begin_src emacs-lisp
(setq xxx-function
'(lambda (&optional ignore)
(if (setq ignore (my-call-someone))
(symbol-value ignore))))
#+end_src

Above I only needed one variable, that I named ignore, and used it to record the return status of function.  But does this buy anything for me? lets find out.
翻译:在上面我只需要一个变量，我将它命名为ignore，用来记录函数的返回状态。但是这能给我带来什么好处呢？让我们来找出答案。

#+begin_src emacs-lisp
(defun  t1 (&optional a) (setq a (ignore)))     ;; 0.11
(defun  t2 () (let (a) (setq a (ignore))))      ;; 0.12

(defun t11 ()
(let ((i    0))
(while (< i 100)
;;
(t1)
;;
(setq i (1+ i)))))

(defun t22 ()
(let ((i    0))
(while (< i 100)
;;
(t2)
;;
(setq i (1+ i)))))

(when HARNESS                                   ;; 3 times
(setq hook nil)
(loop-for 0 10
(t11) (t22) ))
#+end_src

If doesn't seem to matter much. I have just had a bad habbit and I should get rid of it.
翻译:这看起来并不重要。我刚刚养成了一种坏习惯，我应该戒掉它。

** 16.9 Variables: count of them

The count of variables starts gradually affecting the performance. Decide yourself how big threath using many variables is to your function: usually there are other statements that affect the overall perfomance of the function much more. The function call alone takes considerable amount of time when compared to sole let statement.
翻译:变量的数量开始逐渐影响性能。自行决定使用许多变量对你的函数构成多大的威胁：通常还有其他语句对函数的整体性能影响更大。与单独的`let`语句相比，函数调用本身需要花费相当长的时间。

#+begin_src emacs-lisp
(defun t1 ()                        ;; 0.5
(let ((i 0))
(while (< i 1000)
;;
(let* (a1 a2 a3) )
;;
(setq i (1+ i)))))

(defun t2 ()                        ;; 0.7 2x more variables
(let ((i 0))
(while (< i 1000)
;;
(let* (a1 a2 a3 a4 a5 a6) )
;;
(setq i (1+ i)))))

(defun t3 ()                        ;; 0.9 3x more variables
(let ((i 0))
(while (< i 1000)
;;
(let* (a1 a2 a3 a4 a5 a6 a7 a8 a9) )
;;
(setq i (1+ i)))))

(when HARNESS                                   ;; 3 times
(loop-for 0 10
(t1) (t2) (t3) ))
#+end_src

** 16.10 Variables: using let or setq

I always question myself, does it make difference shere I set the variables value. Some times If I complex initializations I would like to declare variable (not set it) in let stament and leave the initializing after the let. This seems to indicate that using the let to set the variables is better.
翻译:我经常问自己，我在哪里设置变量的值是否有区别。有时候，如果我进行复杂的初始化，我希望在let语句中声明变量（不设置它），然后在let之后进行初始化。这表明使用let来设置变量是更好的选择。

#+begin_src emacs-lisp
(defun t1 ()                                    ;; 2.7
(let ((i 0))
(while (< i 1000)
;;
(let ((str1 (format "%s" "1"))
(str2 (format "%s" "1"))
(str3 (format "%s" "1"))
(str4 (format "%s" "1")))
;;
(setq i (1+ i))))))

(defun t2 ()                                    ;; 3.5
(let ((i 0))
(while (< i 1000)
;;
(let (str1 str2 str3 str4)
(setq str1 (format "%s" "1")
str2 (format "%s" "1")
str3 (format "%s" "1")
str4 (format "%s" "1")))
;;
(setq i (1+ i)))))

(when HARNESS                                   ;;10 times
(loop-for 0 10
(t1) (t2) ))
#+end_src

** 16.11 Variables: many *setq* commands

Yes they do. Using one setq command is naturally faster than many of them. For comparision there is t0 function which does the same, but does not use setq at all.
翻译:是的，它们是这样的。使用一组setq命令自然比许多命令要快得多。相比之下，有t0函数也做了同样的事情，但完全没有使用setq。

#+begin_src emacs-lisp
;;  Reference function
;;
(defun t0 ()                                    ;; 1.1
(let ((i 0))
(while (< i 1000)
;;
(let ((a 1) (b 1) (c 1) (d 1) (e 1) (f 1) (g 1) ))
;;
(setq i (1+ i)))))

(defun t1 ()                                    ;; 1.4
(let ((i 0))
(while (< i 1000)
;;
(let (a b c d e f g)
(setq a 1  b 1 c 1 d 1 e 1 f 1 g 1))
;;
(setq i (1+ i)))))

(defun t2 ()                                    ;; 1.9
(let ((i 0))
(while (< i 1000)
;;
(let (a b c d e f g)
(setq a 1) (setq b 1 ) (setq c 1 ) (setq d 1 )
(setq e 1) (setq f 1 ) (setq g 1 ))
;;
(setq i (1+ i)))))

(when HARNESS                                   ;;3 times
(loop-for 0 10
(t0) (t1) (t2)  ))
#+end_src

** 16.12 If and cond, which is faster one?

Neither. Common sense tells you that too: this is actually a stupid test, but I was curious what elp says.  From here you can see that elp.el isn't that bad if you use it for timing.
翻译:不客气。常识也会告诉你这一点：这实际上是个愚蠢的测试，但我很好奇elp会说什么。从这里你可以看出，如果你用它来计时，那么elp.el其实还不错。

#+begin_src emacs-lisp
(defun t1 ()                                    ;; 0.4
(let ((i 0))
(while (< i 1000)
;;
(if t nil)
;;
(setq i (1+ i)))))

(defun t2 ()                                    ;; 0.4
(let ((i 0))
(while (< i 1000)
;;
(cond (t nil))
;;
(setq i (1+ i)))))

(when HARNESS                                   ;;10 times
(loop-for 0 10
(t1) (t2) ))
#+end_src

** 16.13 Concat and format commands

I have very hard time to determine which elp results would describe the average timing difference. I ran the elp test several times, but the deviation between the results were too big to give any reliable estimate. Be very skeptical.
翻译:我很难确定哪些elp结果可以描述平均时间差。我运行了多次elp测试，但结果之间的偏差太大，无法给出任何可靠的估计。要非常怀疑。

#+begin_src emacs-lisp
(defun t1 ()                                    ;; 1.2
(let ((i 0))
(while (< i 1000)
;;
(concat "1" "2" "3" "4" "5" "6" "7" "8")
;;
(setq i (1+ i)))))

(defun t2 ()                                    ;; 1.0
(let ((i 0))
(while (< i 1000)
;;
(format "%s%s%s%s%s%s%s%s"
"1" "2" "3" "4" "5" "6" "7" "8")
;;
(setq i (1+ i)))))

(when HARNESS                                   ;; 5 times
(loop-for 0 10
(t1) (t2) ))
#+end_src

** 16.14 Using *if* before running run-hooks

I just wonder if it makes sense to test hook contents before running it. Why should I call function run-hooks if there is nothing in a hook? From the results point of view, the there is small time difference: we prevent a function call to run-hooks.
翻译:我只是想知道在运行钩子之前测试钩子内容是否有意义。如果钩子里什么都没有，为什么要调用函数run-hooks呢？从结果的角度来看，时间差异很小：我们防止了一次对run-hooks函数的调用。

#+begin_src emacs-lisp
(defun t1 ()
(let ((i 0))
(while (< i 1000)
;;
(run-hooks 'hook)                         ;;0.83
;;
(setq i (1+ i)))))

(defun t2 ()
(let ((i 0))
(while (< i 1000)
;;
(if hook (run-hooks 'hook))
;;
(setq i (1+ i)))))

(when HARNESS                                   ;; 0.41
(defconst hook nil "temp hook variable")
(loop-for 0 10
(t1) (t2) ))
#+end_src

** 16.15 Returning boolean or *data* from function

Supposes you have some data in some variable, but you wonder does ot make a difference to return that data to calling program or just plain boolean t or nil
翻译:假设您有一些数据存储在某个变量中，但您想知道返回这些数据给调用程序与直接返回布尔值 true 或 nil 有没有区别。

Consider that we have some string data that we could return to mean True value, or success. The t2 changes the final return value to boolean.
翻译:我们将一些字符串数据视为返回真值或成功的条件。t2变量将最终的返回值更改为布尔值。

#+begin_src emacs-lisp
;; Remark: this is actually not a very good test set.
;;
(defun  t1 () (let ((ret a)) (setq ret a) ret))
(defun  t2 () (let ((ret a)) (setq ret a) (setq ret t) ret))

(when HARNESS                               ;; 3 times
(setq a (make-string (* 2 80) ?a))
(loop-for 0 500
(t1)                                     ;; 0.13
(t2)))                                   ;; 0.13

#+end_src

No, it doesn't seem to make any difference, so we just return anything we have already in the variable.
翻译:不，这似乎没有区别，所以我们只需要返回变量中已经存在的任何内容。

[Vladimir] ...There is nothing that could slow down the t1 function, because returning the variable does not make copy of it, it only delays garbage collection of that structure for a while.
翻译:[弗拉基米尔]……没有什么可以减慢t1函数的速度，因为返回变量并不会创建它的副本，它只是延迟了该结构的垃圾回收而已。

** 16.16 Calling length or using len variable

If you use the length of list in many places, calculating it every time with length function decreases performance considerably.
翻译:如果你在很多地方使用列表的长度，每次都用length函数计算会大大降低性能。

#+begin_src emacs-lisp
(defun t1 ()                                   ;; 2.3
(let ((i 0))
(while (< i 1000)
;;
(progn  (length list) (length list) (length list))
;;
(setq i (1+ i)))))

(defun t2 ()
(let ((i 0)
(len (length list)))                    ;; 0.5
(while (< i 1000)
;;
(progn  len len len)
;;
(setq i (1+ i)))))

(when HARNESS                                   ;; 3 times
(setq list (make-list 100 nil))
(loop-for 0 10
(t1) (t2) ))
#+end_src

--------------------------------------------------------------------------------------------------------------

* 17.0 Xemacs and Emacs compatibility

** 17.1 About compatibility

During development of my packages I run into many incompatibities not only between Emacs and XEmacs, but also between Emacs version. If you care to write XEmacs and Emacs compatible code without hashless, I'd recommend using fucntions from my main library: they offer transparent interface to certain Emacs and XEmacs specific features. See these libraries and funcktions
翻译:在开发我的包的过程中，我遇到了许多不兼容性问题，不仅存在于Emacs和XEmacs之间，而且存在于不同版本的Emacs之间。如果您愿意编写既适用于Emacs又适用于XEmacs且不带哈希的无兼容性代码，我建议使用我主库中的函数：它们为某些特定于Emacs和XEmacs的功能提供了透明的接口。请参阅这些库和函数。

#+begin_example
tinylib.el   -- functions ti::xe-*
tinylibxe.el -- XEmacs and Emacs emulation library
#+end_example

** 17.2 Overlay and extent compatibility

Good news! XEmacs 19.15 now has package overlay.el which mimics the calls of Emacs overlay functions. This means, that you no longer need to try to accomodate both Emacs(overlay) and XEmacs(extent) commands into your code. Following is enough to make your overlay code work in XEmacs.
翻译:好消息！XEmacs 19.15 现在有了 package overlay.el，它模仿了 Emacs overlay 函数的调用。这意味着，您不再需要在代码中尝试同时适应 Emacs（overlay）和 XEmacs（extent）命令。以下代码就足以让您的 overlay 代码在 XEmacs 中运行。

#+begin_src emacs-lisp
(eval-and-compile
(if (xemacs-p)
(load "overlay")))
#+end_src

** 17.3 Portable Menus

Don't use Emacs specific menus, but see easymenu.el and compose your menus with it. Below you see a very simple minor mode and it's menu definition. The menu appears when the minor mode is turned on and disappears when the minor mode is turned off (at least in Emacs). Pay attention to the Selection 3 that can be enabled and disabled on the fly.
翻译:不要使用Emacs特定的菜单，但查看easymenu.el并使用它来编写您的菜单。下面您看到一个非常简单的minor模式及其菜单定义。当minor模式打开时，菜单会出现，而当minor模式关闭时（至少在Emacs中）会消失。请注意可以随时启用和禁用的选择3。

Note: The easymenu's enable/disable choice is buggy in Emacs 19.28 - 19.34 (in non-windowed mode), so if the progn tests at the end of file fail, don't mind that. Newer Emacs releases have fixed the problems.
翻译:您提到的 `easymenu` 在 Emacs 19.28 至 19.34 版本（在非窗口模式下）中启用/禁用选择存在故障，因此如果在文件末尾的 progn 测试失败，请不要担心。新版本的 Emacs 已经修复了这些问题。

#+begin_src emacs-lisp
;; test.el -- Just sample .el file

(require 'easymenu)
(require 'cl)

(defconst my-map (make-sparse-keymap))
(defconst my-menu nil)
(defconst my-mode nil)
(defvar   my-flag nil)

(define-key my-map "ez1" 'my-1)
(define-key my-map "ez2" 'my-2)
(define-key my-map "ez3" 'my-3)

(easy-menu-define
my-menu
(if (boundp 'xemacs-logo) nil (list my-map))
"My test menu"
(list
"My Menu"
["Selection 1" my-1 t]
;;
;;  X window note:
;;  Works in 19.14, but not in Emacs.
;;
;;  This is a bug in 19.34 but will be
;;  corrected to later release
;;
["Selection 2" my-2 nil]
;;
;;  let's try something more fancier here.
;;
["Selection 3" my-3 (get 'my-menu 'menu-flag) ]))

;;  Add mode to minor mode list
;;
(unless my-flag                         ;Add only once
(setq my-flag t)
(push (cons 'my-mode my-map)  minor-mode-map-alist))

(defun my-1 () (interactive) (message "1"))
(defun my-2 () (interactive) (message "2"))
(defun my-3 () (interactive) (message "3"))

;;   Toggle mode and add the menu, not the menu is available
;;
(setq my-mode nil)
(setq my-mode t)
(easy-menu-add my-menu)

;; X window note:
;; Trying this does not enable choice "3" in XEmacs 19.14
;; In Emacs 19.30 it works ok.
;;
;; (progn (put 'my-menu 'menu-flag t) (force-mode-line-update))
;; (progn (put 'my-menu 'menu-flag nil) (force-mode-line-update))

;; Another Test, you need this in XEmacs, but not actually
;; in Emacs. --> Use it for portability.
;;
;; (easy-menu-remove my-menu)

;; end of code
#+end_src

** 17.4 List of simple incompatibilities.

Here is a small list of functions that do not work in both emacs versions.
翻译:以下是小列表，列出了在两个emacs版本中都不起作用的函数：

+ force-mode-line-update, XEmacs, labeled as obsolete
翻译:强制模式行更新，XEmacs，标记为已废弃。
+ mailabbrev package, XEmacs, calls it mail-abbrevs
翻译:邮件缩写包，XEmacs 中称之为 mail-abbrevs。
+ transient-mark-mode, does not exist in XEmacs 19.14
翻译:暂态标记模式在XEmacs 19.14中不存在。
+ mailabbrev package, XEmacs, calls it mail-abbrevs
翻译:邮件缩写包，XEmacs 中称之为 mail-abbrevs。
+ eval-after-load, XEmacs, function does not exist in 19.14 Use instead:
翻译:在XEmacs 19.14中，`eval-after-load`函数不存在了。请使用以下替代方法：

#+begin_src emacs-lisp
(defvar XXX-package-load-hook nil "")
..code..
(run-hooks 'XXX-package-load-hook)
;; End of package XXX.el
#+end_src

XEmacs 19.15 and 20.1 does have this form though.
翻译:XEmacs 19.15和20.1确实有这种形式。

** 17.5 Hash table compatibility

Hrvoje Niksic [[mailto:hniksic@srce.hr][hniksic@srce.hr]] 17 May 1997 comp.emacs.xemacs
翻译:赫沃耶·尼基西奇[[<mailto:hniksic@srce.hr>][hniksic@srce.hr]] 1997年5月17日 comp.emacs.xemacs

Use CL package's hash function which are compatible with Common Lisp and GNU Emacs. They use XEmacs hashtables on XEmacs and emulate CL hashtables on GNU Emacs.
翻译:使用CL包中的哈希函数，它们与Common Lisp和GNU Emacs兼容。在XEmacs上，它们使用XEmacs散列表；而在GNU Emacs上，则模拟CL散列表。

#+begin_src emacs-lisp
(let ((foo (make-hash-table :test 'equal)))
(setf (gethash "David" foo) 'cool)
(setf (gethash "Hrvoje" foo) 'wow)
...

foo
=> #<hashtable 2/29 0x1ef7>
#+end_src

Now, if you want to dump the hash-table anywhere, the simplest thing to do is dump it to a list. For example, your program crunches data in and out of hashtable for
翻译:现在，如果您想将哈希表转储到任何地方，最简单的方法是将它转储到一个列表中。例如，您的程序在哈希表中输入和输出数据。

#+begin_src emacs-lisp
(let (alist)
(maphash (lambda (key val)
(push (cons key val) alist))
foo)
alist)
=> (("Hrvoje" . wow) ("David" . cool))
#+end_src

There you have all your entries in alist, which you can print, save to file etc. All of this is, of course, much faster than if you had used an alist all the time, since the search time would have been O(n) instead of much better hashtable characteristics.
翻译:您已经拥有了alist中的所有条目，您可以打印它们、保存到文件等。当然，这比一直使用alist要快得多，因为搜索时间将是O(n)，而不是哈希表的更好特性。

** 17.6 Character handling changes

If you had any character tests in your code, it will likely break in XEmacs20 and Emacs20, where a single integer does no longer present a charcter code. Beware especially contructs where you read characters directly and test the input:
翻译:如果你在你的代码中使用了任何字符测试，那么在XEmacs20和Emacs20中很可能会出错，因为在这些环境中，单个整数不再表示一个字符代码。特别是要注意那些直接读取字符并进行输入测试的结构：

#+begin_src emacs-lisp
(setq ch (read-char))
(if (memq ch '(?y ?Y))
...
#+end_src

That will no longer work as expected. Also if you have test like this
翻译:这将不再按预期工作。此外，如果您有类似的测试

#+begin_src emacs-lisp
(if (eq (following-char) ?.)
...
#+end_src

Those will fail also because you can't use old operators like eq. In my latest 'm' library there is emulation for some of the following functions that are from XEmacs20's documentation. The above example can now be converted into
翻译:这些也会失败，因为你不能使用旧的运算符，比如eq。在我的最新'm'库中，为了一些来自XEmacs20文档的功能提供了模拟实现。上面的例子现在可以转换成

#+begin_src emacs-lisp
(require 'tinylibm)
(if (char-in-list-case ch '(?y ?Y))

(if (char= (following-char) ?.)
#+end_src

And the code will work in every Emacs 19.28+, XEmacs 19.14+.
翻译:代码将在每个Emacs 19.28+、XEmacs 19.14+中运行。

*** 17.6.1 Characterp: (object), XEmacs20

t if OBJECT is a character. Unlike in FSF Emacs, a character is its own primitive type. Any character can be converted into an equivalent integer using char-to-int. To convert the other way, use int-to-char; however, only some integers can be converted into characters. Such an integer is called a char-to-int; see char-int-p.
翻译:如果你要处理的对象是字符。与FSF Emacs不同，字符是其自己的基本类型。任何字符都可以使用char-to-int转换为等效的整数。如果要反向转换，请使用int-to-char；然而，并非所有整数都可以转换为字符。这种整数称为char-to-int；请参阅char-int-p。

Some functions that work on integers (e.g. the comparison functions <, <=, =, /=, etc. and the arithmetic functions +, -, *, etc.) accept characters and implicitly convert them into integers. In general, functions that work on characters also accept char-ints and implicitly convert them into characters. WARNING: Neither of these behaviors is very desirable, and they are maintained for backward compatibility with old E-Lisp programs that confounded characters and integers willy-nilly. These behaviors may change in the future; therefore, do not rely on them. Instead, use the character-specific functions such as char=.
翻译:整数函数（例如比较函数<、<=、=、/=等以及算术函数+、-、*等）可以接受字符作为输入并隐式转换为整数。通常情况下，那些处理字符的函数也可以接受char-int类型的参数并将其隐式转换为字符。警告：这两种行为都不太理想，它们被保留是为了向后兼容旧的E-Lisp程序，这些程序随意地将字符和整数混淆在一起。将来这些行为可能会改变；因此，不要依赖它们。相反，应该使用诸如char=这样的特定于字符的函数。

*** 17.6.2 Char-int (ch) XEmacs20

– a built-in function. Convert a character into an equivalent integer. The resulting integer will always be non-negative. The integers in the range 0 - 255 map to characters as follows:
翻译:– 一个内置函数。将字符转换为等效整数。生成的整数始终为非负数。在0-255范围内的整数映射到字符如下：

#+begin_example
0 - 31      Control set 0
32 - 127    ASCII
128 - 159   Control set 1
160 - 255   Right half of ISO-8859-1
#+end_example

If support for Mule does not exist, these are the only valid character values. When Mule support exists, the values assigned to other characters may vary depending on the particular version of XEmacs, the order in which character sets were loaded, etc., and you should not depend on them.
翻译:如果不存在对Mule的支持，这些才是唯一有效的字符值。当存在对Mule的支持时，分配给其他字符的值可能因XEmacs的具体版本、字符集加载的顺序等因素而异，你不应该依赖它们。

*** 17.6.3 Char-to-int: (ch) XEmacs20

– a built-in function. Convert a character into an equivalent integer. The resulting integer will always be non-negative. The integers in the range 0 - 255 map to characters as follows:
翻译:– 一个内置函数。将字符转换为等效整数。生成的整数始终为非负数。在0-255范围内的整数映射到字符如下：

#+begin_example
0 - 31          Control set 0
32 - 127        ASCII
128 - 159       Control set 1
160 - 255       Right half of ISO-8859-1
#+end_example

If support for Mule does not exist, these are the only valid character values. When Mule support exists, the values assigned to other characters may vary depending on the particular version of XEmacs, the order in which character sets were loaded, etc., and you should not depend on them.
翻译:如果不存在对Mule的支持，这些是唯一有效的字符值。当存在Mule支持时，分配给其他字符的值可能因XEmacs的具体版本、字符集加载的顺序等因素而异，你不应该依赖它们。

*** 17.6.4 Int-to-char: (integer) XEmacs20

– a built-in function. Convert an integer into the equivalent character. Not all integers correspond to valid characters; use char-int-p to determine whether this is the case. If the integer cannot be converted, nil is returned.
翻译:– 内置函数。将整数转换为等效字符。并非所有整数都对应有效的字符；使用char-int-p来确定是否如此。如果无法转换整数，则返回nil。

*** 17.6.5 Char-int-p: (object) XEmacs20

– a built-in function. t if OBJECT is an integer that can be converted into a character. See char-to-int.
翻译:如果你上传了一张图片并询问我关于图片中的内容，我会根据图片中的信息尽可能为你提供详细的解答和相关信息。

请注意，由于我是一个基于文本的人工智能助手，我不能直接查看或分析图片内容。你需要先将图片中的信息转换为文本形式，然后才能向我提问。你可以使用各种工具和方法来做到这一点，例如：

1. 使用OCR（光学字符识别）软件将图片中的文字转换成可编辑的文本格式；
2. 将图片描述出来，然后用键盘输入这些描述性文字；
3. 如果图片中有特定的符号、图案或者其他可以转化为文本的信息，你也可以尝试将其数字化或者用其他方式记录下来。

一旦你有了相关的文本信息，就可以用它来向我提问了。我会尽我所能为你提供帮助。

*** 17.6.6 Char-equal function (c1 c2 &optional buffer) XEmacs20.0

– a built-in function. Return t if two characters match, optionally ignoring case. Both arguments must be characters (i.e. NOT integers). Case is ignored if case-fold-search is non-nil in BUFFER. If BUFFER is nil, the current buffer is assumed.
翻译:- 一个内置函数。如果两个字符匹配（可选地忽略大小写），则返回t。两个参数必须是字符（即不是整数）。如果在BUFFER中case-fold-search不为nil，则忽略大小写。如果BUFFER为nil，则假定当前缓冲区。

*** 17.6.7 Char= (c1 c2 &optional buffer) XEmacs20.1

– a built-in function. Return t if two characters match, case is significant. Both arguments must be characters (i.e. NOT integers). The optional buffer argument is for symmetry and is ignored.
翻译:- 一个内置函数。如果两个字符匹配则返回t，区分大小写。两个参数必须是字符（即不是整数）。可选的缓冲区参数是为了对称性而忽略的。
--------------------------------------------------------------------------------------------------------------
